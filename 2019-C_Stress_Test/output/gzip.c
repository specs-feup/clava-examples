#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <malloc.h>
#include <memory.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/dir.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <utime.h>
/*config.h.  Generated by configure.*/

/*config.h.in.  Generated from configure.in by autoheader.*/

/*Define if an assembler version of longest_match is available.*/

/*#undef ASMV*/

/*Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
*/

/*Define to 1 if you have the <fcntl.h> header file.*/

/*Define to 1 if you have the <inttypes.h> header file.*/

/*Define to 1 if you have the <limits.h> header file.*/

/*Define to 1 if you have the `lstat' function.*/

/*Define to 1 if you have the <memory.h> header file.*/

/*Define to 1 if you have the <ndir.h> header file, and it defines `DIR'.*/

/*#undef HAVE_NDIR_H*/

/*Define to 1 if you have the `rpmatch' function.*/

/*#undef HAVE_RPMATCH*/

/*Define to 1 if you have the <stdint.h> header file.*/

/*Define to 1 if you have the <stdlib.h> header file.*/

/*Define to 1 if you have the <strings.h> header file.*/

/*Define to 1 if you have the <string.h> header file.*/

/*Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
*/

/*#undef HAVE_SYS_DIR_H*/

/*Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
*/

/*#undef HAVE_SYS_NDIR_H*/

/*Define to 1 if you have the <sys/stat.h> header file.*/

/*Define to 1 if you have the <sys/types.h> header file.*/

/*Define to 1 if you have the <sys/utime.h> header file.*/

/*#undef HAVE_SYS_UTIME_H*/

/*Define to 1 if you have the <time.h> header file.*/

/*Define to 1 if you have the <unistd.h> header file.*/

/*Define to 1 if you have the `utime' function.*/

/*Define to 1 if you have the <utime.h> header file.*/

/*Name of package*/

/*Define to the address where bug reports for this package should be sent.*/

/*Define to the full name of this package.*/

/*Define to the full name and version of this package.*/

/*Define to the one symbol short name of this package.*/

/*Define to the version of this package.*/

/*Define as the return type of signal handlers (`int' or `void').*/

/*Define to 1 if you have the ANSI C header files.*/

/*Version number of package*/

/*Define to 1 if on AIX 3.
System headers sometimes define this.
We just want to avoid a redefinition error message.*/

/*# undef _ALL_SOURCE*/

/*Number of bits in a file offset, on hosts where this is settable.*/

/*Enable GNU extensions on systems that have them.*/

/*Define for large files, on AIX-style hosts.*/

/*#undef _LARGE_FILES*/

/*Define to 1 if on MINIX.*/

/*#undef _MINIX*/

/*Define to 2 if the system does not provide POSIX.1 features except with
this defined.*/

/*#undef _POSIX_1_SOURCE*/

/*Define to 1 if you need to in order for `stat' and other things to work.*/

/*#undef _POSIX_SOURCE*/

/*Define to empty if `const' does not conform to ANSI C.*/

/*#undef const*/

/*Define to `long' if <sys/types.h> does not define.*/

/*#undef off_t*/

/*Define to `unsigned' if <sys/types.h> does not define.*/

/*#undef size_t*/

/*bits.c -- output variable-length bit strings
* Copyright (C) 1992-1993 Jean-loup Gailly
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

/*
*  PURPOSE
*
*      Output variable-length bit strings. Compression can be done
*      to a file or to memory. (The latter is not supported in this version.)
*
*  DISCUSSION
*
*      The PKZIP "deflate" file format interprets compressed file data
*      as a sequence of bits.  Multi-bit strings in the file may cross
*      byte boundaries without restriction.
*
*      The first bit of each byte is the low-order bit.
*
*      The routines in this file allow a variable-length bit value to
*      be output right-to-left (useful for literal values). For
*      left-to-right output (useful for code strings from the tree routines),
*      the bits must have been reversed first with bi_reverse().
*
*      For in-memory compression, the compressed bit stream goes directly
*      into the requested output buffer. The input data is read in blocks
*      by the mem_read() function. The buffer is limited to 64K on 16 bit
*      machines.
*
*  INTERFACE
*
*      void bi_init (FILE *zipfile)
*          Initialize the bit string routines.
*
*      void send_bits (int value, int length)
*          Write out a bit string, taking the source bits right to
*          left.
*
*      int bi_reverse (int value, int length)
*          Reverse the bits of a bit string, taking the source bits left to
*          right and emitting them right to left.
*
*      void bi_windup (void)
*          Write out any remaining bits in an incomplete byte.
*
*      void copy_block(char *buf, unsigned len, int header)
*          Copy a stored block to the zip file, storing first the length and
*          its one's complement if requested.
*
*/

/*tailor.h -- target dependent definitions
* Copyright (C) 1992-1993 Jean-loup Gailly.
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

/*The target dependent definitions should be defined here only.
* The target dependent functions should be defined in tailor.c.
*/

/*$Id: tailor.h,v 0.18 1993/06/14 19:32:20 jloup Exp $*/

/*MS C under OS/2*/

/*Force file names to lower case*/

/*Prime/PRIMOS*/

/*Force file names to lower case*/

/*temporary, subject to change*/

/*We don't want a signal handler for SIGTERM*/

/*Pyramid*/

/*problem with overlapping copies*/

/*don't rely on inode numbers*/

/*Common defaults*/

/*assume Unix*/

/*keep at least MIN_PART chars between dots in a file name.*/

/*gzip.h -- common declarations for all gzip modules
* Copyright (C) 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
* Copyright (C) 1992-1993 Jean-loup Gailly.
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

typedef void *voidp;
typedef unsigned char uch;
typedef unsigned short ush;
typedef unsigned long ulg;
/*Return codes from gzip*/

/*Compression methods (see algorithm.doc)*/

/*methods 4 to 7 reserved*/

extern int method;
/*compression method*/

/*To save memory for 16 bit systems, some arrays are overlaid between
* the various modules:
* deflate:  prev+head   window      d_buf  l_buf  outbuf
* unlzw:    tab_prefix  tab_suffix  stack  inbuf  outbuf
* inflate:              window             inbuf
* unpack:               window             inbuf  prefix_len
* unlzh:    left+right  window      c_table inbuf c_len
* For compression, input is done in window[]. For decompression, output
* is done in window except for unlzw.
*/

/*input buffer size*/

/*input buffer size*/

/*required by unlzw()*/

/*output buffer size*/

/*output buffer size*/

/*required by unlzw()*/

/*buffer for distances, see trees.c*/

/*buffer for distances, see trees.c*/

//extern uch outbuf[];

extern uch inbuf[];
/*input buffer*/

extern uch outbuf[];
/*output buffer*/

extern ush d_buf[];
/*buffer for distances, see trees.c*/

extern uch window[];
/*Sliding window and suffix table (unlzw)*/

/*hash link (see deflate.c)*/

/*hash head (see deflate.c)*/

extern ush prev[];
/*prefix code (see unlzw.c)*/

/*prefix for even codes*/

/*prefix for odd  codes*/

extern unsigned int insize;
/*valid bytes in inbuf*/

extern unsigned int inptr;
/*index of next byte to be processed in inbuf*/

extern unsigned int outcnt;
/*bytes in output buffer*/

extern int rsync;
/*deflate into rsyncable chunks*/

extern off_t bytes_in;
/*number of input bytes*/

extern off_t bytes_out;
/*number of output bytes*/

extern off_t header_bytes;
/*number of bytes in gzip header*/

extern int ifd;
/*input file descriptor*/

extern int ofd;
/*output file descriptor*/

extern char ifname[];
/*input file name or "stdin"*/

extern char ofname[];
/*output file name or "stdout"*/

extern char *progname;
/*program name*/

extern time_t time_stamp;
/*original time stamp (modification time)*/

extern off_t ifile_size;
/*input file size, -1 for devices (debug only)*/

typedef int file_t;
/*Do not use stdio*/

/*in memory compression*/

/*gzip flag byte*/

/*bit 0 set: file probably ascii text*/

/*bit 1 set: continuation of multi-part gzip file*/

/*bit 2 set: extra field present*/

/*bit 3 set: original file name present*/

/*bit 4 set: file comment present*/

/*bit 5 set: file is encrypted*/

/*bit 6,7:   reserved*/

/*internal file attribute*/

/*window size--must be a power of two, and*/

/*at least 32K for zip's deflate method*/

/*The minimum and maximum match lengths*/

/*Minimum amount of lookahead, except at the end of the input file.
* See deflate.c for comments about the MIN_MATCH+1.
*/

/*In order to simplify the code, particularly on 16 bit machines, match
* distances are limited to MAX_DIST instead of WSIZE.
*/

extern int decrypt;
/*flag to turn on decryption*/

extern int exit_code;
/*program exit code*/

extern int verbose;
/*be verbose (-v)*/

extern int quiet;
/*be quiet (-q)*/

extern int level;
/*compression level*/

extern int test;
/*check .z file integrity*/

extern int to_stdout;
/*output to stdout (-c)*/

extern int save_orig_name;
/*set if original name must be saved*/
/*put_byte is used for the compressed output, put_ubyte for the
* uncompressed output. However unlzw() uses window for its
* suffix table instead of its output buffer, so it does not use put_ubyte
* (to be cleaned up).
*/
/*Output a 16 bit value, lsb first*/
/*Output a 32 bit value to the bit stream, lsb first*/
/*force sequential output*/
/*no option -a yet*/
/*force to lower case*/
/*Macros for getting two-byte and four-byte header values*/
/*Diagnostic functions*/
/*in zip.c:*/
int clava_dcg_global[ 342 ] = {0};
extern int zip(int in, int out);
extern int file_read(char *buf, unsigned int size);
/*in unzip.c*/
extern int unzip(int in, int out);
extern int check_zipfile(int in);
/*in unpack.c*/
extern int unpack(int in, int out);
/*in unlzh.c*/
extern int unlzh(int in, int out);
/*in gzip.c*/
void abort_gzip_signal();
/*in deflate.c*/
void lm_init(int pack_level, ush *flags);
off_t deflate();
/*in trees.c*/
void ct_init(ush *attr, int *method);
int ct_tally(int dist, int lc);
off_t flush_block(char *buf, ulg stored_len, int pad, int eof);
/*in bits.c*/
void bi_init(file_t zipfile);
void send_bits(int value, int length);
unsigned int bi_reverse(unsigned int value, int length);
void bi_windup();
void copy_block(char *buf, unsigned int len, int header);
extern int (*read_buf) (char *, unsigned int);
/*in util.c:*/
extern int copy(int in, int out);
extern ulg updcrc(uch *s, unsigned int n);
extern void clear_bufs();
extern int fill_inbuf(int eof_ok);
extern void flush_outbuf();
extern void flush_window();
extern void write_buf(int fd, voidp buf, unsigned int cnt);
extern char * strlwr(char *s);
extern char * base_name(char *fname);
extern int xunlink(char *fname);
extern void make_simple_name(char *name);
extern char * add_envopt(int *argcp, char ***argvp, char *env);
extern void error(char *m);
extern void warning(char *m);
extern void read_error();
extern void write_error();
extern void display_ratio(off_t num, off_t den, FILE *file);
extern void fprint_off(FILE *, off_t, int);
extern voidp xmalloc(unsigned int size);
/*in inflate.c*/
extern int inflate();
/*in yesno.c*/
extern int yesno();
/*crypt.h (dummy version) -- do not perform encryption
* Hardly worth copyrighting :-)
*/

/*dummy version*/

/*length of encryption random header*/

/*===========================================================================
* Local data used by the "bit string" routines.
*/

static file_t zfile;
/*output gzip file*/

static unsigned short bi_buf;
/*Output buffer. bits are inserted starting at the bottom (least significant
* bits).
*/

/*Number of bits used within bi_buf. (bi_buf might be implemented on
* more than 16 bits on some systems.)
*/

static int bi_valid;
/*Number of valid bits in bi_buf.  All bits above the last valid bit
* are always zero.
*/

int (*read_buf) (char *, unsigned int);
/*Current input function. Set to mem_read for in-memory compression*/
/*bit length of the compressed data*/
/*===========================================================================
* Initialize the bit string routines.
*/
void bi_init(file_t zipfile) {
   /*output zip file, NO_FILE for in-memory compression*/
   zfile = zipfile;
   bi_buf = 0;
   bi_valid = 0;
   /*Set the defaults for file compression. They are set by memcompress
   * for in-memory compression.
   */
   if(zfile != (-1)) {
      read_buf = file_read;
   }
}

/*===========================================================================
* Send a value on a given number of bits.
* IN assertion: length <= 16 and value fits in length bits.
*/
void send_bits(int value, int length) {
   /*value to send*/
   /*number of bits*/
   /*If not enough room in bi_buf, use (valid) bits from bi_buf and
   * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
   * unused bits in value.
   */
   if(bi_valid > (int) (8 * 2 * sizeof(char)) - length) {
      bi_buf |= (value << bi_valid);
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) ((bi_buf) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) (bi_buf) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) ((bi_buf) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 0 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) (bi_buf) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 0 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
      bi_buf = (ush) value >> ((8 * 2 * sizeof(char)) - bi_valid);
      bi_valid += length - (8 * 2 * sizeof(char));
   }
   else {
      bi_buf |= value << bi_valid;
      bi_valid += length;
   }
}

/*===========================================================================
* Reverse the first len bits of a code, using straightforward code (a faster
* method would use a table)
* IN assertion: 1 <= len <= 15
*/
unsigned int bi_reverse(unsigned int code, int len) {
   /*the value to invert*/
   /*its bit length*/
   register unsigned int res = 0;
   do  {
      res |= code & 1;
      code >>= 1 , res <<= 1;
   }
   while (--len > 0);
   
   return res >> 1;
}

/*===========================================================================
* Write out any remaining bits in an incomplete byte.
*/
void bi_windup() {
   if(bi_valid > 8) {
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) ((bi_buf) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) (bi_buf) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) ((bi_buf) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 1 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) (bi_buf) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 1 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
   }
   else if(bi_valid > 0) {
      {
         outbuf[outcnt++] = (uch) (bi_buf);
         if(outcnt == 16384) {
            clava_dcg_global[ 1 ]++;
            flush_outbuf();
         }
      }
      ;
   }
   bi_buf = 0;
   bi_valid = 0;
}

/*===========================================================================
* Copy a stored block to the zip file, storing first the length and its
* one's complement if requested.
*/
void copy_block(char *buf, unsigned int len, int header) {
   /*the input data*/
   /*its length*/
   /*true if block header must be written*/
   clava_dcg_global[ 2 ]++;
   bi_windup();
   /*align on byte boundary*/
   if(header) {
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) (((ush) len) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) ((ush) len) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) (((ush) len) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 3 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) ((ush) len) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 3 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) (((ush) ~len) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) ((ush) ~len) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) (((ush) ~len) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 3 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) ((ush) ~len) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 3 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
   }
   while(len--) {
      {
         outbuf[outcnt++] = (uch) (*buf++);
         if(outcnt == 16384) {
            clava_dcg_global[ 3 ]++;
            flush_outbuf();
         }
      }
      ;
   }
}

/*crypt.c (dummy version) -- do not perform encryption
* Hardly worth copyrighting :-)
*/

/*deflate.c -- compress data using the deflation algorithm
* Copyright (C) 1992-1993 Jean-loup Gailly
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

/*
*  PURPOSE
*
*      Identify new text as repetitions of old text within a fixed-
*      length sliding window trailing behind the new text.
*
*  DISCUSSION
*
*      The "deflation" process depends on being able to identify portions
*      of the input text which are identical to earlier input (within a
*      sliding window trailing behind the input currently being processed).
*
*      The most straightforward technique turns out to be the fastest for
*      most input files: try all possible matches and select the longest.
*      The key feature of this algorithm is that insertions into the string
*      dictionary are very simple and thus fast, and deletions are avoided
*      completely. Insertions are performed at each input character, whereas
*      string matches are performed only when the previous match ends. So it
*      is preferable to spend more time in matches to allow very fast string
*      insertions and avoid deletions. The matching algorithm for small
*      strings is inspired from that of Rabin & Karp. A brute force approach
*      is used to find longer strings when a small match has been found.
*      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
*      (by Leonid Broukhis).
*         A previous version of this file used a more sophisticated algorithm
*      (by Fiala and Greene) which is guaranteed to run in linear amortized
*      time, but has a larger average cost, uses more memory and is patented.
*      However the F&G algorithm may be faster for some highly redundant
*      files if the parameter max_chain_length (described below) is too large.
*
*  ACKNOWLEDGEMENTS
*
*      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
*      I found it in 'freeze' written by Leonid Broukhis.
*      Thanks to many info-zippers for bug reports and testing.
*
*  REFERENCES
*
*      APPNOTE.TXT documentation file in PKZIP 1.93a distribution.
*
*      A description of the Rabin and Karp algorithm is given in the book
*         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
*
*      Fiala,E.R., and Greene,D.H.
*         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
*
*  INTERFACE
*
*      void lm_init (int pack_level, ush *flags)
*          Initialize the "longest match" routines for a new file
*
*      off_t deflate (void)
*          Processes a new input file and return its compressed length. Sets
*          the compressed length, crc, deflate flags and internal file
*          attributes.
*/

/*lzw.h -- define the lzw functions.
* Copyright (C) 1992-1993 Jean-loup Gailly.
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

/*Initial number of bits per code*/

/*Mask for 'number of compression bits'*/

/*Mask 0x20 is reserved to mean a fourth header byte, and 0x40 is free.
* It's a pity that old uncompress does not check bit 0x20. That makes
* extension of the format actually undesirable because old compress
* would just crash on the new format instead of giving a meaningful
* error message. It does check the number of bits, but it's more
* helpful to say "unsupported format, get a new version" than
* "can only handle 16 bits".
*/

/*Block compression: if table is full and compression rate is dropping,
* clear the dictionary.
*/

/*reserved bits*/

/*flush the dictionary*/

/*first free entry*/

extern int maxbits;
/*max bits per code for LZW*/

extern int block_mode;
/*block compress mode -C compatible with 2.0*/
extern int lzw(int in, int out);
extern int unlzw(int in, int out);
/*===========================================================================
* Configuration parameters
*/

/*Compile with MEDIUM_MEM to reduce the memory requirements or
* with SMALL_MEM to use as little memory as possible. Use BIG_MEM if the
* entire input file can be held in memory (not possible on 16 bit systems).
* Warning: defining these symbols affects HASH_BITS (see below) and thus
* affects the compression ratio. The compressed output
* is still correct, and might even be smaller in some cases.
*/

/*Number of bits used to hash strings*/

/*For portability to 16 bit machines, do not use values above 15.*/

/*To save space (see unlzw.c), we overlay prev+head with tab_prefix and
* window with tab_suffix. Check that we can do this:
*/

/*HASH_SIZE and WSIZE must be powers of two*/

/*Tail of hash chains*/

/*speed options for the general purpose bit flag*/

/*Matches of length 3 are discarded if their distance exceeds TOO_FAR*/

/*Size of rsync window, must be < MAX_DIST*/

/*Whether window sum matches magic value*/

/*===========================================================================
* Local data used by the "longest match" routines.
*/

typedef ush Pos;
typedef unsigned int IPos;
/*A Pos is an index in the character window. We use short instead of int to
* save space in the various tables. IPos is used only for parameter passing.
*/

/*DECLARE(uch, window, 2L*WSIZE);*/

/*Sliding window. Input bytes are read into the second half of the window,
* and move to the first half later to keep a dictionary of at least WSIZE
* bytes. With this organization, matches are limited to a distance of
* WSIZE-MAX_MATCH bytes, but this ensures that IO is always
* performed with a length multiple of the block size. Also, it limits
* the window size to 64K, which is quite useful on MSDOS.
* To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would
* be less efficient).
*/

/*DECLARE(Pos, prev, WSIZE);*/

/*Link to older string with same hash index. To limit the size of this
* array to 64K, this link is maintained only for the last 32K strings.
* An index in this array is thus a window index modulo 32K.
*/

/*DECLARE(Pos, head, 1<<HASH_BITS);*/

/*Heads of the hash chains or NIL.*/

ulg window_size = (ulg) 2 * 0x8000;
/*window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the
* input file length plus MIN_LOOKAHEAD.
*/

long block_start;
/*window position at the beginning of the current output block. Gets
* negative when the window is moved backwards.
*/

static unsigned int ins_h;
/*hash index of string to be inserted*/

/*Number of bits by which ins_h and del_h must be shifted at each
* input step. It must be such that after MIN_MATCH steps, the oldest
* byte no longer takes part in the hash key, that is:
*   H_SHIFT * MIN_MATCH >= HASH_BITS
*/

unsigned int prev_length;
/*Length of the best match at previous step. Matches not greater than this
* are discarded. This is used in the lazy match evaluation.
*/

unsigned int strstart;
/*start of string to insert*/

unsigned int match_start;
/*start of matching string*/

static int eofile;
/*flag set at end of input file*/

static unsigned int lookahead;
/*number of valid bytes ahead in window*/

unsigned int max_chain_length;
/*To speed up deflation, hash chains are never searched beyond this length.
* A higher limit improves compression ratio but degrades the speed.
*/

static unsigned int max_lazy_match;
/*Attempt to find a better match only when the current match is strictly
* smaller than this value. This mechanism is used only for compression
* levels >= 4.
*/

/*Insert new strings in the hash table only if the match length
* is not greater than this length. This saves time but degrades compression.
* max_insert_length is used only for compression levels <= 3.
*/

static int compr_level;
/*compression level (1..9)*/

unsigned int good_match;
/*Use a faster search when the previous match is longer than this*/

static ulg rsync_sum;
/*rolling sum of rsync window*/

static ulg rsync_chunk_end;
/*next rsync sequence point*/
/*Values for max_lazy_match, good_match and max_chain_length, depending on
* the desired pack level (0..9). The values given below have been tuned to
* exclude worst case performance for pathological files. Better values may be
* found for specific files.
*/

struct config {
   ush good_length;
   /*reduce lazy search above this match length*/
   ush max_lazy;
   /*do not perform lazy search above this match length*/
   ush nice_length;
   /*quit search above this match length*/
   ush max_chain;
};

typedef struct config config;
int nice_match;
/*Stop searching when current match exceeds this*/

static config configuration_table[10] = {{0, 0, 0, 0}, {4, 4, 8, 4}, {4, 5, 16, 8}, {4, 6, 32, 32}, {4, 4, 16, 16}, {8, 16, 32, 32}, {8, 16, 128, 128}, {8, 32, 128, 256}, {32, 128, 258, 1024}, {32, 258, 258, 4096}};
/*good lazy nice chain*/
/*0*/
/*1*/
/*2*/
/*3*/
/*4*/
/*5*/
/*6*/
/*7*/
/*8*/
/*9*/
/*Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
* For deflate_fast() (levels <= 3) good is ignored and lazy has a different
* meaning.
*/
/*result of memcmp for equal strings*/
/*===========================================================================
*  Prototypes for local functions.
*/
static void fill_window();
static off_t deflate_fast();
int longest_match(IPos cur_match);
/*asm code initialization*/
/*===========================================================================
* Update a hash value with the given input byte
* IN  assertion: all calls to to UPDATE_HASH are made with consecutive
*    input characters, so that a running hash key can be computed from the
*    previous key instead of complete recalculation each time.
*/
/*===========================================================================
* Insert string s in the dictionary and set match_head to the previous head
* of the hash chain (the most recent string with same hash key). Return
* the previous length of the hash chain.
* IN  assertion: all calls to to INSERT_STRING are made with consecutive
*    input characters and the first MIN_MATCH bytes of s are valid
*    (except for the last MIN_MATCH-1 bytes of the input file).
*/
/*===========================================================================
* Initialize the "longest match" routines for a new file
*/
void lm_init(int pack_level, ush *flags) {
   /*0: store, 1: best speed, 9: best compression*/
   /*general purpose bit flag*/
   register unsigned int j;
   if(pack_level < 1 || pack_level > 9) {
      clava_dcg_global[ 4 ]++;
      error("bad pack level");
   }
   compr_level = pack_level;
   /*Initialize the hash table.*/
   clava_dcg_global[ 5 ]++;
   memset((voidp) ((char *) (prev + 0x8000)), 0, ((unsigned int) (1 << 15) * sizeof((*(prev + 0x8000)))));
   /*prev will be initialized on the fly*/
   /*rsync params*/
   rsync_chunk_end = 0xFFFFFFFFUL;
   rsync_sum = 0;
   /*Set the default configuration parameters:
   */
   max_lazy_match = configuration_table[pack_level].max_lazy;
   good_match = configuration_table[pack_level].good_length;
   nice_match = configuration_table[pack_level].nice_length;
   max_chain_length = configuration_table[pack_level].max_chain;
   if(pack_level == 1) {
      *flags |= 4;
   }
   else if(pack_level == 9) {
      *flags |= 2;
   }
   /*??? reduce max_chain_length for binary files*/
   strstart = 0;
   block_start = 0L;
   /*initialize the asm code*/
   clava_dcg_global[ 6 ]++;
   lookahead = read_buf((char *) window, sizeof(int) <= 2 ? (unsigned int) 0x8000 : 2 * 0x8000);
   if(lookahead == 0 || lookahead == (unsigned int) (-1)) {
      eofile = 1 , lookahead = 0;
      
      return;
   }
   eofile = 0;
   /*Make sure that we always have enough lookahead. This is important
   * if input comes from a device such as a tty.
   */
   while(lookahead < (258 + 3 + 1) && !eofile) {
      clava_dcg_global[ 7 ]++;
      fill_window();
   }
   ins_h = 0;
   for(j = 0; j < 3 - 1; j++) (ins_h = (((ins_h) << ((15 + 3 - 1) / 3)) ^ (window[j])) & ((unsigned int) (1 << 15) - 1));
   /*If lookahead < MIN_MATCH, ins_h is garbage, but this is
   * not important since only literal bytes will be emitted.
   */
}

/*===========================================================================
* Set match_start to the longest match starting at the given string and
* return its length. Matches shorter or equal to prev_length are discarded,
* in which case the result is equal to prev_length and match_start is
* garbage.
* IN assertions: cur_match is the head of the hash chain for the current
*   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
*/
/*For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or
* match.s. The code is functionally equivalent, so you can use the C version
* if desired.
*/
int longest_match(IPos cur_match) {
   /*current match*/
   unsigned int chain_length = max_chain_length;
   /*max hash chain length*/
   register uch *scan = window + strstart;
   /*current string*/
   register uch *match;
   /*matched string*/
   register int len;
   /*length of current match*/
   int best_len = prev_length;
   /*best match length so far*/
   IPos limit = strstart > (IPos) (0x8000 - (258 + 3 + 1)) ? strstart - (IPos) (0x8000 - (258 + 3 + 1)) : 0;
   /*Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */
   /*The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
   /*Compare two bytes at a time. Note: this is not always beneficial.
   * Try with and without -DUNALIGNED_OK to check.
   */
   register uch *strend = window + strstart + 258;
   register uch scan_end1 = scan[best_len - 1];
   register uch scan_end = scan[best_len];
   /*Do not waste too much time if we already have a good match:*/
   if(prev_length >= good_match) {
      chain_length >>= 2;
   }
   ;
   do  {
      ;
      match = window + cur_match;
      /*Skip to next match if the match length cannot increase
      * or if the match length is less than 2:
      */
      /*This code assumes sizeof(unsigned short) == 2. Do not use
      * UNALIGNED_OK if your compiler uses a different size.
      */
      /*It is not necessary to compare scan[2] and match[2] since they are
      * always equal when the other bytes match, given that the hash keys
      * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
      * strstart+3, +5, ... up to strstart+257. We check for insufficient
      * lookahead only every 4th comparison; the 128th check will be made
      * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
      * necessary to put more guard bytes at the end of the window, or
      * to check more often for insufficient lookahead.
      */
      /*The funny "do {}" generates better code on most compilers*/
      /*Here, scan <= window+strstart+257*/
      /*UNALIGNED_OK*/
      if(match[best_len] != scan_end || match[best_len - 1] != scan_end1 || *match != *scan || *++match != scan[1]) continue;
      /*The check at best_len-1 can be removed because it will be made
      * again later. (This heuristic is not always a win.)
      * It is not necessary to compare scan[2] and match[2] since they
      * are always equal when the other bytes match, given that
      * the hash keys are equal and that HASH_BITS >= 8.
      */
      scan += 2 , match++;
      /*We check for insufficient lookahead only every 8th comparison;
      * the 256th check will be made at strstart+258.
      */
      do  {
      }
      while (*++scan == *++match && *++scan == *++match && *++scan == *++match && *++scan == *++match && *++scan == *++match && *++scan == *++match && *++scan == *++match && *++scan == *++match && scan < strend);
      len = 258 - (int) (strend - scan);
      scan = strend - 258;
      /*UNALIGNED_OK*/
      if(len > best_len) {
         match_start = cur_match;
         best_len = len;
         if(len >= nice_match) break;
         scan_end1 = scan[best_len - 1];
         scan_end = scan[best_len];
      }
   }
   while ((cur_match = prev[cur_match & (0x8000 - 1)]) > limit && --chain_length != 0);
   
   return best_len;
}

/*ASMV*/
/*===========================================================================
* Check that the match at match_start is indeed a match.
*/
/*check that the match is indeed a match*/
/*===========================================================================
* Fill the window when the lookahead becomes insufficient.
* Updates strstart and lookahead, and sets eofile if end of input file.
* IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
* OUT assertions: at least one byte has been read, or eofile is set;
*    file reads are performed for at least two bytes (required for the
*    translate_eol option).
*/
static void fill_window() {
   register unsigned int n, m;
   unsigned int more = (unsigned int) (window_size - (ulg) lookahead - (ulg) strstart);
   /*Amount of free space at the end of the window.*/
   /*If the window is almost full and there is insufficient lookahead,
   * move the upper half to the lower one to make room in the upper half.
   */
   if(more == (unsigned int) (-1)) {
      /*Very unlikely, but possible on 16 bit machine if strstart == 0
      * and lookahead == 1 (input done one byte at time)
      */
      more--;
   }
   else if(strstart >= 0x8000 + (0x8000 - (258 + 3 + 1))) {
      /*By the IN assertion, the window is not empty so we can't confuse
      * more == 0 with more == 64K on a 16 bit machine.
      */
      ;
      clava_dcg_global[ 8 ]++;
      memcpy((char *) window, (char *) window + 0x8000, (unsigned int) 0x8000);
      match_start -= 0x8000;
      strstart -= 0x8000;
      /*we now have strstart >= MAX_DIST:*/
      if(rsync_chunk_end != 0xFFFFFFFFUL) rsync_chunk_end -= 0x8000;
      block_start -= (long) 0x8000;
      for(n = 0; n < (unsigned int) (1 << 15); n++) {
         m = (prev + 0x8000)[n];
         (prev + 0x8000)[n] = (Pos) (m >= 0x8000 ? m - 0x8000 : 0);
      }
      for(n = 0; n < 0x8000; n++) {
         m = prev[n];
         prev[n] = (Pos) (m >= 0x8000 ? m - 0x8000 : 0);
         /*If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      }
      more += 0x8000;
   }
   /*At this point, more >= 2*/
   if(!eofile) {
      clava_dcg_global[ 9 ]++;
      n = read_buf((char *) window + strstart + lookahead, more);
      if(n == 0 || n == (unsigned int) (-1)) {
         eofile = 1;
      }
      else {
         lookahead += n;
      }
   }
}

static void rsync_roll(unsigned int start, unsigned int num) {
   unsigned int i;
   if(start < 4096) {
      /*before window fills.*/
      for(i = start; i < 4096; i++) {
         if(i == start + num) 
         return;
         rsync_sum += (ulg) window[i];
      }
      num -= (4096 - start);
      start = 4096;
   }
   /*buffer after window full*/
   for(i = start; i < start + num; i++) {
      /*New character in*/
      rsync_sum += (ulg) window[i];
      /*Old character out*/
      rsync_sum -= (ulg) window[i - 4096];
      if(rsync_chunk_end == 0xFFFFFFFFUL && ((rsync_sum) % 4096 == 0)) rsync_chunk_end = i;
   }
}

/*===========================================================================
* Set rsync_chunk_end if window sum matches magic value.
*/
/*===========================================================================
* Flush the current block, with given end-of-file flag.
* IN assertion: strstart is set to the end of the current match.
*/
/*===========================================================================
* Processes a new input file and return its compressed length. This
* function does not perform lazy evaluationof matches and inserts
* new strings in the dictionary only for unmatched strings or for short
* matches. It is used only for the fast compression options.
*/
static off_t deflate_fast() {
   IPos hash_head;
   /*head of the hash chain*/
   int flush;
   /*set if current block must be flushed, 2=>and padded*/
   unsigned int match_length = 0;
   /*length of best match*/
   prev_length = 3 - 1;
   while(lookahead != 0) {
      /*Insert the string window[strstart .. strstart+2] in the
      * dictionary, and set hash_head to the head of the hash chain:
      */
      ((ins_h = (((ins_h) << ((15 + 3 - 1) / 3)) ^ (window[(strstart) + 3 - 1])) & ((unsigned int) (1 << 15) - 1)) , prev[(strstart) & (0x8000 - 1)] = hash_head = (prev + 0x8000)[ins_h] , (prev + 0x8000)[ins_h] = (strstart));
      /*Find the longest match, discarding those <= prev_length.
      * At this point we have always match_length < MIN_MATCH
      */
      if(hash_head != 0 && strstart - hash_head <= (0x8000 - (258 + 3 + 1)) && strstart <= window_size - (258 + 3 + 1)) {
         /*To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
         clava_dcg_global[ 10 ]++;
         match_length = longest_match(hash_head);
         /*longest_match() sets match_start*/
         if(match_length > lookahead) match_length = lookahead;
      }
      if(match_length >= 3) {
         ;
         clava_dcg_global[ 11 ]++;
         flush = ct_tally(strstart - match_start, match_length - 3);
         lookahead -= match_length;
         do  {
            if(rsync) {
               clava_dcg_global[ 12 ]++;
               rsync_roll((strstart), (match_length));
            }
         }
         while (0);
         /*Insert new strings in the hash table only if the match length
         * is not too large. This saves time but degrades compression.
         */
         if(match_length <= max_lazy_match) {
            match_length--;
            /*string at strstart already in hash table*/
            do  {
               strstart++;
               ((ins_h = (((ins_h) << ((15 + 3 - 1) / 3)) ^ (window[(strstart) + 3 - 1])) & ((unsigned int) (1 << 15) - 1)) , prev[(strstart) & (0x8000 - 1)] = hash_head = (prev + 0x8000)[ins_h] , (prev + 0x8000)[ins_h] = (strstart));
               /*strstart never exceeds WSIZE-MAX_MATCH, so there are
               * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
               * these bytes are garbage, but it does not matter since
               * the next lookahead bytes will be emitted as literals.
               */
            }
            while (--match_length != 0);
            strstart++;
         }
         else {
            strstart += match_length;
            match_length = 0;
            ins_h = window[strstart];
            (ins_h = (((ins_h) << ((15 + 3 - 1) / 3)) ^ (window[strstart + 1])) & ((unsigned int) (1 << 15) - 1));
         }
      }
      else {
         /*No match, output a literal byte*/
         ;
         clava_dcg_global[ 11 ]++;
         flush = ct_tally(0, window[strstart]);
         do  {
            if(rsync) {
               clava_dcg_global[ 12 ]++;
               rsync_roll((strstart), (1));
            }
         }
         while (0);
         lookahead--;
         strstart++;
      }
      if(rsync && strstart > rsync_chunk_end) {
         rsync_chunk_end = 0xFFFFFFFFUL;
         flush = 2;
      }
      if(flush) {
         clava_dcg_global[ 13 ]++;
         flush_block(block_start >= 0L ? (char *) &window[(unsigned int) block_start] : (char *) ((void *) 0), (long) strstart - block_start, flush - 1, (0)) , block_start = strstart;
      }
      /*Make sure that we always have enough lookahead, except
      * at the end of the input file. We need MAX_MATCH bytes
      * for the next match, plus MIN_MATCH bytes to insert the
      * string following the next match.
      */
      while(lookahead < (258 + 3 + 1) && !eofile) {
         clava_dcg_global[ 14 ]++;
         fill_window();
      }
   }
   clava_dcg_global[ 13 ]++;
   
   return flush_block(block_start >= 0L ? (char *) &window[(unsigned int) block_start] : (char *) ((void *) 0), (long) strstart - block_start, flush - 1, (1));
   /*eof*/
}

/*===========================================================================
* Same as above, but achieves better compression. We use a lazy
* evaluation for matches: a match is finally adopted only if there is
* no better match at the next window position.
*/
off_t deflate() {
   IPos hash_head;
   /*head of hash chain*/
   IPos prev_match;
   /*previous match*/
   int flush;
   /*set if current block must be flushed*/
   int match_available = 0;
   /*set if previous match exists*/
   register unsigned int match_length = 3 - 1;
   /*length of best match*/
   if(compr_level <= 3) {
      clava_dcg_global[ 15 ]++;
      
      return deflate_fast();
   }
   /*optimized for speed*/
   /*Process the input block.*/
   while(lookahead != 0) {
      /*Insert the string window[strstart .. strstart+2] in the
      * dictionary, and set hash_head to the head of the hash chain:
      */
      ((ins_h = (((ins_h) << ((15 + 3 - 1) / 3)) ^ (window[(strstart) + 3 - 1])) & ((unsigned int) (1 << 15) - 1)) , prev[(strstart) & (0x8000 - 1)] = hash_head = (prev + 0x8000)[ins_h] , (prev + 0x8000)[ins_h] = (strstart));
      /*Find the longest match, discarding those <= prev_length.
      */
      prev_length = match_length , prev_match = match_start;
      match_length = 3 - 1;
      if(hash_head != 0 && prev_length < max_lazy_match && strstart - hash_head <= (0x8000 - (258 + 3 + 1)) && strstart <= window_size - (258 + 3 + 1)) {
         /*To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
         clava_dcg_global[ 16 ]++;
         match_length = longest_match(hash_head);
         /*longest_match() sets match_start*/
         if(match_length > lookahead) match_length = lookahead;
         /*Ignore a length 3 match if it is too distant:*/
         if(match_length == 3 && strstart - match_start > 4096) {
            /*If prev_match is also MIN_MATCH, match_start is garbage
            * but we will ignore the current match anyway.
            */
            match_length--;
         }
      }
      /*If there was a match at the previous step and the current
      * match is not better, output the previous match:
      */
      if(prev_length >= 3 && match_length <= prev_length) {
         ;
         clava_dcg_global[ 17 ]++;
         flush = ct_tally(strstart - 1 - prev_match, prev_length - 3);
         /*Insert in hash table all strings up to the end of the match.
         * strstart-1 and strstart are already inserted.
         */
         lookahead -= prev_length - 1;
         prev_length -= 2;
         do  {
            if(rsync) {
               clava_dcg_global[ 18 ]++;
               rsync_roll((strstart), (prev_length + 1));
            }
         }
         while (0);
         do  {
            strstart++;
            ((ins_h = (((ins_h) << ((15 + 3 - 1) / 3)) ^ (window[(strstart) + 3 - 1])) & ((unsigned int) (1 << 15) - 1)) , prev[(strstart) & (0x8000 - 1)] = hash_head = (prev + 0x8000)[ins_h] , (prev + 0x8000)[ins_h] = (strstart));
            /*strstart never exceeds WSIZE-MAX_MATCH, so there are
            * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
            * these bytes are garbage, but it does not matter since the
            * next lookahead bytes will always be emitted as literals.
            */
         }
         while (--prev_length != 0);
         match_available = 0;
         match_length = 3 - 1;
         strstart++;
         if(rsync && strstart > rsync_chunk_end) {
            rsync_chunk_end = 0xFFFFFFFFUL;
            flush = 2;
         }
         if(flush) {
            clava_dcg_global[ 19 ]++;
            flush_block(block_start >= 0L ? (char *) &window[(unsigned int) block_start] : (char *) ((void *) 0), (long) strstart - block_start, flush - 1, (0)) , block_start = strstart;
         }
      }
      else if(match_available) {
         /*If there was no match at the previous position, output a
         * single literal. If there was a match but the current match
         * is longer, truncate the previous match to a single literal.
         */
         ;
         clava_dcg_global[ 17 ]++;
         flush = ct_tally(0, window[strstart - 1]);
         if(rsync && strstart > rsync_chunk_end) {
            rsync_chunk_end = 0xFFFFFFFFUL;
            flush = 2;
         }
         if(flush) {
            clava_dcg_global[ 19 ]++;
            flush_block(block_start >= 0L ? (char *) &window[(unsigned int) block_start] : (char *) ((void *) 0), (long) strstart - block_start, flush - 1, (0)) , block_start = strstart;
         }
         do  {
            if(rsync) {
               clava_dcg_global[ 18 ]++;
               rsync_roll((strstart), (1));
            }
         }
         while (0);
         strstart++;
         lookahead--;
      }
      else {
         /*There is no previous match to compare with, wait for
         * the next step to decide.
         */
         if(rsync && strstart > rsync_chunk_end) {
            /*Reset huffman tree*/
            rsync_chunk_end = 0xFFFFFFFFUL;
            flush = 2;
            clava_dcg_global[ 19 ]++;
            flush_block(block_start >= 0L ? (char *) &window[(unsigned int) block_start] : (char *) ((void *) 0), (long) strstart - block_start, flush - 1, (0)) , block_start = strstart;
         }
         match_available = 1;
         do  {
            if(rsync) {
               clava_dcg_global[ 18 ]++;
               rsync_roll((strstart), (1));
            }
         }
         while (0);
         strstart++;
         lookahead--;
      }
      ;
      /*Make sure that we always have enough lookahead, except
      * at the end of the input file. We need MAX_MATCH bytes
      * for the next match, plus MIN_MATCH bytes to insert the
      * string following the next match.
      */
      while(lookahead < (258 + 3 + 1) && !eofile) {
         clava_dcg_global[ 20 ]++;
         fill_window();
      }
   }
   if(match_available) {
      clava_dcg_global[ 17 ]++;
      ct_tally(0, window[strstart - 1]);
   }
   clava_dcg_global[ 19 ]++;
   
   return flush_block(block_start >= 0L ? (char *) &window[(unsigned int) block_start] : (char *) ((void *) 0), (long) strstart - block_start, flush - 1, (1));
   /*eof*/
}

/*Getopt for GNU.
NOTE: getopt is now part of the C library, so if you don't know what
"Keep this file name-space clean" means, talk to drepper@gnu.org
before changing it!
Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001
Free Software Foundation, Inc.
This file is part of the GNU C Library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/

/*This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
Ditto for AIX 3.2 and <stdlib.h>.*/

/*This is a separate conditional since some stdc systems
reject `defined (const)'.*/

/*This needs to come after some library #include
to get __GNU_LIBRARY__ defined.*/

/*This version of `getopt' appears to the caller like standard Unix `getopt'
but it behaves differently for the user, since it allows the user
to intersperse the options with the other arguments.

As `getopt' works, it permutes the elements of ARGV so that,
when it is done, all the options precede everything else.  Thus
all application programs are extended to handle flexible argument order.

Setting the environment variable POSIXLY_CORRECT disables permutation.
Then the behavior is completely standard.

GNU application programs can use a third alternative mode in which
they can distinguish the relative order of options and other arguments.*/

/*Declarations for getopt.
Copyright (C) 1989-1994, 1996-1999, 2001 Free Software Foundation, Inc.
This file is part of the GNU C Library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/

/*For communication from `getopt' to the caller.
When `getopt' finds an option that takes an argument,
the argument value is returned here.
Also, when `ordering' is RETURN_IN_ORDER,
each non-option ARGV-element is returned here.*/

extern char *optarg;
/*Index in ARGV of the next element to be scanned.
This is used for communication to and from the caller
and for communication between successive calls to `getopt'.

On entry to `getopt', zero means this is the first call; initialize.

When `getopt' returns -1, this is the index of the first of the
non-option elements that the caller should itself scan.

Otherwise, `optind' communicates from one call to the next
how much of ARGV has been scanned so far.*/

extern int optind;
/*Callers store zero here to inhibit the error message `getopt' prints
for unrecognized options.*/

extern int opterr;
/*Set to an option character which was unrecognized.*/

extern int optopt;
/*Describe the long-named options requested by the application.
The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
of `struct option' terminated by an element containing a name which is
zero.

The field `has_arg' is:
no_argument		(or 0) if the option does not take an argument,
required_argument	(or 1) if the option requires an argument,
optional_argument 	(or 2) if the option takes an optional argument.

If the field `flag' is not NULL, it points to a variable that is set
to the value given in the field `val' when the option is found, but
left unchanged if the option is not found.

To have a long-named option do something other than set an `int' to
a compiled-in constant, such as set a value from `optarg', set the
option's `flag' field to zero and its `val' field to a nonzero
value (the equivalent single-letter option character, if there is
one).  For long options that have a zero `flag' field, `getopt'
returns the contents of the `val' field.*/

struct option {
   char const *name;
   /*has_arg can't be an enum because some compilers complain about
   type mismatches in all the code that assumes it is an int.*/
   int has_arg;
   int *flag;
   int val;
};

/*Names for the values of the `has_arg' field of `struct option'.*/
/*Get definitions and prototypes for functions to process the
arguments in ARGV (ARGC of them, minus the program name) for
options given in OPTS.

Return the option character from OPTS just read.  Return -1 when
there are no more options.  For unrecognized options, or options
missing arguments, `optopt' is set to the option letter, and '?' is
returned.

The OPTS string is a list of characters which are recognized option
letters, optionally followed by colons, specifying that that letter
takes an argument, to be placed in `optarg'.

If a letter in OPTS is followed by two colons, its argument is
optional.  This behavior is specific to the GNU `getopt'.

The argument `--' causes premature termination of argument
scanning, explicitly telling `getopt' that there are no more
options.

If OPTS begins with `--', then non-option arguments are treated as
arguments to the option '\0'.  This behavior is specific to the GNU
`getopt'.*/
/*Many other libraries have conflicting prototypes for getopt, with
differences in the consts, in stdlib.h.  To avoid compilation
errors, only prototype getopt for the GNU C library.*/
__attribute__((nonnull(2, 3)))
__attribute__((no_throw))
extern int getopt(int __argc, char * const *__argv, char const *__shortopts);
/*not __GNU_LIBRARY__*/
/*__GNU_LIBRARY__*/
extern int getopt_long(int __argc, char * const *__argv, char const *__shortopts, struct option const *__longopts, int *__longind);
extern int getopt_long_only(int __argc, char * const *__argv, char const *__shortopts, struct option const *__longopts, int *__longind);
/*Internal only.  Users should not call this directly.*/
extern int _getopt_internal(int __argc, char * const *__argv, char const *__shortopts, struct option const *__longopts, int *__longind, int __long_only);
/*not __STDC__*/

/*__STDC__*/

/*Make sure we later can get all the definitions and declarations.*/

/*getopt.h*/

/*For communication from `getopt' to the caller.
When `getopt' finds an option that takes an argument,
the argument value is returned here.
Also, when `ordering' is RETURN_IN_ORDER,
each non-option ARGV-element is returned here.*/

char *optarg;
/*Index in ARGV of the next element to be scanned.
This is used for communication to and from the caller
and for communication between successive calls to `getopt'.

On entry to `getopt', zero means this is the first call; initialize.

When `getopt' returns -1, this is the index of the first of the
non-option elements that the caller should itself scan.

Otherwise, `optind' communicates from one call to the next
how much of ARGV has been scanned so far.*/

/*1003.2 says this must be 1 before any call.*/

int optind = 1;
/*Formerly, initialization of getopt depended on optind==0, which
causes problems with re-calling getopt as programs generally don't
know that.*/

int __getopt_initialized;
/*The next char to be scanned in the option-element
in which the last option character we returned was found.
This allows us to pick up the scan where we left off.

If this is zero, or a null string, it means resume the scan
by advancing to the next ARGV-element.*/

static char *nextchar;
/*Callers store zero here to inhibit the error message
for unrecognized options.*/

int opterr = 1;
/*Set to an option character which was unrecognized.
This must be initialized on some systems to avoid linking in the
system's own getopt implementation.*/

int optopt = '?';
/*Describe how to deal with options that follow non-option ARGV-elements.

If the caller did not specify anything,
the default is REQUIRE_ORDER if the environment variable
POSIXLY_CORRECT is defined, PERMUTE otherwise.

REQUIRE_ORDER means don't recognize them as options;
stop option processing when the first non-option is seen.
This is what Unix does.
This mode of operation is selected by either setting the environment
variable POSIXLY_CORRECT, or using `+' as the first character
of the list of option characters.

PERMUTE is the default.  We permute the contents of ARGV as we scan,
so that eventually all the non-options are at the end.  This allows options
to be given in any order, even with programs that were not written to
expect this.

RETURN_IN_ORDER is an option available to programs that were written
to expect options and other ARGV-elements in any order and that care about
the ordering of the two.  We describe each non-option ARGV-element
as if it were the argument of an option with character code 1.
Using `-' as the first character of the list of option characters
selects this mode of operation.

The special argument `--' forces an end of option-scanning regardless
of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
`--' can cause `getopt' to return -1 with `optind' != ARGC.*/

enum anon_enum_588 {
   REQUIRE_ORDER,
   PERMUTE,
   RETURN_IN_ORDER,
};

static enum anon_enum_588 ordering;
/*Value of POSIXLY_CORRECT environment variable.*/

static char *posixly_correct;
/*Avoid depending on library functions or files
whose names are inconsistent.*/
__attribute__((nonnull(1)))
__attribute__((no_throw))
extern char * getenv(char const *);
static char * __strchr__(char const *str, int chr) {
   while(*str) {
      if(*str == chr) 
      return (char *) str;
      str++;
   }
   
   return 0;
}

/*If using GCC, we can safely declare strlen this way.
If not using GCC, it is ok not to declare it.*/

/*Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
That was relevant to code that was here before.*/

/*gcc with -traditional declares the built-in strlen to return int,
and has done so at least since version 2.4.5. -- rms.*/

/*not __STDC__*/

/*__GNUC__*/

/*Handle permutation of arguments.*/

/*Describe the part of ARGV that contains non-options that have
been skipped.  `first_nonopt' is the index in ARGV of the first of them;
`last_nonopt' is the index after the last of them.*/

static int first_nonopt;
static int last_nonopt;
/*Bash 2.0 gives us an environment variable containing flags
indicating ARGV elements that should not be considered arguments.*/
/*Defined in getopt_init.c*/
/*Make sure the environment variable bash 2.0 puts in the environment
is valid for the getopt call we must make sure that the ARGV passed
to getopt is that one passed to the process.*/
/*XXX This is no good solution.  We should rather copy the args so
that we can compare them later.  But we must not use malloc(3).*/
/*text_set_element*/
/*!_LIBC*/
/*_LIBC*/
/*Exchange two adjacent subsequences of ARGV.
One subsequence is elements [first_nonopt,last_nonopt)
which contains all the non-options that have been skipped so far.
The other is elements [last_nonopt,optind), which contains all
the options processed since those non-options were skipped.

`first_nonopt' and `last_nonopt' are relocated so that they describe
the new indices of the non-options in ARGV after they are moved.*/
static void exchange(char **);
static void exchange(char **argv) {
   int bottom = first_nonopt;
   int middle = last_nonopt;
   int top = optind;
   char *tem;
   /*Exchange the shorter segment with the far end of the longer segment.
   That puts the shorter segment into the right place.
   It leaves the longer segment in the right place overall,
   but it consists of two parts that need to be swapped next.*/
   /*First make sure the handling of the `__getopt_nonoption_flags'
   string can work normally.  Our top argument must be in the range
   of the string.*/
   /*We must extend the array.  The user plays games with us and
   presents new arguments.*/
   while(top > middle && middle > bottom) {
      if(top - middle > middle - bottom) {
         /*Bottom segment is the short one.*/
         int len = middle - bottom;
         register int i;
         /*Swap it with the top part of the top segment.*/
         for(i = 0; i < len; i++) {
            tem = argv[bottom + i];
            argv[bottom + i] = argv[top - (middle - bottom) + i];
            argv[top - (middle - bottom) + i] = tem;
            ;
         }
         /*Exclude the moved bottom segment from further swapping.*/
         top -= len;
      }
      else {
         /*Top segment is the short one.*/
         int len = top - middle;
         register int i;
         /*Swap it with the bottom part of the bottom segment.*/
         for(i = 0; i < len; i++) {
            tem = argv[bottom + i];
            argv[bottom + i] = argv[middle + i];
            argv[middle + i] = tem;
            ;
         }
         /*Exclude the moved top segment from further swapping.*/
         bottom += len;
      }
   }
   /*Update records for the slots the non-options now occupy.*/
   first_nonopt += (optind - last_nonopt);
   last_nonopt = optind;
}

/*Initialize the internal data when the first call is made.*/
static char const * _getopt_initialize(int, char * const *, char const *);
static char const * _getopt_initialize(int argc, char * const *argv, char const *optstring) {
   /*Start processing options with ARGV-element 1 (since ARGV-element 0
   is the program name); the sequence of previously skipped
   non-option ARGV-elements is empty.*/
   first_nonopt = last_nonopt = optind;
   nextchar = ((void *) 0);
   clava_dcg_global[ 21 ]++;
   posixly_correct = getenv("POSIXLY_CORRECT");
   /*Determine how to handle the ordering of options and nonoptions.*/
   if(optstring[0] == '-') {
      ordering = RETURN_IN_ORDER;
      ++optstring;
   }
   else if(optstring[0] == '+') {
      ordering = REQUIRE_ORDER;
      ++optstring;
   }
   else if(posixly_correct != ((void *) 0)) ordering = REQUIRE_ORDER;
   else ordering = PERMUTE;
   
   return optstring;
}

/*Scan elements of ARGV (whose length is ARGC) for option characters
given in OPTSTRING.

If an element of ARGV starts with '-', and is not exactly "-" or "--",
then it is an option element.  The characters of this element
(aside from the initial '-') are option characters.  If `getopt'
is called repeatedly, it returns successively each of the option characters
from each of the option elements.

If `getopt' finds another option character, it returns that character,
updating `optind' and `nextchar' so that the next call to `getopt' can
resume the scan with the following option character or ARGV-element.

If there are no more option characters, `getopt' returns -1.
Then `optind' is the index in ARGV of the first ARGV-element
that is not an option.  (The ARGV-elements have been permuted
so that those that are not options now come last.)

OPTSTRING is a string containing the legitimate option characters.
If an option character is seen that is not listed in OPTSTRING,
return '?' after printing an error message.  If you set `opterr' to
zero, the error message is suppressed but we still return '?'.

If a char in OPTSTRING is followed by a colon, that means it wants an arg,
so the following text in the same ARGV-element, or the text of the following
ARGV-element, is returned in `optarg'.  Two colons mean an option that
wants an optional arg; if there is text in the current ARGV-element,
it is returned in `optarg', otherwise `optarg' is set to zero.

If OPTSTRING starts with `-' or `+', it requests different methods of
handling the non-option ARGV-elements.
See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.

Long-named options begin with `--' instead of `-'.
Their names may be abbreviated as long as the abbreviation is unique
or is an exact match for some defined option.  If they have an
argument, it follows the option name in the same ARGV-element, separated
from the option name by a `=', or else the in next ARGV-element.
When `getopt' finds a long-named option, it returns 0 if that option's
`flag' field is nonzero, the value of the option's `val' field
if the `flag' field is zero.

The elements of ARGV aren't really const, because we permute them.
But we pretend they're const in the prototype to be compatible
with other systems.

LONGOPTS is a vector of `struct option' terminated by an
element containing a name which is zero.

LONGIND returns the index in LONGOPT of the long-named option found.
It is only valid when a long-named option has been found by the most
recent call.

If LONG_ONLY is nonzero, '-' as well as '--' can introduce
long-named options.*/
int _getopt_internal(int argc, char * const *argv, char const *optstring, struct option const *longopts, int *longind, int long_only) {
   int print_errors = opterr;
   if(optstring[0] == ':') print_errors = 0;
   if(argc < 1) 
   return -1;
   optarg = ((void *) 0);
   if(optind == 0 || !__getopt_initialized) {
      if(optind == 0) optind = 1;
      /*Don't scan ARGV[0], the program name.*/
      clava_dcg_global[ 22 ]++;
      optstring = _getopt_initialize(argc, argv, optstring);
      __getopt_initialized = 1;
   }
   /*Test whether ARGV[optind] points to a non-option argument.
   Either it does not have option syntax, or there is an environment flag
   from the shell indicating it is not an option.  The later information
   is only used when the used in the GNU libc.*/
   if(nextchar == ((void *) 0) || *nextchar == '\0') {
      /*Advance to the next ARGV-element.*/
      /*Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
      moved back by the user (who may also have changed the arguments).*/
      if(last_nonopt > optind) last_nonopt = optind;
      if(first_nonopt > optind) first_nonopt = optind;
      if(ordering == PERMUTE) {
         /*If we have just processed some options following some non-options,
         exchange them so that the options come first.*/
         if(first_nonopt != last_nonopt && last_nonopt != optind) {
            clava_dcg_global[ 23 ]++;
            exchange((char **) argv);
         }
         else if(last_nonopt != optind) first_nonopt = optind;
         /*Skip any additional non-options
         and extend the range of non-options previously skipped.*/
         while(optind < argc && (argv[optind][0] != '-' || argv[optind][1] == '\0')) optind++;
         last_nonopt = optind;
      }
      /*The special ARGV-element `--' means premature end of options.
      Skip it like a null option,
      then exchange with previous non-options as if it were an option,
      then skip everything else like a non-option.*/
      clava_dcg_global[ 24 ]++;
      if(optind != argc && !strcmp(argv[optind], "--")) {
         optind++;
         if(first_nonopt != last_nonopt && last_nonopt != optind) {
            clava_dcg_global[ 23 ]++;
            exchange((char **) argv);
         }
         else if(first_nonopt == last_nonopt) first_nonopt = optind;
         last_nonopt = argc;
         optind = argc;
      }
      /*If we have done all the ARGV-elements, stop the scan
      and back over any non-options that we skipped and permuted.*/
      if(optind == argc) {
         /*Set the next-arg-index to point at the non-options
         that we previously skipped, so the caller will digest them.*/
         if(first_nonopt != last_nonopt) optind = first_nonopt;
         
         return -1;
      }
      /*If we have come to a non-option and did not permute it,
      either stop the scan or describe it to the caller and pass it by.*/
      if((argv[optind][0] != '-' || argv[optind][1] == '\0')) {
         if(ordering == REQUIRE_ORDER) 
         return -1;
         optarg = argv[optind++];
         
         return 1;
      }
      /*We have found another option-ARGV-element.
      Skip the initial punctuation.*/
      nextchar = (argv[optind] + 1 + (longopts != ((void *) 0) && argv[optind][1] == '-'));
   }
   /*Decode the current option-ARGV-element.*/
   /*Check whether the ARGV-element is a long option.
   
   If long_only and the ARGV-element has the form "-f", where f is
   a valid short option, don't consider it an abbreviated form of
   a long option that starts with f.  Otherwise there would be no
   way to give the -f short option.
   
   On the other hand, if there's a long option "fubar" and
   the ARGV-element is "-fu", do consider that an abbreviation of
   the long option, just like "--fu", and not "-f" with arg "u".
   
   This distinction seems to be the most useful approach.*/
   clava_dcg_global[ 25 ]++;
   if(longopts != ((void *) 0) && (argv[optind][1] == '-' || (long_only && (argv[optind][2] || !__strchr__(optstring, argv[optind][1]))))) {
      char *nameend;
      struct option const *p;
      struct option const *pfound = ((void *) 0);
      int exact = 0;
      int ambig = 0;
      int indfound = -1;
      int option_index;
      for(nameend = nextchar; *nameend && *nameend != '='; nameend++);
      /*Do nothing.*/
      /*Test all long options for either exact match
      or abbreviated matches.*/
      for(p = longopts , option_index = 0; p->name; p++ , option_index++) {
         clava_dcg_global[ 26 ]++;
         if(!strncmp(p->name, nextchar, nameend - nextchar)) {
            clava_dcg_global[ 27 ]++;
            if((unsigned int) (nameend - nextchar) == (unsigned int) strlen(p->name)) {
               /*Exact match found.*/
               pfound = p;
               indfound = option_index;
               exact = 1;
               break;
            }
            else if(pfound == ((void *) 0)) {
               /*First nonexact match found.*/
               pfound = p;
               indfound = option_index;
            }
            else if(long_only || pfound->has_arg != p->has_arg || pfound->flag != p->flag || pfound->val != p->val) {
               /*Second or later nonexact match found.*/
               ambig = 1;
            }
         }
      }
      if(ambig && !exact) {
         if(print_errors) {
            clava_dcg_global[ 28 ]++;
            fprintf(stderr, ("%s: option `%s' is ambiguous\n"), argv[0], argv[optind]);
         }
         clava_dcg_global[ 27 ]++;
         nextchar += strlen(nextchar);
         optind++;
         optopt = 0;
         
         return '?';
      }
      if(pfound != ((void *) 0)) {
         option_index = indfound;
         optind++;
         if(*nameend) {
            /*Don't test has_arg with >, because some C compilers don't
            allow it to be used on enums.*/
            if(pfound->has_arg) optarg = nameend + 1;
            else {
               if(print_errors) {
                  if(argv[optind - 1][1] == '-') {
                     /*--option*/
                     clava_dcg_global[ 28 ]++;
                     fprintf(stderr, ("%s: option `--%s' doesn't allow an argument\n"), argv[0], pfound->name);
                  }
                  else {
                     /*+option or -option*/
                     clava_dcg_global[ 28 ]++;
                     fprintf(stderr, ("%s: option `%c%s' doesn't allow an argument\n"), argv[0], argv[optind - 1][0], pfound->name);
                  }
               }
               clava_dcg_global[ 27 ]++;
               nextchar += strlen(nextchar);
               optopt = pfound->val;
               
               return '?';
            }
         }
         else if(pfound->has_arg == 1) {
            if(optind < argc) optarg = argv[optind++];
            else {
               if(print_errors) {
                  clava_dcg_global[ 28 ]++;
                  fprintf(stderr, ("%s: option `%s' requires an argument\n"), argv[0], argv[optind - 1]);
               }
               clava_dcg_global[ 27 ]++;
               nextchar += strlen(nextchar);
               optopt = pfound->val;
               
               return optstring[0] == ':' ? ':' : '?';
            }
         }
         clava_dcg_global[ 27 ]++;
         nextchar += strlen(nextchar);
         if(longind != ((void *) 0)) *longind = option_index;
         if(pfound->flag) {
            *(pfound->flag) = pfound->val;
            
            return 0;
         }
         
         return pfound->val;
      }
      /*Can't find it as a long option.  If this is not getopt_long_only,
      or the option starts with '--' or is not a valid short
      option, then it's an error.
      Otherwise interpret it as a short option.*/
      clava_dcg_global[ 25 ]++;
      if(!long_only || argv[optind][1] == '-' || __strchr__(optstring, *nextchar) == ((void *) 0)) {
         if(print_errors) {
            if(argv[optind][1] == '-') {
               /*--option*/
               clava_dcg_global[ 28 ]++;
               fprintf(stderr, ("%s: unrecognized option `--%s'\n"), argv[0], nextchar);
            }
            else {
               /*+option or -option*/
               clava_dcg_global[ 28 ]++;
               fprintf(stderr, ("%s: unrecognized option `%c%s'\n"), argv[0], argv[optind][0], nextchar);
            }
         }
         nextchar = (char *) "";
         optind++;
         optopt = 0;
         
         return '?';
      }
   }
   /*Look at and handle the next short option-character.*/
   {
      char c = *nextchar++;
      clava_dcg_global[ 25 ]++;
      char *temp = __strchr__(optstring, c);
      /*Increment `optind' when we start to process its last character.*/
      if(*nextchar == '\0') ++optind;
      if(temp == ((void *) 0) || c == ':') {
         if(print_errors) {
            if(posixly_correct) {
               /*1003.2 specifies the format of this message.*/
               clava_dcg_global[ 28 ]++;
               fprintf(stderr, ("%s: illegal option -- %c\n"), argv[0], c);
            }
            else {
               clava_dcg_global[ 28 ]++;
               fprintf(stderr, ("%s: invalid option -- %c\n"), argv[0], c);
            }
         }
         optopt = c;
         
         return '?';
      }
      /*Convenience. Treat POSIX -W foo same as long option --foo*/
      if(temp[0] == 'W' && temp[1] == ';') {
         char *nameend;
         struct option const *p;
         struct option const *pfound = ((void *) 0);
         int exact = 0;
         int ambig = 0;
         int indfound = 0;
         int option_index;
         /*This is an option that requires an argument.*/
         if(*nextchar != '\0') {
            optarg = nextchar;
            /*If we end this ARGV-element by taking the rest as an arg,
            we must advance to the next element now.*/
            optind++;
         }
         else if(optind == argc) {
            if(print_errors) {
               /*1003.2 specifies the format of this message.*/
               clava_dcg_global[ 28 ]++;
               fprintf(stderr, ("%s: option requires an argument -- %c\n"), argv[0], c);
            }
            optopt = c;
            if(optstring[0] == ':') c = ':';
            else c = '?';
            
            return c;
         }
         else {
            /*We already incremented `optind' once;
            increment it again when taking next ARGV-elt as argument.*/
            optarg = argv[optind++];
         }
         /*optarg is now the argument, see if it's in the
         table of longopts.*/
         for(nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++);
         /*Do nothing.*/
         /*Test all long options for either exact match
         or abbreviated matches.*/
         for(p = longopts , option_index = 0; p->name; p++ , option_index++) {
            clava_dcg_global[ 26 ]++;
            if(!strncmp(p->name, nextchar, nameend - nextchar)) {
               clava_dcg_global[ 27 ]++;
               if((unsigned int) (nameend - nextchar) == strlen(p->name)) {
                  /*Exact match found.*/
                  pfound = p;
                  indfound = option_index;
                  exact = 1;
                  break;
               }
               else if(pfound == ((void *) 0)) {
                  /*First nonexact match found.*/
                  pfound = p;
                  indfound = option_index;
               }
               else {
                  /*Second or later nonexact match found.*/
                  ambig = 1;
               }
            }
         }
         if(ambig && !exact) {
            if(print_errors) {
               clava_dcg_global[ 28 ]++;
               fprintf(stderr, ("%s: option `-W %s' is ambiguous\n"), argv[0], argv[optind]);
            }
            clava_dcg_global[ 27 ]++;
            nextchar += strlen(nextchar);
            optind++;
            
            return '?';
         }
         if(pfound != ((void *) 0)) {
            option_index = indfound;
            if(*nameend) {
               /*Don't test has_arg with >, because some C compilers don't
               allow it to be used on enums.*/
               if(pfound->has_arg) optarg = nameend + 1;
               else {
                  if(print_errors) {
                     clava_dcg_global[ 28 ]++;
                     fprintf(stderr, ("%s: option `-W %s' doesn't allow an argument\n"), argv[0], pfound->name);
                  }
                  clava_dcg_global[ 27 ]++;
                  nextchar += strlen(nextchar);
                  
                  return '?';
               }
            }
            else if(pfound->has_arg == 1) {
               if(optind < argc) optarg = argv[optind++];
               else {
                  if(print_errors) {
                     clava_dcg_global[ 28 ]++;
                     fprintf(stderr, ("%s: option `%s' requires an argument\n"), argv[0], argv[optind - 1]);
                  }
                  clava_dcg_global[ 27 ]++;
                  nextchar += strlen(nextchar);
                  
                  return optstring[0] == ':' ? ':' : '?';
               }
            }
            clava_dcg_global[ 27 ]++;
            nextchar += strlen(nextchar);
            if(longind != ((void *) 0)) *longind = option_index;
            if(pfound->flag) {
               *(pfound->flag) = pfound->val;
               
               return 0;
            }
            
            return pfound->val;
         }
         nextchar = ((void *) 0);
         
         return 'W';
         /*Let the application handle it.*/
      }
      if(temp[1] == ':') {
         if(temp[2] == ':') {
            /*This is an option that accepts an argument optionally.*/
            if(*nextchar != '\0') {
               optarg = nextchar;
               optind++;
            }
            else optarg = ((void *) 0);
            nextchar = ((void *) 0);
         }
         else {
            /*This is an option that requires an argument.*/
            if(*nextchar != '\0') {
               optarg = nextchar;
               /*If we end this ARGV-element by taking the rest as an arg,
               we must advance to the next element now.*/
               optind++;
            }
            else if(optind == argc) {
               if(print_errors) {
                  /*1003.2 specifies the format of this message.*/
                  clava_dcg_global[ 28 ]++;
                  fprintf(stderr, ("%s: option requires an argument -- %c\n"), argv[0], c);
               }
               optopt = c;
               if(optstring[0] == ':') c = ':';
               else c = '?';
            }
            else {
               /*We already incremented `optind' once;
               increment it again when taking next ARGV-elt as argument.*/
               optarg = argv[optind++];
            }
            nextchar = ((void *) 0);
         }
      }
      
      return c;
   }
}

__attribute__((nonnull(2, 3)))
__attribute__((no_throw))
int getopt(int argc, char * const *argv, char const *optstring) {
   clava_dcg_global[ 29 ]++;
   
   return _getopt_internal(argc, argv, optstring, (struct option const *) 0, (int *) 0, 0);
}

/*getopt_long and getopt_long_only entry points for GNU getopt.
Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
Free Software Foundation, Inc.
This file is part of the GNU C Library.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/

/*This is a separate conditional since some stdc systems
reject `defined (const)'.*/

/*Comment out all this code if we are using the GNU C Library, and are not
actually compiling the library itself.  This code is part of the GNU C
Library, but also included in many other GNU distributions.  Compiling
and linking in this code is a waste when using the GNU C library
(especially if it is a shared library).  Rather than having every GNU
program understand `configure --with-gnu-libc' and omit the object files,
it is simpler to just do this in the source for each such file.*/

/*gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface
* Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
* Copyright (C) 1992-1993 Jean-loup Gailly
* The unzip code was written and put in the public domain by Mark Adler.
* Portions of the lzw code are derived from the public domain 'compress'
* written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
* Ken Turkowski, Dave Mack and Peter Jannesen.
*
* See the license_msg below and the file COPYING for the software license.
* See the file algorithm.doc for the compression algorithms and file formats.
*/

static char *license_msg[7] = {"Copyright 2002 Free Software Foundation", "Copyright 1992-1993 Jean-loup Gailly", "This program comes with ABSOLUTELY NO WARRANTY.", "You may redistribute copies of this program", "under the terms of the GNU General Public License.", "For more information about these matters, see the file named COPYING.", 0};
/*Compress files with zip algorithm and 'compress' interface.
* See usage() and help() functions below for all options.
* Outputs:
*        file.gz:   compressed file with same mode, owner, and utimes
*     or stdout with -c option or if stdin used as input.
* If the output file name had to be truncated, the original name is kept
* in the compressed file.
* On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-gz.
*
* Using gz on MSDOS would create too many file name conflicts. For
* example, foo.txt -> foo.tgz (.tgz must be reserved as shorthand for
* tar.gz). Similarly, foo.dir and foo.doc would both be mapped to foo.dgz.
* I also considered 12345678.txt -> 12345txt.gz but this truncates the name
* too heavily. There is no ideal solution given the MSDOS 8+3 limitation.
*
* For the meaning of all compilation flags, see comments in Makefile.in.
*/

/*revision.h -- define the version number
* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
* Copyright (C) 1992-1993 Jean-loup Gailly.
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

/*This version does not support compression into old compress format:*/

/*$Id: revision.h,v 0.25 1993/06/24 08:29:52 jloup Exp $*/

/*configuration*/

typedef void (*sig_type) (int);
/*creation mode for open()*/

/*creation mode for open()*/

/*max pathname length*/

/*Separator for file name parts (see shorten_name())*/

/*global buffers*/

uch inbuf[32832];
uch outbuf[18432];
ush d_buf[32768];
uch window[65536];
ush prev[65536];
/*local variables*/

int ascii = 0;
/*convert end-of-lines to local OS conventions*/

int to_stdout = 0;
/*output to stdout (-c)*/

int decompress = 0;
/*decompress (-d)*/

int force = 0;
/*don't ask questions, compress links (-f)*/

int no_name = -1;
/*don't save or restore the original file name*/

int no_time = -1;
/*don't save or restore the original file time*/

int recursive = 0;
/*recurse through directories (-r)*/

int list = 0;
/*list the file contents (-l)*/

int verbose = 0;
/*be verbose (-v)*/

int quiet = 0;
/*be very quiet (-q)*/

int do_lzw = 0;
/*generate output compatible with old compress (-Z)*/

int test = 0;
/*test .gz file integrity*/

int foreground;
/*set if program run in foreground*/

char *progname;
/*program name*/

int maxbits = 16;
/*max bits per code for LZW*/

int method = 8;
/*compression method*/

int level = 6;
/*compression level*/

int exit_code = 0;
/*program exit code*/

int save_orig_name;
/*set if original name must be saved*/

int last_member;
/*set for .zip and .Z files*/

int part_nb;
/*number of parts in .gz file*/

time_t time_stamp;
/*original time stamp (modification time)*/

off_t ifile_size;
/*input file size, -1 for devices (debug only)*/

char *env;
/*contents of GZIP env variable*/

char **args = ((void *) 0);
/*argv pointer if GZIP env variable defined*/

char *z_suffix;
/*default suffix (can be set with --suffix)*/

size_t z_len;
/*strlen(z_suffix)*/

off_t bytes_in;
/*number of input bytes*/

off_t bytes_out;
/*number of output bytes*/

off_t total_in;
/*input bytes for all files*/

off_t total_out;
/*output bytes for all files*/

char ifname[1024];
/*input file name*/

char ofname[1024];
/*output file name*/

int remove_ofname = 0;
/*remove output file on error*/

struct stat istat;
/*status for input file*/

int ifd;
/*input file descriptor*/

int ofd;
/*output file descriptor*/

unsigned int insize;
/*valid bytes in inbuf*/

unsigned int inptr;
/*index of next byte to be processed in inbuf*/

unsigned int outcnt;
/*bytes in output buffer*/

int rsync = 0;
/*make ryncable chunks*/

struct option longopts[25] = {{"ascii", 0, 0, 'a'}, {"to-stdout", 0, 0, 'c'}, {"stdout", 0, 0, 'c'}, {"decompress", 0, 0, 'd'}, {"uncompress", 0, 0, 'd'}, {"force", 0, 0, 'f'}, {"help", 0, 0, 'h'}, {"list", 0, 0, 'l'}, {"license", 0, 0, 'L'}, {"no-name", 0, 0, 'n'}, {"name", 0, 0, 'N'}, {"quiet", 0, 0, 'q'}, {"silent", 0, 0, 'q'}, {"recursive", 0, 0, 'r'}, {"suffix", 1, 0, 'S'}, {"test", 0, 0, 't'}, {"no-time", 0, 0, 'T'}, {"verbose", 0, 0, 'v'}, {"version", 0, 0, 'V'}, {"fast", 0, 0, '1'}, {"best", 0, 0, '9'}, {"lzw", 0, 0, 'Z'}, {"bits", 1, 0, 'b'}, {"rsyncable", 0, 0, 'R'}, {0, 0, 0, 0}};
/*{ name  has_arg  *flag  val }*/
/*{"encrypt",    0, 0, 'e'},    encrypt*/
/*{"pkzip",      0, 0, 'k'},    force output in pkzip format*/
/*local functions*/
static void usage();
static void help();
static void license();
static void version();
static int input_eof();
static void treat_stdin();
static void treat_file(char *iname);
static int create_outfile();
static int do_stat(char *name, struct stat *sbuf);
static char * get_suffix(char *name);
static int get_istat(char *iname, struct stat *sbuf);
static int make_ofname();
static int same_file(struct stat *stat1, struct stat *stat2);
static int name_too_long(char *name, struct stat *statb);
static void shorten_name(char *name);
static int get_method(int in);
static void do_list(int ifd, int method);
static int check_ofname();
static void copy_stat(struct stat *ifstat);
static void do_exit(int exitcode);
int main(int argc, char **argv);
int (*work) (int, int) = zip;
/*function to call*/
static void treat_dir(char *dir);
static void reset_times(char *name, struct stat *statb);
/*========================================================================*/
static void usage() {
   clava_dcg_global[ 30 ]++;
   printf("usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n", progname, 0 ? "a" : "", 0 ? "" : "r");
}

/*========================================================================*/
static void help() {
   static char *help_msg[20] = {" -c --stdout      write on standard output, keep original files unchanged", " -d --decompress  decompress", " -f --force       force overwrite of output file and compress links", " -h --help        give this help", " -l --list        list compressed file contents", " -L --license     display software license", " -n --no-name     do not save or restore the original name and time stamp", " -N --name        save or restore the original name and time stamp", " -q --quiet       suppress all warnings", " -r --recursive   operate recursively on directories", " -S .suf  --suffix .suf     use suffix .suf on compressed files", " -t --test        test compressed file integrity", " -v --verbose     verbose mode", " -V --version     display version number", " -1 --fast        compress faster", " -9 --best        compress better", "    --rsyncable   Make rsync-friendly archive", " file...          files to (de)compress. If none given, use standard input.", "Report bugs to <bug-gzip@gnu.org>.", 0};
   /*-e --encrypt     encrypt*/
   /*-k --pkzip       force output in pkzip format*/
   char **p = help_msg;
   clava_dcg_global[ 31 ]++;
   printf("%s %s\n(%s)\n", progname, "1.3.5", "2002-09-30");
   clava_dcg_global[ 32 ]++;
   usage();
   while(*p) {
      clava_dcg_global[ 31 ]++;
      printf("%s\n", *p++);
   }
}

/*========================================================================*/
static void license() {
   char **p = license_msg;
   clava_dcg_global[ 33 ]++;
   printf("%s %s\n(%s)\n", progname, "1.3.5", "2002-09-30");
   while(*p) {
      clava_dcg_global[ 33 ]++;
      printf("%s\n", *p++);
   }
}

/*========================================================================*/
static void version() {
   clava_dcg_global[ 34 ]++;
   license();
   clava_dcg_global[ 35 ]++;
   printf("Compilation options:\n%s %s ", "DIRENT", "UTIME");
   clava_dcg_global[ 35 ]++;
   printf("STDC_HEADERS ");
   clava_dcg_global[ 35 ]++;
   printf("HAVE_UNISTD_H ");
   clava_dcg_global[ 35 ]++;
   printf("HAVE_MEMORY_H ");
   clava_dcg_global[ 35 ]++;
   printf("HAVE_STRING_H ");
   clava_dcg_global[ 35 ]++;
   printf("HAVE_LSTAT ");
   clava_dcg_global[ 35 ]++;
   printf("\n");
   clava_dcg_global[ 35 ]++;
   printf("Written by Jean-loup Gailly.\n");
}

static void progerror(char *string) {
   clava_dcg_global[ 36 ]++;
   int e = (*__errno_location());
   clava_dcg_global[ 37 ]++;
   fprintf(stderr, "%s: ", progname);
   clava_dcg_global[ 36 ]++;
   (*__errno_location()) = e;
   clava_dcg_global[ 38 ]++;
   perror(string);
   exit_code = 1;
}

/*========================================================================*/
void clava_call_graph() {
   FILE *log_file_364 = fopen("/home/specs/jbispo/repos/clava-examples/2019-C_Stress_Test/output/gzip.dot", "w+");
   if (log_file_364 == NULL)
   {
       printf("Error opening file /home/specs/jbispo/repos/clava-examples/2019-C_Stress_Test/output/gzip.dot\n");
       exit(1);
   } 
   fprintf(log_file_364, "digraph dynamic_call_graph {\n\n");
   if(clava_dcg_global[0] != 0) {
      fprintf(log_file_364, "	send_bits -> flush_outbuf [label=\"%d\"];\n", clava_dcg_global[0]);
   }
   if(clava_dcg_global[1] != 0) {
      fprintf(log_file_364, "	bi_windup -> flush_outbuf [label=\"%d\"];\n", clava_dcg_global[1]);
   }
   if(clava_dcg_global[2] != 0) {
      fprintf(log_file_364, "	copy_block -> bi_windup [label=\"%d\"];\n", clava_dcg_global[2]);
   }
   if(clava_dcg_global[3] != 0) {
      fprintf(log_file_364, "	copy_block -> flush_outbuf [label=\"%d\"];\n", clava_dcg_global[3]);
   }
   if(clava_dcg_global[4] != 0) {
      fprintf(log_file_364, "	lm_init -> error [label=\"%d\"];\n", clava_dcg_global[4]);
   }
   if(clava_dcg_global[5] != 0) {
      fprintf(log_file_364, "	lm_init -> memset [label=\"%d\"];\n", clava_dcg_global[5]);
   }
   if(clava_dcg_global[6] != 0) {
      fprintf(log_file_364, "	lm_init -> read_buf [label=\"%d\"];\n", clava_dcg_global[6]);
   }
   if(clava_dcg_global[7] != 0) {
      fprintf(log_file_364, "	lm_init -> fill_window [label=\"%d\"];\n", clava_dcg_global[7]);
   }
   if(clava_dcg_global[8] != 0) {
      fprintf(log_file_364, "	fill_window -> memcpy [label=\"%d\"];\n", clava_dcg_global[8]);
   }
   if(clava_dcg_global[9] != 0) {
      fprintf(log_file_364, "	fill_window -> read_buf [label=\"%d\"];\n", clava_dcg_global[9]);
   }
   if(clava_dcg_global[10] != 0) {
      fprintf(log_file_364, "	deflate_fast -> longest_match [label=\"%d\"];\n", clava_dcg_global[10]);
   }
   if(clava_dcg_global[11] != 0) {
      fprintf(log_file_364, "	deflate_fast -> ct_tally [label=\"%d\"];\n", clava_dcg_global[11]);
   }
   if(clava_dcg_global[12] != 0) {
      fprintf(log_file_364, "	deflate_fast -> rsync_roll [label=\"%d\"];\n", clava_dcg_global[12]);
   }
   if(clava_dcg_global[13] != 0) {
      fprintf(log_file_364, "	deflate_fast -> flush_block [label=\"%d\"];\n", clava_dcg_global[13]);
   }
   if(clava_dcg_global[14] != 0) {
      fprintf(log_file_364, "	deflate_fast -> fill_window [label=\"%d\"];\n", clava_dcg_global[14]);
   }
   if(clava_dcg_global[15] != 0) {
      fprintf(log_file_364, "	deflate -> deflate_fast [label=\"%d\"];\n", clava_dcg_global[15]);
   }
   if(clava_dcg_global[16] != 0) {
      fprintf(log_file_364, "	deflate -> longest_match [label=\"%d\"];\n", clava_dcg_global[16]);
   }
   if(clava_dcg_global[17] != 0) {
      fprintf(log_file_364, "	deflate -> ct_tally [label=\"%d\"];\n", clava_dcg_global[17]);
   }
   if(clava_dcg_global[18] != 0) {
      fprintf(log_file_364, "	deflate -> rsync_roll [label=\"%d\"];\n", clava_dcg_global[18]);
   }
   if(clava_dcg_global[19] != 0) {
      fprintf(log_file_364, "	deflate -> flush_block [label=\"%d\"];\n", clava_dcg_global[19]);
   }
   if(clava_dcg_global[20] != 0) {
      fprintf(log_file_364, "	deflate -> fill_window [label=\"%d\"];\n", clava_dcg_global[20]);
   }
   if(clava_dcg_global[21] != 0) {
      fprintf(log_file_364, "	_getopt_initialize -> getenv [label=\"%d\"];\n", clava_dcg_global[21]);
   }
   if(clava_dcg_global[22] != 0) {
      fprintf(log_file_364, "	_getopt_internal -> _getopt_initialize [label=\"%d\"];\n", clava_dcg_global[22]);
   }
   if(clava_dcg_global[23] != 0) {
      fprintf(log_file_364, "	_getopt_internal -> exchange [label=\"%d\"];\n", clava_dcg_global[23]);
   }
   if(clava_dcg_global[24] != 0) {
      fprintf(log_file_364, "	_getopt_internal -> strcmp [label=\"%d\"];\n", clava_dcg_global[24]);
   }
   if(clava_dcg_global[25] != 0) {
      fprintf(log_file_364, "	_getopt_internal -> __strchr__ [label=\"%d\"];\n", clava_dcg_global[25]);
   }
   if(clava_dcg_global[26] != 0) {
      fprintf(log_file_364, "	_getopt_internal -> strncmp [label=\"%d\"];\n", clava_dcg_global[26]);
   }
   if(clava_dcg_global[27] != 0) {
      fprintf(log_file_364, "	_getopt_internal -> strlen [label=\"%d\"];\n", clava_dcg_global[27]);
   }
   if(clava_dcg_global[28] != 0) {
      fprintf(log_file_364, "	_getopt_internal -> fprintf [label=\"%d\"];\n", clava_dcg_global[28]);
   }
   if(clava_dcg_global[29] != 0) {
      fprintf(log_file_364, "	getopt -> _getopt_internal [label=\"%d\"];\n", clava_dcg_global[29]);
   }
   if(clava_dcg_global[30] != 0) {
      fprintf(log_file_364, "	usage -> printf [label=\"%d\"];\n", clava_dcg_global[30]);
   }
   if(clava_dcg_global[31] != 0) {
      fprintf(log_file_364, "	help -> printf [label=\"%d\"];\n", clava_dcg_global[31]);
   }
   if(clava_dcg_global[32] != 0) {
      fprintf(log_file_364, "	help -> usage [label=\"%d\"];\n", clava_dcg_global[32]);
   }
   if(clava_dcg_global[33] != 0) {
      fprintf(log_file_364, "	license -> printf [label=\"%d\"];\n", clava_dcg_global[33]);
   }
   if(clava_dcg_global[34] != 0) {
      fprintf(log_file_364, "	version -> license [label=\"%d\"];\n", clava_dcg_global[34]);
   }
   if(clava_dcg_global[35] != 0) {
      fprintf(log_file_364, "	version -> printf [label=\"%d\"];\n", clava_dcg_global[35]);
   }
   if(clava_dcg_global[36] != 0) {
      fprintf(log_file_364, "	progerror -> __errno_location [label=\"%d\"];\n", clava_dcg_global[36]);
   }
   if(clava_dcg_global[37] != 0) {
      fprintf(log_file_364, "	progerror -> fprintf [label=\"%d\"];\n", clava_dcg_global[37]);
   }
   if(clava_dcg_global[38] != 0) {
      fprintf(log_file_364, "	progerror -> perror [label=\"%d\"];\n", clava_dcg_global[38]);
   }
   if(clava_dcg_global[39] != 0) {
      fprintf(log_file_364, "	main -> base_name [label=\"%d\"];\n", clava_dcg_global[39]);
   }
   if(clava_dcg_global[40] != 0) {
      fprintf(log_file_364, "	main -> strlen [label=\"%d\"];\n", clava_dcg_global[40]);
   }
   if(clava_dcg_global[41] != 0) {
      fprintf(log_file_364, "	main -> strcmp [label=\"%d\"];\n", clava_dcg_global[41]);
   }
   if(clava_dcg_global[42] != 0) {
      fprintf(log_file_364, "	main -> add_envopt [label=\"%d\"];\n", clava_dcg_global[42]);
   }
   if(clava_dcg_global[43] != 0) {
      fprintf(log_file_364, "	main -> signal [label=\"%d\"];\n", clava_dcg_global[43]);
   }
   if(clava_dcg_global[44] != 0) {
      fprintf(log_file_364, "	main -> strncmp [label=\"%d\"];\n", clava_dcg_global[44]);
   }
   if(clava_dcg_global[45] != 0) {
      fprintf(log_file_364, "	main -> getopt_long [label=\"%d\"];\n", clava_dcg_global[45]);
   }
   if(clava_dcg_global[46] != 0) {
      fprintf(log_file_364, "	main -> atoi [label=\"%d\"];\n", clava_dcg_global[46]);
   }
   if(clava_dcg_global[47] != 0) {
      fprintf(log_file_364, "	main -> fprintf [label=\"%d\"];\n", clava_dcg_global[47]);
   }
   if(clava_dcg_global[48] != 0) {
      fprintf(log_file_364, "	main -> usage [label=\"%d\"];\n", clava_dcg_global[48]);
   }
   if(clava_dcg_global[49] != 0) {
      fprintf(log_file_364, "	main -> do_exit [label=\"%d\"];\n", clava_dcg_global[49]);
   }
   if(clava_dcg_global[50] != 0) {
      fprintf(log_file_364, "	main -> help [label=\"%d\"];\n", clava_dcg_global[50]);
   }
   if(clava_dcg_global[51] != 0) {
      fprintf(log_file_364, "	main -> license [label=\"%d\"];\n", clava_dcg_global[51]);
   }
   if(clava_dcg_global[52] != 0) {
      fprintf(log_file_364, "	main -> version [label=\"%d\"];\n", clava_dcg_global[52]);
   }
   if(clava_dcg_global[53] != 0) {
      fprintf(log_file_364, "	main -> treat_file [label=\"%d\"];\n", clava_dcg_global[53]);
   }
   if(clava_dcg_global[54] != 0) {
      fprintf(log_file_364, "	main -> treat_stdin [label=\"%d\"];\n", clava_dcg_global[54]);
   }
   if(clava_dcg_global[55] != 0) {
      fprintf(log_file_364, "	main -> do_list [label=\"%d\"];\n", clava_dcg_global[55]);
   }
   if(clava_dcg_global[56] != 0) {
      fprintf(log_file_364, "	input_eof -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[56]);
   }
   if(clava_dcg_global[57] != 0) {
      fprintf(log_file_364, "	treat_stdin -> isatty [label=\"%d\"];\n", clava_dcg_global[57]);
   }
   if(clava_dcg_global[58] != 0) {
      fprintf(log_file_364, "	treat_stdin -> fileno [label=\"%d\"];\n", clava_dcg_global[58]);
   }
   if(clava_dcg_global[59] != 0) {
      fprintf(log_file_364, "	treat_stdin -> fprintf [label=\"%d\"];\n", clava_dcg_global[59]);
   }
   if(clava_dcg_global[60] != 0) {
      fprintf(log_file_364, "	treat_stdin -> do_exit [label=\"%d\"];\n", clava_dcg_global[60]);
   }
   if(clava_dcg_global[61] != 0) {
      fprintf(log_file_364, "	treat_stdin -> strcpy [label=\"%d\"];\n", clava_dcg_global[61]);
   }
   if(clava_dcg_global[62] != 0) {
      fprintf(log_file_364, "	treat_stdin -> fstat [label=\"%d\"];\n", clava_dcg_global[62]);
   }
   if(clava_dcg_global[63] != 0) {
      fprintf(log_file_364, "	treat_stdin -> progerror [label=\"%d\"];\n", clava_dcg_global[63]);
   }
   if(clava_dcg_global[64] != 0) {
      fprintf(log_file_364, "	treat_stdin -> clear_bufs [label=\"%d\"];\n", clava_dcg_global[64]);
   }
   if(clava_dcg_global[65] != 0) {
      fprintf(log_file_364, "	treat_stdin -> get_method [label=\"%d\"];\n", clava_dcg_global[65]);
   }
   if(clava_dcg_global[66] != 0) {
      fprintf(log_file_364, "	treat_stdin -> do_list [label=\"%d\"];\n", clava_dcg_global[66]);
   }
   if(clava_dcg_global[67] != 0) {
      fprintf(log_file_364, "	treat_stdin -> work [label=\"%d\"];\n", clava_dcg_global[67]);
   }
   if(clava_dcg_global[68] != 0) {
      fprintf(log_file_364, "	treat_stdin -> input_eof [label=\"%d\"];\n", clava_dcg_global[68]);
   }
   if(clava_dcg_global[69] != 0) {
      fprintf(log_file_364, "	treat_stdin -> display_ratio [label=\"%d\"];\n", clava_dcg_global[69]);
   }
   if(clava_dcg_global[70] != 0) {
      fprintf(log_file_364, "	treat_file -> strcmp [label=\"%d\"];\n", clava_dcg_global[70]);
   }
   if(clava_dcg_global[71] != 0) {
      fprintf(log_file_364, "	treat_file -> treat_stdin [label=\"%d\"];\n", clava_dcg_global[71]);
   }
   if(clava_dcg_global[72] != 0) {
      fprintf(log_file_364, "	treat_file -> get_istat [label=\"%d\"];\n", clava_dcg_global[72]);
   }
   if(clava_dcg_global[73] != 0) {
      fprintf(log_file_364, "	treat_file -> treat_dir [label=\"%d\"];\n", clava_dcg_global[73]);
   }
   if(clava_dcg_global[74] != 0) {
      fprintf(log_file_364, "	treat_file -> reset_times [label=\"%d\"];\n", clava_dcg_global[74]);
   }
   if(clava_dcg_global[75] != 0) {
      fprintf(log_file_364, "	treat_file -> fprintf [label=\"%d\"];\n", clava_dcg_global[75]);
   }
   if(clava_dcg_global[76] != 0) {
      fprintf(log_file_364, "	treat_file -> strcpy [label=\"%d\"];\n", clava_dcg_global[76]);
   }
   if(clava_dcg_global[77] != 0) {
      fprintf(log_file_364, "	treat_file -> make_ofname [label=\"%d\"];\n", clava_dcg_global[77]);
   }
   if(clava_dcg_global[78] != 0) {
      fprintf(log_file_364, "	treat_file -> open [label=\"%d\"];\n", clava_dcg_global[78]);
   }
   if(clava_dcg_global[79] != 0) {
      fprintf(log_file_364, "	treat_file -> progerror [label=\"%d\"];\n", clava_dcg_global[79]);
   }
   if(clava_dcg_global[80] != 0) {
      fprintf(log_file_364, "	treat_file -> clear_bufs [label=\"%d\"];\n", clava_dcg_global[80]);
   }
   if(clava_dcg_global[81] != 0) {
      fprintf(log_file_364, "	treat_file -> get_method [label=\"%d\"];\n", clava_dcg_global[81]);
   }
   if(clava_dcg_global[82] != 0) {
      fprintf(log_file_364, "	treat_file -> close [label=\"%d\"];\n", clava_dcg_global[82]);
   }
   if(clava_dcg_global[83] != 0) {
      fprintf(log_file_364, "	treat_file -> do_list [label=\"%d\"];\n", clava_dcg_global[83]);
   }
   if(clava_dcg_global[84] != 0) {
      fprintf(log_file_364, "	treat_file -> fileno [label=\"%d\"];\n", clava_dcg_global[84]);
   }
   if(clava_dcg_global[85] != 0) {
      fprintf(log_file_364, "	treat_file -> create_outfile [label=\"%d\"];\n", clava_dcg_global[85]);
   }
   if(clava_dcg_global[86] != 0) {
      fprintf(log_file_364, "	treat_file -> work [label=\"%d\"];\n", clava_dcg_global[86]);
   }
   if(clava_dcg_global[87] != 0) {
      fprintf(log_file_364, "	treat_file -> input_eof [label=\"%d\"];\n", clava_dcg_global[87]);
   }
   if(clava_dcg_global[88] != 0) {
      fprintf(log_file_364, "	treat_file -> copy_stat [label=\"%d\"];\n", clava_dcg_global[88]);
   }
   if(clava_dcg_global[89] != 0) {
      fprintf(log_file_364, "	treat_file -> write_error [label=\"%d\"];\n", clava_dcg_global[89]);
   }
   if(clava_dcg_global[90] != 0) {
      fprintf(log_file_364, "	treat_file -> xunlink [label=\"%d\"];\n", clava_dcg_global[90]);
   }
   if(clava_dcg_global[91] != 0) {
      fprintf(log_file_364, "	treat_file -> display_ratio [label=\"%d\"];\n", clava_dcg_global[91]);
   }
   if(clava_dcg_global[92] != 0) {
      fprintf(log_file_364, "	create_outfile -> check_ofname [label=\"%d\"];\n", clava_dcg_global[92]);
   }
   if(clava_dcg_global[93] != 0) {
      fprintf(log_file_364, "	create_outfile -> close [label=\"%d\"];\n", clava_dcg_global[93]);
   }
   if(clava_dcg_global[94] != 0) {
      fprintf(log_file_364, "	create_outfile -> open [label=\"%d\"];\n", clava_dcg_global[94]);
   }
   if(clava_dcg_global[95] != 0) {
      fprintf(log_file_364, "	create_outfile -> progerror [label=\"%d\"];\n", clava_dcg_global[95]);
   }
   if(clava_dcg_global[96] != 0) {
      fprintf(log_file_364, "	create_outfile -> fstat [label=\"%d\"];\n", clava_dcg_global[96]);
   }
   if(clava_dcg_global[97] != 0) {
      fprintf(log_file_364, "	create_outfile -> xunlink [label=\"%d\"];\n", clava_dcg_global[97]);
   }
   if(clava_dcg_global[98] != 0) {
      fprintf(log_file_364, "	create_outfile -> name_too_long [label=\"%d\"];\n", clava_dcg_global[98]);
   }
   if(clava_dcg_global[99] != 0) {
      fprintf(log_file_364, "	create_outfile -> fprintf [label=\"%d\"];\n", clava_dcg_global[99]);
   }
   if(clava_dcg_global[100] != 0) {
      fprintf(log_file_364, "	create_outfile -> shorten_name [label=\"%d\"];\n", clava_dcg_global[100]);
   }
   if(clava_dcg_global[101] != 0) {
      fprintf(log_file_364, "	do_stat -> __errno_location [label=\"%d\"];\n", clava_dcg_global[101]);
   }
   if(clava_dcg_global[102] != 0) {
      fprintf(log_file_364, "	do_stat -> lstat [label=\"%d\"];\n", clava_dcg_global[102]);
   }
   if(clava_dcg_global[103] != 0) {
      fprintf(log_file_364, "	do_stat -> stat [label=\"%d\"];\n", clava_dcg_global[103]);
   }
   if(clava_dcg_global[104] != 0) {
      fprintf(log_file_364, "	get_suffix -> strcmp [label=\"%d\"];\n", clava_dcg_global[104]);
   }
   if(clava_dcg_global[105] != 0) {
      fprintf(log_file_364, "	get_suffix -> strlen [label=\"%d\"];\n", clava_dcg_global[105]);
   }
   if(clava_dcg_global[106] != 0) {
      fprintf(log_file_364, "	get_suffix -> strcpy [label=\"%d\"];\n", clava_dcg_global[106]);
   }
   if(clava_dcg_global[107] != 0) {
      fprintf(log_file_364, "	get_suffix -> strlwr [label=\"%d\"];\n", clava_dcg_global[107]);
   }
   if(clava_dcg_global[108] != 0) {
      fprintf(log_file_364, "	get_istat -> strlen [label=\"%d\"];\n", clava_dcg_global[108]);
   }
   if(clava_dcg_global[109] != 0) {
      fprintf(log_file_364, "	get_istat -> strcpy [label=\"%d\"];\n", clava_dcg_global[109]);
   }
   if(clava_dcg_global[110] != 0) {
      fprintf(log_file_364, "	get_istat -> do_stat [label=\"%d\"];\n", clava_dcg_global[110]);
   }
   if(clava_dcg_global[111] != 0) {
      fprintf(log_file_364, "	get_istat -> __errno_location [label=\"%d\"];\n", clava_dcg_global[111]);
   }
   if(clava_dcg_global[112] != 0) {
      fprintf(log_file_364, "	get_istat -> progerror [label=\"%d\"];\n", clava_dcg_global[112]);
   }
   if(clava_dcg_global[113] != 0) {
      fprintf(log_file_364, "	get_istat -> get_suffix [label=\"%d\"];\n", clava_dcg_global[113]);
   }
   if(clava_dcg_global[114] != 0) {
      fprintf(log_file_364, "	get_istat -> strcmp [label=\"%d\"];\n", clava_dcg_global[114]);
   }
   if(clava_dcg_global[115] != 0) {
      fprintf(log_file_364, "	get_istat -> strcat [label=\"%d\"];\n", clava_dcg_global[115]);
   }
   if(clava_dcg_global[116] != 0) {
      fprintf(log_file_364, "	get_istat -> fprintf [label=\"%d\"];\n", clava_dcg_global[116]);
   }
   if(clava_dcg_global[117] != 0) {
      fprintf(log_file_364, "	make_ofname -> strcpy [label=\"%d\"];\n", clava_dcg_global[117]);
   }
   if(clava_dcg_global[118] != 0) {
      fprintf(log_file_364, "	make_ofname -> get_suffix [label=\"%d\"];\n", clava_dcg_global[118]);
   }
   if(clava_dcg_global[119] != 0) {
      fprintf(log_file_364, "	make_ofname -> fprintf [label=\"%d\"];\n", clava_dcg_global[119]);
   }
   if(clava_dcg_global[120] != 0) {
      fprintf(log_file_364, "	make_ofname -> strlwr [label=\"%d\"];\n", clava_dcg_global[120]);
   }
   if(clava_dcg_global[121] != 0) {
      fprintf(log_file_364, "	make_ofname -> strcmp [label=\"%d\"];\n", clava_dcg_global[121]);
   }
   if(clava_dcg_global[122] != 0) {
      fprintf(log_file_364, "	make_ofname -> strlen [label=\"%d\"];\n", clava_dcg_global[122]);
   }
   if(clava_dcg_global[123] != 0) {
      fprintf(log_file_364, "	make_ofname -> strcat [label=\"%d\"];\n", clava_dcg_global[123]);
   }
   if(clava_dcg_global[124] != 0) {
      fprintf(log_file_364, "	get_method -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[124]);
   }
   if(clava_dcg_global[125] != 0) {
      fprintf(log_file_364, "	get_method -> memcmp [label=\"%d\"];\n", clava_dcg_global[125]);
   }
   if(clava_dcg_global[126] != 0) {
      fprintf(log_file_364, "	get_method -> fprintf [label=\"%d\"];\n", clava_dcg_global[126]);
   }
   if(clava_dcg_global[127] != 0) {
      fprintf(log_file_364, "	get_method -> base_name [label=\"%d\"];\n", clava_dcg_global[127]);
   }
   if(clava_dcg_global[128] != 0) {
      fprintf(log_file_364, "	get_method -> error [label=\"%d\"];\n", clava_dcg_global[128]);
   }
   if(clava_dcg_global[129] != 0) {
      fprintf(log_file_364, "	get_method -> strcpy [label=\"%d\"];\n", clava_dcg_global[129]);
   }
   if(clava_dcg_global[130] != 0) {
      fprintf(log_file_364, "	get_method -> check_zipfile [label=\"%d\"];\n", clava_dcg_global[130]);
   }
   if(clava_dcg_global[131] != 0) {
      fprintf(log_file_364, "	do_list -> printf [label=\"%d\"];\n", clava_dcg_global[131]);
   }
   if(clava_dcg_global[132] != 0) {
      fprintf(log_file_364, "	do_list -> fprint_off [label=\"%d\"];\n", clava_dcg_global[132]);
   }
   if(clava_dcg_global[133] != 0) {
      fprintf(log_file_364, "	do_list -> display_ratio [label=\"%d\"];\n", clava_dcg_global[133]);
   }
   if(clava_dcg_global[134] != 0) {
      fprintf(log_file_364, "	do_list -> lseek [label=\"%d\"];\n", clava_dcg_global[134]);
   }
   if(clava_dcg_global[135] != 0) {
      fprintf(log_file_364, "	do_list -> read [label=\"%d\"];\n", clava_dcg_global[135]);
   }
   if(clava_dcg_global[136] != 0) {
      fprintf(log_file_364, "	do_list -> read_error [label=\"%d\"];\n", clava_dcg_global[136]);
   }
   if(clava_dcg_global[137] != 0) {
      fprintf(log_file_364, "	do_list -> ctime [label=\"%d\"];\n", clava_dcg_global[137]);
   }
   if(clava_dcg_global[138] != 0) {
      fprintf(log_file_364, "	name_too_long -> strlen [label=\"%d\"];\n", clava_dcg_global[138]);
   }
   if(clava_dcg_global[139] != 0) {
      fprintf(log_file_364, "	name_too_long -> lstat [label=\"%d\"];\n", clava_dcg_global[139]);
   }
   if(clava_dcg_global[140] != 0) {
      fprintf(log_file_364, "	name_too_long -> same_file [label=\"%d\"];\n", clava_dcg_global[140]);
   }
   if(clava_dcg_global[141] != 0) {
      fprintf(log_file_364, "	shorten_name -> strlen [label=\"%d\"];\n", clava_dcg_global[141]);
   }
   if(clava_dcg_global[142] != 0) {
      fprintf(log_file_364, "	shorten_name -> error [label=\"%d\"];\n", clava_dcg_global[142]);
   }
   if(clava_dcg_global[143] != 0) {
      fprintf(log_file_364, "	shorten_name -> get_suffix [label=\"%d\"];\n", clava_dcg_global[143]);
   }
   if(clava_dcg_global[144] != 0) {
      fprintf(log_file_364, "	shorten_name -> strcmp [label=\"%d\"];\n", clava_dcg_global[144]);
   }
   if(clava_dcg_global[145] != 0) {
      fprintf(log_file_364, "	shorten_name -> strcpy [label=\"%d\"];\n", clava_dcg_global[145]);
   }
   if(clava_dcg_global[146] != 0) {
      fprintf(log_file_364, "	shorten_name -> strrchr [label=\"%d\"];\n", clava_dcg_global[146]);
   }
   if(clava_dcg_global[147] != 0) {
      fprintf(log_file_364, "	shorten_name -> strcspn [label=\"%d\"];\n", clava_dcg_global[147]);
   }
   if(clava_dcg_global[148] != 0) {
      fprintf(log_file_364, "	check_ofname -> __errno_location [label=\"%d\"];\n", clava_dcg_global[148]);
   }
   if(clava_dcg_global[149] != 0) {
      fprintf(log_file_364, "	check_ofname -> lstat [label=\"%d\"];\n", clava_dcg_global[149]);
   }
   if(clava_dcg_global[150] != 0) {
      fprintf(log_file_364, "	check_ofname -> shorten_name [label=\"%d\"];\n", clava_dcg_global[150]);
   }
   if(clava_dcg_global[151] != 0) {
      fprintf(log_file_364, "	check_ofname -> name_too_long [label=\"%d\"];\n", clava_dcg_global[151]);
   }
   if(clava_dcg_global[152] != 0) {
      fprintf(log_file_364, "	check_ofname -> same_file [label=\"%d\"];\n", clava_dcg_global[152]);
   }
   if(clava_dcg_global[153] != 0) {
      fprintf(log_file_364, "	check_ofname -> strcmp [label=\"%d\"];\n", clava_dcg_global[153]);
   }
   if(clava_dcg_global[154] != 0) {
      fprintf(log_file_364, "	check_ofname -> fprintf [label=\"%d\"];\n", clava_dcg_global[154]);
   }
   if(clava_dcg_global[155] != 0) {
      fprintf(log_file_364, "	check_ofname -> isatty [label=\"%d\"];\n", clava_dcg_global[155]);
   }
   if(clava_dcg_global[156] != 0) {
      fprintf(log_file_364, "	check_ofname -> fileno [label=\"%d\"];\n", clava_dcg_global[156]);
   }
   if(clava_dcg_global[157] != 0) {
      fprintf(log_file_364, "	check_ofname -> fflush [label=\"%d\"];\n", clava_dcg_global[157]);
   }
   if(clava_dcg_global[158] != 0) {
      fprintf(log_file_364, "	check_ofname -> yesno [label=\"%d\"];\n", clava_dcg_global[158]);
   }
   if(clava_dcg_global[159] != 0) {
      fprintf(log_file_364, "	check_ofname -> xunlink [label=\"%d\"];\n", clava_dcg_global[159]);
   }
   if(clava_dcg_global[160] != 0) {
      fprintf(log_file_364, "	check_ofname -> progerror [label=\"%d\"];\n", clava_dcg_global[160]);
   }
   if(clava_dcg_global[161] != 0) {
      fprintf(log_file_364, "	reset_times -> utime [label=\"%d\"];\n", clava_dcg_global[161]);
   }
   if(clava_dcg_global[162] != 0) {
      fprintf(log_file_364, "	reset_times -> __errno_location [label=\"%d\"];\n", clava_dcg_global[162]);
   }
   if(clava_dcg_global[163] != 0) {
      fprintf(log_file_364, "	reset_times -> fprintf [label=\"%d\"];\n", clava_dcg_global[163]);
   }
   if(clava_dcg_global[164] != 0) {
      fprintf(log_file_364, "	reset_times -> perror [label=\"%d\"];\n", clava_dcg_global[164]);
   }
   if(clava_dcg_global[165] != 0) {
      fprintf(log_file_364, "	copy_stat -> fprintf [label=\"%d\"];\n", clava_dcg_global[165]);
   }
   if(clava_dcg_global[166] != 0) {
      fprintf(log_file_364, "	copy_stat -> reset_times [label=\"%d\"];\n", clava_dcg_global[166]);
   }
   if(clava_dcg_global[167] != 0) {
      fprintf(log_file_364, "	copy_stat -> fchmod [label=\"%d\"];\n", clava_dcg_global[167]);
   }
   if(clava_dcg_global[168] != 0) {
      fprintf(log_file_364, "	copy_stat -> __errno_location [label=\"%d\"];\n", clava_dcg_global[168]);
   }
   if(clava_dcg_global[169] != 0) {
      fprintf(log_file_364, "	copy_stat -> perror [label=\"%d\"];\n", clava_dcg_global[169]);
   }
   if(clava_dcg_global[170] != 0) {
      fprintf(log_file_364, "	copy_stat -> fchown [label=\"%d\"];\n", clava_dcg_global[170]);
   }
   if(clava_dcg_global[171] != 0) {
      fprintf(log_file_364, "	copy_stat -> xunlink [label=\"%d\"];\n", clava_dcg_global[171]);
   }
   if(clava_dcg_global[172] != 0) {
      fprintf(log_file_364, "	treat_dir -> opendir [label=\"%d\"];\n", clava_dcg_global[172]);
   }
   if(clava_dcg_global[173] != 0) {
      fprintf(log_file_364, "	treat_dir -> progerror [label=\"%d\"];\n", clava_dcg_global[173]);
   }
   if(clava_dcg_global[174] != 0) {
      fprintf(log_file_364, "	treat_dir -> __errno_location [label=\"%d\"];\n", clava_dcg_global[174]);
   }
   if(clava_dcg_global[175] != 0) {
      fprintf(log_file_364, "	treat_dir -> readdir [label=\"%d\"];\n", clava_dcg_global[175]);
   }
   if(clava_dcg_global[176] != 0) {
      fprintf(log_file_364, "	treat_dir -> strcmp [label=\"%d\"];\n", clava_dcg_global[176]);
   }
   if(clava_dcg_global[177] != 0) {
      fprintf(log_file_364, "	treat_dir -> strlen [label=\"%d\"];\n", clava_dcg_global[177]);
   }
   if(clava_dcg_global[178] != 0) {
      fprintf(log_file_364, "	treat_dir -> strcpy [label=\"%d\"];\n", clava_dcg_global[178]);
   }
   if(clava_dcg_global[179] != 0) {
      fprintf(log_file_364, "	treat_dir -> treat_file [label=\"%d\"];\n", clava_dcg_global[179]);
   }
   if(clava_dcg_global[180] != 0) {
      fprintf(log_file_364, "	treat_dir -> fprintf [label=\"%d\"];\n", clava_dcg_global[180]);
   }
   if(clava_dcg_global[181] != 0) {
      fprintf(log_file_364, "	treat_dir -> closedir [label=\"%d\"];\n", clava_dcg_global[181]);
   }
   if(clava_dcg_global[182] != 0) {
      fprintf(log_file_364, "	do_exit -> exit [label=\"%d\"];\n", clava_dcg_global[182]);
   }
   if(clava_dcg_global[183] != 0) {
      fprintf(log_file_364, "	do_exit -> free [label=\"%d\"];\n", clava_dcg_global[183]);
   }
   if(clava_dcg_global[184] != 0) {
      fprintf(log_file_364, "	do_remove -> close [label=\"%d\"];\n", clava_dcg_global[184]);
   }
   if(clava_dcg_global[185] != 0) {
      fprintf(log_file_364, "	do_remove -> xunlink [label=\"%d\"];\n", clava_dcg_global[185]);
   }
   if(clava_dcg_global[186] != 0) {
      fprintf(log_file_364, "	abort_gzip -> do_remove [label=\"%d\"];\n", clava_dcg_global[186]);
   }
   if(clava_dcg_global[187] != 0) {
      fprintf(log_file_364, "	abort_gzip -> do_exit [label=\"%d\"];\n", clava_dcg_global[187]);
   }
   if(clava_dcg_global[188] != 0) {
      fprintf(log_file_364, "	abort_gzip_signal -> do_remove [label=\"%d\"];\n", clava_dcg_global[188]);
   }
   if(clava_dcg_global[189] != 0) {
      fprintf(log_file_364, "	abort_gzip_signal -> _exit [label=\"%d\"];\n", clava_dcg_global[189]);
   }
   if(clava_dcg_global[190] != 0) {
      fprintf(log_file_364, "	huft_build -> memset [label=\"%d\"];\n", clava_dcg_global[190]);
   }
   if(clava_dcg_global[191] != 0) {
      fprintf(log_file_364, "	huft_build -> malloc [label=\"%d\"];\n", clava_dcg_global[191]);
   }
   if(clava_dcg_global[192] != 0) {
      fprintf(log_file_364, "	huft_build -> huft_free [label=\"%d\"];\n", clava_dcg_global[192]);
   }
   if(clava_dcg_global[193] != 0) {
      fprintf(log_file_364, "	huft_free -> free [label=\"%d\"];\n", clava_dcg_global[193]);
   }
   if(clava_dcg_global[194] != 0) {
      fprintf(log_file_364, "	inflate_codes -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[194]);
   }
   if(clava_dcg_global[195] != 0) {
      fprintf(log_file_364, "	inflate_codes -> flush_window [label=\"%d\"];\n", clava_dcg_global[195]);
   }
   if(clava_dcg_global[196] != 0) {
      fprintf(log_file_364, "	inflate_codes -> memcpy [label=\"%d\"];\n", clava_dcg_global[196]);
   }
   if(clava_dcg_global[197] != 0) {
      fprintf(log_file_364, "	inflate_stored -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[197]);
   }
   if(clava_dcg_global[198] != 0) {
      fprintf(log_file_364, "	inflate_stored -> flush_window [label=\"%d\"];\n", clava_dcg_global[198]);
   }
   if(clava_dcg_global[199] != 0) {
      fprintf(log_file_364, "	inflate_fixed -> huft_build [label=\"%d\"];\n", clava_dcg_global[199]);
   }
   if(clava_dcg_global[200] != 0) {
      fprintf(log_file_364, "	inflate_fixed -> huft_free [label=\"%d\"];\n", clava_dcg_global[200]);
   }
   if(clava_dcg_global[201] != 0) {
      fprintf(log_file_364, "	inflate_fixed -> inflate_codes [label=\"%d\"];\n", clava_dcg_global[201]);
   }
   if(clava_dcg_global[202] != 0) {
      fprintf(log_file_364, "	inflate_dynamic -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[202]);
   }
   if(clava_dcg_global[203] != 0) {
      fprintf(log_file_364, "	inflate_dynamic -> huft_build [label=\"%d\"];\n", clava_dcg_global[203]);
   }
   if(clava_dcg_global[204] != 0) {
      fprintf(log_file_364, "	inflate_dynamic -> huft_free [label=\"%d\"];\n", clava_dcg_global[204]);
   }
   if(clava_dcg_global[205] != 0) {
      fprintf(log_file_364, "	inflate_dynamic -> fprintf [label=\"%d\"];\n", clava_dcg_global[205]);
   }
   if(clava_dcg_global[206] != 0) {
      fprintf(log_file_364, "	inflate_dynamic -> inflate_codes [label=\"%d\"];\n", clava_dcg_global[206]);
   }
   if(clava_dcg_global[207] != 0) {
      fprintf(log_file_364, "	inflate_block -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[207]);
   }
   if(clava_dcg_global[208] != 0) {
      fprintf(log_file_364, "	inflate_block -> inflate_dynamic [label=\"%d\"];\n", clava_dcg_global[208]);
   }
   if(clava_dcg_global[209] != 0) {
      fprintf(log_file_364, "	inflate_block -> inflate_stored [label=\"%d\"];\n", clava_dcg_global[209]);
   }
   if(clava_dcg_global[210] != 0) {
      fprintf(log_file_364, "	inflate_block -> inflate_fixed [label=\"%d\"];\n", clava_dcg_global[210]);
   }
   if(clava_dcg_global[211] != 0) {
      fprintf(log_file_364, "	inflate -> inflate_block [label=\"%d\"];\n", clava_dcg_global[211]);
   }
   if(clava_dcg_global[212] != 0) {
      fprintf(log_file_364, "	inflate -> flush_window [label=\"%d\"];\n", clava_dcg_global[212]);
   }
   if(clava_dcg_global[213] != 0) {
      fprintf(log_file_364, "	lzw -> fprintf [label=\"%d\"];\n", clava_dcg_global[213]);
   }
   if(clava_dcg_global[214] != 0) {
      fprintf(log_file_364, "	ct_init -> gen_codes [label=\"%d\"];\n", clava_dcg_global[214]);
   }
   if(clava_dcg_global[215] != 0) {
      fprintf(log_file_364, "	ct_init -> bi_reverse [label=\"%d\"];\n", clava_dcg_global[215]);
   }
   if(clava_dcg_global[216] != 0) {
      fprintf(log_file_364, "	ct_init -> init_block [label=\"%d\"];\n", clava_dcg_global[216]);
   }
   if(clava_dcg_global[217] != 0) {
      fprintf(log_file_364, "	gen_codes -> bi_reverse [label=\"%d\"];\n", clava_dcg_global[217]);
   }
   if(clava_dcg_global[218] != 0) {
      fprintf(log_file_364, "	build_tree_1 -> pqdownheap [label=\"%d\"];\n", clava_dcg_global[218]);
   }
   if(clava_dcg_global[219] != 0) {
      fprintf(log_file_364, "	build_tree_1 -> gen_bitlen [label=\"%d\"];\n", clava_dcg_global[219]);
   }
   if(clava_dcg_global[220] != 0) {
      fprintf(log_file_364, "	build_tree_1 -> gen_codes [label=\"%d\"];\n", clava_dcg_global[220]);
   }
   if(clava_dcg_global[221] != 0) {
      fprintf(log_file_364, "	send_tree -> send_bits [label=\"%d\"];\n", clava_dcg_global[221]);
   }
   if(clava_dcg_global[222] != 0) {
      fprintf(log_file_364, "	build_bl_tree -> scan_tree [label=\"%d\"];\n", clava_dcg_global[222]);
   }
   if(clava_dcg_global[223] != 0) {
      fprintf(log_file_364, "	build_bl_tree -> build_tree_1 [label=\"%d\"];\n", clava_dcg_global[223]);
   }
   if(clava_dcg_global[224] != 0) {
      fprintf(log_file_364, "	send_all_trees -> send_bits [label=\"%d\"];\n", clava_dcg_global[224]);
   }
   if(clava_dcg_global[225] != 0) {
      fprintf(log_file_364, "	send_all_trees -> send_tree [label=\"%d\"];\n", clava_dcg_global[225]);
   }
   if(clava_dcg_global[226] != 0) {
      fprintf(log_file_364, "	flush_block -> set_file_type [label=\"%d\"];\n", clava_dcg_global[226]);
   }
   if(clava_dcg_global[227] != 0) {
      fprintf(log_file_364, "	flush_block -> build_tree_1 [label=\"%d\"];\n", clava_dcg_global[227]);
   }
   if(clava_dcg_global[228] != 0) {
      fprintf(log_file_364, "	flush_block -> build_bl_tree [label=\"%d\"];\n", clava_dcg_global[228]);
   }
   if(clava_dcg_global[229] != 0) {
      fprintf(log_file_364, "	flush_block -> error [label=\"%d\"];\n", clava_dcg_global[229]);
   }
   if(clava_dcg_global[230] != 0) {
      fprintf(log_file_364, "	flush_block -> copy_block [label=\"%d\"];\n", clava_dcg_global[230]);
   }
   if(clava_dcg_global[231] != 0) {
      fprintf(log_file_364, "	flush_block -> send_bits [label=\"%d\"];\n", clava_dcg_global[231]);
   }
   if(clava_dcg_global[232] != 0) {
      fprintf(log_file_364, "	flush_block -> compress_block [label=\"%d\"];\n", clava_dcg_global[232]);
   }
   if(clava_dcg_global[233] != 0) {
      fprintf(log_file_364, "	flush_block -> send_all_trees [label=\"%d\"];\n", clava_dcg_global[233]);
   }
   if(clava_dcg_global[234] != 0) {
      fprintf(log_file_364, "	flush_block -> init_block [label=\"%d\"];\n", clava_dcg_global[234]);
   }
   if(clava_dcg_global[235] != 0) {
      fprintf(log_file_364, "	flush_block -> bi_windup [label=\"%d\"];\n", clava_dcg_global[235]);
   }
   if(clava_dcg_global[236] != 0) {
      fprintf(log_file_364, "	compress_block -> send_bits [label=\"%d\"];\n", clava_dcg_global[236]);
   }
   if(clava_dcg_global[237] != 0) {
      fprintf(log_file_364, "	set_file_type -> warning [label=\"%d\"];\n", clava_dcg_global[237]);
   }
   if(clava_dcg_global[238] != 0) {
      fprintf(log_file_364, "	fillbuf -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[238]);
   }
   if(clava_dcg_global[239] != 0) {
      fprintf(log_file_364, "	getbits -> fillbuf [label=\"%d\"];\n", clava_dcg_global[239]);
   }
   if(clava_dcg_global[240] != 0) {
      fprintf(log_file_364, "	init_getbits -> fillbuf [label=\"%d\"];\n", clava_dcg_global[240]);
   }
   if(clava_dcg_global[241] != 0) {
      fprintf(log_file_364, "	make_table -> error [label=\"%d\"];\n", clava_dcg_global[241]);
   }
   if(clava_dcg_global[242] != 0) {
      fprintf(log_file_364, "	read_pt_len -> getbits [label=\"%d\"];\n", clava_dcg_global[242]);
   }
   if(clava_dcg_global[243] != 0) {
      fprintf(log_file_364, "	read_pt_len -> fillbuf [label=\"%d\"];\n", clava_dcg_global[243]);
   }
   if(clava_dcg_global[244] != 0) {
      fprintf(log_file_364, "	read_pt_len -> make_table [label=\"%d\"];\n", clava_dcg_global[244]);
   }
   if(clava_dcg_global[245] != 0) {
      fprintf(log_file_364, "	read_c_len -> getbits [label=\"%d\"];\n", clava_dcg_global[245]);
   }
   if(clava_dcg_global[246] != 0) {
      fprintf(log_file_364, "	read_c_len -> fillbuf [label=\"%d\"];\n", clava_dcg_global[246]);
   }
   if(clava_dcg_global[247] != 0) {
      fprintf(log_file_364, "	read_c_len -> make_table [label=\"%d\"];\n", clava_dcg_global[247]);
   }
   if(clava_dcg_global[248] != 0) {
      fprintf(log_file_364, "	decode_c -> getbits [label=\"%d\"];\n", clava_dcg_global[248]);
   }
   if(clava_dcg_global[249] != 0) {
      fprintf(log_file_364, "	decode_c -> read_pt_len [label=\"%d\"];\n", clava_dcg_global[249]);
   }
   if(clava_dcg_global[250] != 0) {
      fprintf(log_file_364, "	decode_c -> read_c_len [label=\"%d\"];\n", clava_dcg_global[250]);
   }
   if(clava_dcg_global[251] != 0) {
      fprintf(log_file_364, "	decode_c -> fillbuf [label=\"%d\"];\n", clava_dcg_global[251]);
   }
   if(clava_dcg_global[252] != 0) {
      fprintf(log_file_364, "	decode_p -> fillbuf [label=\"%d\"];\n", clava_dcg_global[252]);
   }
   if(clava_dcg_global[253] != 0) {
      fprintf(log_file_364, "	decode_p -> getbits [label=\"%d\"];\n", clava_dcg_global[253]);
   }
   if(clava_dcg_global[254] != 0) {
      fprintf(log_file_364, "	huf_decode_start -> init_getbits [label=\"%d\"];\n", clava_dcg_global[254]);
   }
   if(clava_dcg_global[255] != 0) {
      fprintf(log_file_364, "	decode_start -> huf_decode_start [label=\"%d\"];\n", clava_dcg_global[255]);
   }
   if(clava_dcg_global[256] != 0) {
      fprintf(log_file_364, "	decode -> decode_c [label=\"%d\"];\n", clava_dcg_global[256]);
   }
   if(clava_dcg_global[257] != 0) {
      fprintf(log_file_364, "	decode -> decode_p [label=\"%d\"];\n", clava_dcg_global[257]);
   }
   if(clava_dcg_global[258] != 0) {
      fprintf(log_file_364, "	unlzh -> decode_start [label=\"%d\"];\n", clava_dcg_global[258]);
   }
   if(clava_dcg_global[259] != 0) {
      fprintf(log_file_364, "	unlzh -> decode [label=\"%d\"];\n", clava_dcg_global[259]);
   }
   if(clava_dcg_global[260] != 0) {
      fprintf(log_file_364, "	unlzh -> write_buf [label=\"%d\"];\n", clava_dcg_global[260]);
   }
   if(clava_dcg_global[261] != 0) {
      fprintf(log_file_364, "	unlzw -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[261]);
   }
   if(clava_dcg_global[262] != 0) {
      fprintf(log_file_364, "	unlzw -> fprintf [label=\"%d\"];\n", clava_dcg_global[262]);
   }
   if(clava_dcg_global[263] != 0) {
      fprintf(log_file_364, "	unlzw -> memset [label=\"%d\"];\n", clava_dcg_global[263]);
   }
   if(clava_dcg_global[264] != 0) {
      fprintf(log_file_364, "	unlzw -> read [label=\"%d\"];\n", clava_dcg_global[264]);
   }
   if(clava_dcg_global[265] != 0) {
      fprintf(log_file_364, "	unlzw -> read_error [label=\"%d\"];\n", clava_dcg_global[265]);
   }
   if(clava_dcg_global[266] != 0) {
      fprintf(log_file_364, "	unlzw -> error [label=\"%d\"];\n", clava_dcg_global[266]);
   }
   if(clava_dcg_global[267] != 0) {
      fprintf(log_file_364, "	unlzw -> write_buf [label=\"%d\"];\n", clava_dcg_global[267]);
   }
   if(clava_dcg_global[268] != 0) {
      fprintf(log_file_364, "	unlzw -> memcpy [label=\"%d\"];\n", clava_dcg_global[268]);
   }
   if(clava_dcg_global[269] != 0) {
      fprintf(log_file_364, "	read_tree -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[269]);
   }
   if(clava_dcg_global[270] != 0) {
      fprintf(log_file_364, "	read_tree -> error [label=\"%d\"];\n", clava_dcg_global[270]);
   }
   if(clava_dcg_global[271] != 0) {
      fprintf(log_file_364, "	unpack -> read_tree [label=\"%d\"];\n", clava_dcg_global[271]);
   }
   if(clava_dcg_global[272] != 0) {
      fprintf(log_file_364, "	unpack -> build_tree [label=\"%d\"];\n", clava_dcg_global[272]);
   }
   if(clava_dcg_global[273] != 0) {
      fprintf(log_file_364, "	unpack -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[273]);
   }
   if(clava_dcg_global[274] != 0) {
      fprintf(log_file_364, "	unpack -> flush_window [label=\"%d\"];\n", clava_dcg_global[274]);
   }
   if(clava_dcg_global[275] != 0) {
      fprintf(log_file_364, "	unpack -> error [label=\"%d\"];\n", clava_dcg_global[275]);
   }
   if(clava_dcg_global[276] != 0) {
      fprintf(log_file_364, "	check_zipfile -> fprintf [label=\"%d\"];\n", clava_dcg_global[276]);
   }
   if(clava_dcg_global[277] != 0) {
      fprintf(log_file_364, "	unzip -> updcrc [label=\"%d\"];\n", clava_dcg_global[277]);
   }
   if(clava_dcg_global[278] != 0) {
      fprintf(log_file_364, "	unzip -> inflate [label=\"%d\"];\n", clava_dcg_global[278]);
   }
   if(clava_dcg_global[279] != 0) {
      fprintf(log_file_364, "	unzip -> error [label=\"%d\"];\n", clava_dcg_global[279]);
   }
   if(clava_dcg_global[280] != 0) {
      fprintf(log_file_364, "	unzip -> fprintf [label=\"%d\"];\n", clava_dcg_global[280]);
   }
   if(clava_dcg_global[281] != 0) {
      fprintf(log_file_364, "	unzip -> fill_inbuf [label=\"%d\"];\n", clava_dcg_global[281]);
   }
   if(clava_dcg_global[282] != 0) {
      fprintf(log_file_364, "	unzip -> flush_window [label=\"%d\"];\n", clava_dcg_global[282]);
   }
   if(clava_dcg_global[283] != 0) {
      fprintf(log_file_364, "	unzip -> abort_gzip [label=\"%d\"];\n", clava_dcg_global[283]);
   }
   if(clava_dcg_global[284] != 0) {
      fprintf(log_file_364, "	copy -> __errno_location [label=\"%d\"];\n", clava_dcg_global[284]);
   }
   if(clava_dcg_global[285] != 0) {
      fprintf(log_file_364, "	copy -> write_buf [label=\"%d\"];\n", clava_dcg_global[285]);
   }
   if(clava_dcg_global[286] != 0) {
      fprintf(log_file_364, "	copy -> read [label=\"%d\"];\n", clava_dcg_global[286]);
   }
   if(clava_dcg_global[287] != 0) {
      fprintf(log_file_364, "	copy -> read_error [label=\"%d\"];\n", clava_dcg_global[287]);
   }
   if(clava_dcg_global[288] != 0) {
      fprintf(log_file_364, "	fill_inbuf -> read [label=\"%d\"];\n", clava_dcg_global[288]);
   }
   if(clava_dcg_global[289] != 0) {
      fprintf(log_file_364, "	fill_inbuf -> read_error [label=\"%d\"];\n", clava_dcg_global[289]);
   }
   if(clava_dcg_global[290] != 0) {
      fprintf(log_file_364, "	fill_inbuf -> flush_window [label=\"%d\"];\n", clava_dcg_global[290]);
   }
   if(clava_dcg_global[291] != 0) {
      fprintf(log_file_364, "	fill_inbuf -> __errno_location [label=\"%d\"];\n", clava_dcg_global[291]);
   }
   if(clava_dcg_global[292] != 0) {
      fprintf(log_file_364, "	flush_outbuf -> write_buf [label=\"%d\"];\n", clava_dcg_global[292]);
   }
   if(clava_dcg_global[293] != 0) {
      fprintf(log_file_364, "	flush_window -> updcrc [label=\"%d\"];\n", clava_dcg_global[293]);
   }
   if(clava_dcg_global[294] != 0) {
      fprintf(log_file_364, "	flush_window -> write_buf [label=\"%d\"];\n", clava_dcg_global[294]);
   }
   if(clava_dcg_global[295] != 0) {
      fprintf(log_file_364, "	write_buf -> write [label=\"%d\"];\n", clava_dcg_global[295]);
   }
   if(clava_dcg_global[296] != 0) {
      fprintf(log_file_364, "	write_buf -> write_error [label=\"%d\"];\n", clava_dcg_global[296]);
   }
   if(clava_dcg_global[297] != 0) {
      fprintf(log_file_364, "	strlwr -> __ctype_b_loc [label=\"%d\"];\n", clava_dcg_global[297]);
   }
   if(clava_dcg_global[298] != 0) {
      fprintf(log_file_364, "	strlwr -> tolower [label=\"%d\"];\n", clava_dcg_global[298]);
   }
   if(clava_dcg_global[299] != 0) {
      fprintf(log_file_364, "	base_name -> strrchr [label=\"%d\"];\n", clava_dcg_global[299]);
   }
   if(clava_dcg_global[300] != 0) {
      fprintf(log_file_364, "	base_name -> strlwr [label=\"%d\"];\n", clava_dcg_global[300]);
   }
   if(clava_dcg_global[301] != 0) {
      fprintf(log_file_364, "	xunlink -> unlink [label=\"%d\"];\n", clava_dcg_global[301]);
   }
   if(clava_dcg_global[302] != 0) {
      fprintf(log_file_364, "	make_simple_name -> strrchr [label=\"%d\"];\n", clava_dcg_global[302]);
   }
   if(clava_dcg_global[303] != 0) {
      fprintf(log_file_364, "	add_envopt -> getenv [label=\"%d\"];\n", clava_dcg_global[303]);
   }
   if(clava_dcg_global[304] != 0) {
      fprintf(log_file_364, "	add_envopt -> xmalloc [label=\"%d\"];\n", clava_dcg_global[304]);
   }
   if(clava_dcg_global[305] != 0) {
      fprintf(log_file_364, "	add_envopt -> strlen [label=\"%d\"];\n", clava_dcg_global[305]);
   }
   if(clava_dcg_global[306] != 0) {
      fprintf(log_file_364, "	add_envopt -> strcpy [label=\"%d\"];\n", clava_dcg_global[306]);
   }
   if(clava_dcg_global[307] != 0) {
      fprintf(log_file_364, "	add_envopt -> strspn [label=\"%d\"];\n", clava_dcg_global[307]);
   }
   if(clava_dcg_global[308] != 0) {
      fprintf(log_file_364, "	add_envopt -> strcspn [label=\"%d\"];\n", clava_dcg_global[308]);
   }
   if(clava_dcg_global[309] != 0) {
      fprintf(log_file_364, "	add_envopt -> free [label=\"%d\"];\n", clava_dcg_global[309]);
   }
   if(clava_dcg_global[310] != 0) {
      fprintf(log_file_364, "	add_envopt -> calloc [label=\"%d\"];\n", clava_dcg_global[310]);
   }
   if(clava_dcg_global[311] != 0) {
      fprintf(log_file_364, "	add_envopt -> error [label=\"%d\"];\n", clava_dcg_global[311]);
   }
   if(clava_dcg_global[312] != 0) {
      fprintf(log_file_364, "	error -> fprintf [label=\"%d\"];\n", clava_dcg_global[312]);
   }
   if(clava_dcg_global[313] != 0) {
      fprintf(log_file_364, "	error -> abort_gzip [label=\"%d\"];\n", clava_dcg_global[313]);
   }
   if(clava_dcg_global[314] != 0) {
      fprintf(log_file_364, "	warning -> fprintf [label=\"%d\"];\n", clava_dcg_global[314]);
   }
   if(clava_dcg_global[315] != 0) {
      fprintf(log_file_364, "	read_error -> __errno_location [label=\"%d\"];\n", clava_dcg_global[315]);
   }
   if(clava_dcg_global[316] != 0) {
      fprintf(log_file_364, "	read_error -> fprintf [label=\"%d\"];\n", clava_dcg_global[316]);
   }
   if(clava_dcg_global[317] != 0) {
      fprintf(log_file_364, "	read_error -> perror [label=\"%d\"];\n", clava_dcg_global[317]);
   }
   if(clava_dcg_global[318] != 0) {
      fprintf(log_file_364, "	read_error -> abort_gzip [label=\"%d\"];\n", clava_dcg_global[318]);
   }
   if(clava_dcg_global[319] != 0) {
      fprintf(log_file_364, "	write_error -> __errno_location [label=\"%d\"];\n", clava_dcg_global[319]);
   }
   if(clava_dcg_global[320] != 0) {
      fprintf(log_file_364, "	write_error -> fprintf [label=\"%d\"];\n", clava_dcg_global[320]);
   }
   if(clava_dcg_global[321] != 0) {
      fprintf(log_file_364, "	write_error -> perror [label=\"%d\"];\n", clava_dcg_global[321]);
   }
   if(clava_dcg_global[322] != 0) {
      fprintf(log_file_364, "	write_error -> abort_gzip [label=\"%d\"];\n", clava_dcg_global[322]);
   }
   if(clava_dcg_global[323] != 0) {
      fprintf(log_file_364, "	display_ratio -> fprintf [label=\"%d\"];\n", clava_dcg_global[323]);
   }
   if(clava_dcg_global[324] != 0) {
      fprintf(log_file_364, "	fprint_off -> _IO_putc [label=\"%d\"];\n", clava_dcg_global[324]);
   }
   if(clava_dcg_global[325] != 0) {
      fprintf(log_file_364, "	xmalloc -> malloc [label=\"%d\"];\n", clava_dcg_global[325]);
   }
   if(clava_dcg_global[326] != 0) {
      fprintf(log_file_364, "	xmalloc -> error [label=\"%d\"];\n", clava_dcg_global[326]);
   }
   if(clava_dcg_global[327] != 0) {
      fprintf(log_file_364, "	yesno -> getchar [label=\"%d\"];\n", clava_dcg_global[327]);
   }
   if(clava_dcg_global[328] != 0) {
      fprintf(log_file_364, "	yesno -> __ctype_b_loc [label=\"%d\"];\n", clava_dcg_global[328]);
   }
   if(clava_dcg_global[329] != 0) {
      fprintf(log_file_364, "	yesno -> rpmatch [label=\"%d\"];\n", clava_dcg_global[329]);
   }
   if(clava_dcg_global[330] != 0) {
      fprintf(log_file_364, "	zip -> flush_outbuf [label=\"%d\"];\n", clava_dcg_global[330]);
   }
   if(clava_dcg_global[331] != 0) {
      fprintf(log_file_364, "	zip -> updcrc [label=\"%d\"];\n", clava_dcg_global[331]);
   }
   if(clava_dcg_global[332] != 0) {
      fprintf(log_file_364, "	zip -> bi_init [label=\"%d\"];\n", clava_dcg_global[332]);
   }
   if(clava_dcg_global[333] != 0) {
      fprintf(log_file_364, "	zip -> ct_init [label=\"%d\"];\n", clava_dcg_global[333]);
   }
   if(clava_dcg_global[334] != 0) {
      fprintf(log_file_364, "	zip -> lm_init [label=\"%d\"];\n", clava_dcg_global[334]);
   }
   if(clava_dcg_global[335] != 0) {
      fprintf(log_file_364, "	zip -> base_name [label=\"%d\"];\n", clava_dcg_global[335]);
   }
   if(clava_dcg_global[336] != 0) {
      fprintf(log_file_364, "	zip -> deflate [label=\"%d\"];\n", clava_dcg_global[336]);
   }
   if(clava_dcg_global[337] != 0) {
      fprintf(log_file_364, "	file_read -> read [label=\"%d\"];\n", clava_dcg_global[337]);
   }
   if(clava_dcg_global[338] != 0) {
      fprintf(log_file_364, "	file_read -> read_error [label=\"%d\"];\n", clava_dcg_global[338]);
   }
   if(clava_dcg_global[339] != 0) {
      fprintf(log_file_364, "	file_read -> updcrc [label=\"%d\"];\n", clava_dcg_global[339]);
   }
   if(clava_dcg_global[340] != 0) {
      fprintf(log_file_364, "	getopt_long -> _getopt_internal [label=\"%d\"];\n", clava_dcg_global[340]);
   }
   if(clava_dcg_global[341] != 0) {
      fprintf(log_file_364, "	getopt_long_only -> _getopt_internal [label=\"%d\"];\n", clava_dcg_global[341]);
   }
   fprintf(log_file_364, "}\n");
   fclose(log_file_364);
}

int main(int argc, char **argv) {
   atexit(clava_call_graph);
   int file_count;
   /*number of files to precess*/
   int proglen;
   /*length of progname*/
   int optc;
   /*current option*/
   ;
   /*wild card expansion if necessary*/
   clava_dcg_global[ 39 ]++;
   progname = base_name(argv[0]);
   clava_dcg_global[ 40 ]++;
   proglen = strlen(progname);
   /*Suppress .exe for MSDOS, OS/2 and VMS:*/
   clava_dcg_global[ 41 ]++;
   if(proglen > 4 && (strcmp((progname + proglen - 4), (".exe")) == 0)) {
      progname[proglen - 4] = '\0';
   }
   /*Add options in GZIP environment variable if there is one*/
   clava_dcg_global[ 42 ]++;
   env = add_envopt(&argc, &argv, "GZIP");
   if(env != ((void *) 0)) args = argv;
   clava_dcg_global[ 43 ]++;
   foreground = signal(2, ((__sighandler_t) 1)) != ((__sighandler_t) 1);
   if(foreground) {
      clava_dcg_global[ 43 ]++;
      (void) signal(2, (sig_type) abort_gzip_signal);
   }
   clava_dcg_global[ 43 ]++;
   if(signal(15, ((__sighandler_t) 1)) != ((__sighandler_t) 1)) {
      clava_dcg_global[ 43 ]++;
      (void) signal(15, (sig_type) abort_gzip_signal);
   }
   clava_dcg_global[ 43 ]++;
   if(signal(1, ((__sighandler_t) 1)) != ((__sighandler_t) 1)) {
      clava_dcg_global[ 43 ]++;
      (void) signal(1, (sig_type) abort_gzip_signal);
   }
   /*For compatibility with old compress, use program name as an option.
   * If you compile with -DGNU_STANDARD, this program will behave as
   * gzip even if it is invoked under the name gunzip or zcat.
   *
   * Systems which do not support links can still use -d or -dc.
   * Ignore an .exe extension for MSDOS, OS/2 and VMS.
   */
   clava_dcg_global[ 44 ]++;
   clava_dcg_global[ 44 ]++;
   if(strncmp(progname, "un", 2) == 0 || strncmp(progname, "gun", 3) == 0) {
      decompress = 1;
   }
   else {
      clava_dcg_global[ 41 ]++;
      clava_dcg_global[ 41 ]++;
      if((strcmp((progname + 1), ("cat")) == 0) || (strcmp((progname), ("gzcat")) == 0)) {
         decompress = to_stdout = 1;
      }
   }
   z_suffix = ".gz";
   clava_dcg_global[ 40 ]++;
   z_len = strlen(z_suffix);
   while((optc = getopt_long(argc, argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789", longopts, (int *) 0)) != -1) {
      clava_dcg_global[ 45 ]++;
      switch (optc) {
         case 'a':
         ascii = 1;
         break;
         case 'b':
         clava_dcg_global[ 46 ]++;
         maxbits = atoi(optarg);
         for(; *optarg; optarg++) if(!('0' <= *optarg && *optarg <= '9')) {
            clava_dcg_global[ 47 ]++;
            fprintf(stderr, "%s: -b operand is not an integer\n", progname);
            clava_dcg_global[ 48 ]++;
            usage();
            clava_dcg_global[ 49 ]++;
            do_exit(1);
         }
         break;
         case 'c':
         to_stdout = 1;
         break;
         case 'd':
         decompress = 1;
         break;
         case 'f':
         force++;
         break;
         case 'h':
         case 'H':
         case '?':
         clava_dcg_global[ 50 ]++;
         help();
         clava_dcg_global[ 49 ]++;
         do_exit(0);
         break;
         case 'l':
         list = decompress = to_stdout = 1;
         break;
         case 'L':
         clava_dcg_global[ 51 ]++;
         license();
         clava_dcg_global[ 49 ]++;
         do_exit(0);
         break;
         case 'm':
         /*undocumented, may change later*/
         no_time = 1;
         break;
         case 'M':
         /*undocumented, may change later*/
         no_time = 0;
         break;
         case 'n':
         no_name = no_time = 1;
         break;
         case 'N':
         no_name = no_time = 0;
         break;
         case 'q':
         quiet = 1;
         verbose = 0;
         break;
         case 'r':
         recursive = 1;
         break;
         case 'R':
         rsync = 1;
         break;
         case 'S':
         clava_dcg_global[ 40 ]++;
         z_len = strlen(optarg);
         z_suffix = optarg;
         break;
         case 't':
         test = decompress = to_stdout = 1;
         break;
         case 'v':
         verbose++;
         quiet = 0;
         break;
         case 'V':
         clava_dcg_global[ 52 ]++;
         version();
         clava_dcg_global[ 49 ]++;
         do_exit(0);
         break;
         case 'Z':
         clava_dcg_global[ 47 ]++;
         fprintf(stderr, "%s: -Z not supported in this version\n", progname);
         clava_dcg_global[ 48 ]++;
         usage();
         clava_dcg_global[ 49 ]++;
         do_exit(1);
         break;
         case '1':
         case '2':
         case '3':
         case '4':
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
         level = optc - '0';
         break;
         default:
         /*Error message already emitted by getopt_long.*/
         clava_dcg_global[ 48 ]++;
         usage();
         clava_dcg_global[ 49 ]++;
         do_exit(1);
      }
   }
   /*loop on all arguments*/
   /*Ignore "Broken Pipe" message with --quiet*/
   clava_dcg_global[ 43 ]++;
   if(quiet && signal(13, ((__sighandler_t) 1)) != ((__sighandler_t) 1)) {
      clava_dcg_global[ 43 ]++;
      signal(13, (sig_type) abort_gzip_signal);
   }
   /*By default, save name and timestamp on compression but do not
   * restore them on decompression.
   */
   if(no_time < 0) no_time = decompress;
   if(no_name < 0) no_name = decompress;
   file_count = argc - optind;
   if(ascii && !quiet) {
      clava_dcg_global[ 47 ]++;
      fprintf(stderr, "%s: option --ascii ignored on this system\n", progname);
   }
   if((z_len == 0 && !decompress) || z_len > 30) {
      clava_dcg_global[ 47 ]++;
      fprintf(stderr, "%s: incorrect suffix '%s'\n", progname, z_suffix);
      clava_dcg_global[ 49 ]++;
      do_exit(1);
   }
   if(do_lzw && !decompress) work = lzw;
   /*Allocate all global buffers (for DYN_ALLOC option)*/
   ;
   ;
   ;
   ;
   ;
   /*And get to work*/
   if(file_count != 0) {
      if(to_stdout && !test && !list && (!decompress || !ascii)) {
         ;
      }
      while(optind < argc) {
         clava_dcg_global[ 53 ]++;
         treat_file(argv[optind++]);
      }
   }
   else {
      /*Standard input*/
      clava_dcg_global[ 54 ]++;
      treat_stdin();
   }
   if(list && !quiet && file_count > 1) {
      clava_dcg_global[ 55 ]++;
      do_list(-1, -1);
      /*print totals*/
   }
   clava_dcg_global[ 49 ]++;
   do_exit(exit_code);
   
   return exit_code;
   /*just to avoid lint warning*/
}

/*Return nonzero when at end of file on input.*/
static int input_eof() {
   if(!decompress || last_member) 
   return 1;
   if(inptr == insize) {
      clava_dcg_global[ 56 ]++;
      if(insize != 0x8000 || fill_inbuf(1) == (-1)) 
      return 1;
      /*Unget the char that fill_inbuf got.*/
      inptr = 0;
   }
   
   return 0;
}

/*========================================================================
* Compress or decompress stdin
*/
static void treat_stdin() {
   clava_dcg_global[ 57 ]++;
   clava_dcg_global[ 58 ]++;
   if(!force && !list && isatty(fileno((FILE *) (decompress ? stdin : stdout)))) {
      /*Do not send compressed data to the terminal or read it from
      * the terminal. We get here when user invoked the program
      * without parameters, so be helpful. According to the GNU standards:
      *
      *   If there is one behavior you think is most useful when the output
      *   is to a terminal, and another that you think is most useful when
      *   the output is a file or a pipe, then it is usually best to make
      *   the default behavior the one that is useful with output to a
      *   terminal, and have an option for the other behavior.
      *
      * Here we use the --force option to get the other behavior.
      */
      clava_dcg_global[ 59 ]++;
      fprintf(stderr, "%s: compressed data not %s a terminal. Use -f to force %scompression.\n", progname, decompress ? "read from" : "written to", decompress ? "de" : "");
      clava_dcg_global[ 59 ]++;
      fprintf(stderr, "For help, type: %s -h\n", progname);
      clava_dcg_global[ 60 ]++;
      do_exit(1);
   }
   if(decompress || !ascii) {
      ;
   }
   if(!test && !list && (!decompress || !ascii)) {
      ;
   }
   clava_dcg_global[ 61 ]++;
   strcpy(ifname, "stdin");
   clava_dcg_global[ 61 ]++;
   strcpy(ofname, "stdout");
   /*Get the time stamp on the input file.*/
   time_stamp = 0;
   /*time unknown by default*/
   if(list || !no_time) {
      clava_dcg_global[ 62 ]++;
      clava_dcg_global[ 58 ]++;
      if(fstat(fileno(stdin), &istat) != 0) {
         clava_dcg_global[ 63 ]++;
         progerror("standard input");
         clava_dcg_global[ 60 ]++;
         do_exit(1);
      }
      time_stamp = istat.st_mtim.tv_sec;
      /*NO_STDIN_FSTAT*/
   }
   ifile_size = -1L;
   /*convention for unknown size*/
   clava_dcg_global[ 64 ]++;
   clear_bufs();
   /*clear input and output buffers*/
   to_stdout = 1;
   part_nb = 0;
   if(decompress) {
      clava_dcg_global[ 65 ]++;
      method = get_method(ifd);
      if(method < 0) {
         clava_dcg_global[ 60 ]++;
         do_exit(exit_code);
         /*error message already emitted*/
      }
   }
   if(list) {
      clava_dcg_global[ 66 ]++;
      do_list(ifd, method);
      
      return;
   }
   /*Actually do the compression/decompression. Loop over zipped members.
   */
   for(;;) {
      clava_dcg_global[ 67 ]++;
      clava_dcg_global[ 58 ]++;
      clava_dcg_global[ 58 ]++;
      if((*work)(fileno(stdin), fileno(stdout)) != 0) 
      return;
      clava_dcg_global[ 68 ]++;
      if(input_eof()) break;
      clava_dcg_global[ 65 ]++;
      method = get_method(ifd);
      if(method < 0) 
      return;
      /*error message already emitted*/
      bytes_out = 0;
      /*required for length check*/
   }
   if(verbose) {
      if(test) {
         clava_dcg_global[ 59 ]++;
         fprintf(stderr, " OK\n");
      }
      else if(!decompress) {
         clava_dcg_global[ 69 ]++;
         display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
         clava_dcg_global[ 59 ]++;
         fprintf(stderr, "\n");
      }
   }
}

/*========================================================================
* Compress or decompress the given file
*/
static void treat_file(char *iname) {
   /*Accept "-" as synonym for stdin*/
   clava_dcg_global[ 70 ]++;
   if((strcmp((iname), ("-")) == 0)) {
      int cflag = to_stdout;
      clava_dcg_global[ 71 ]++;
      treat_stdin();
      to_stdout = cflag;
      
      return;
   }
   /*Check if the input file is present, set ifname and istat:*/
   clava_dcg_global[ 72 ]++;
   if(get_istat(iname, &istat) != 0) 
   return;
   /*If the input name is that of a directory, recurse or ignore:*/
   if(((((istat.st_mode)) & 0170000) == (0040000))) {
      if(recursive) {
         struct stat st;
         st = istat;
         clava_dcg_global[ 73 ]++;
         treat_dir(iname);
         /*Warning: ifname is now garbage*/
         clava_dcg_global[ 74 ]++;
         reset_times(iname, &st);
      }
      else {
         if(!quiet) {
            clava_dcg_global[ 75 ]++;
            fprintf(stderr, "%s: %s is a directory -- ignored\n", progname, ifname);
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
      
      return;
   }
   if(!((((istat.st_mode)) & 0170000) == (0100000))) {
      {
         if(!quiet) {
            clava_dcg_global[ 75 ]++;
            fprintf(stderr, "%s: %s is not a directory or a regular file - ignored\n", progname, ifname);
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
      
      return;
   }
   if(istat.st_nlink > 1 && !to_stdout && !force) {
      {
         if(!quiet) {
            clava_dcg_global[ 75 ]++;
            fprintf(stderr, "%s: %s has %lu other link%c -- unchanged\n", progname, ifname, (unsigned long) istat.st_nlink - 1, istat.st_nlink > 2 ? 's' : ' ');
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
      
      return;
   }
   ifile_size = istat.st_size;
   time_stamp = no_time && !list ? 0 : istat.st_mtim.tv_sec;
   /*Generate output file name. For -r and (-t or -l), skip files
   * without a valid gzip suffix (check done in make_ofname).
   */
   if(to_stdout && !list && !test) {
      clava_dcg_global[ 76 ]++;
      strcpy(ofname, "stdout");
   }
   else {
      clava_dcg_global[ 77 ]++;
      if(make_ofname() != 0) {
         
         return;
      }
   }
   /*Open the input file and determine compression method. The mode
   * parameter is ignored but required by some systems (VMS) and forbidden
   * on other systems (MacOS).
   */
   clava_dcg_global[ 78 ]++;
   ifd = open(ifname, ascii && !decompress ? 00 : 00 | 0, (0400 | 0200));
   if(ifd == -1) {
      clava_dcg_global[ 79 ]++;
      progerror(ifname);
      
      return;
   }
   clava_dcg_global[ 80 ]++;
   clear_bufs();
   /*clear input and output buffers*/
   part_nb = 0;
   if(decompress) {
      clava_dcg_global[ 81 ]++;
      method = get_method(ifd);
      /*updates ofname if original given*/
      if(method < 0) {
         clava_dcg_global[ 82 ]++;
         close(ifd);
         
         return;
         /*error message already emitted*/
      }
   }
   if(list) {
      clava_dcg_global[ 83 ]++;
      do_list(ifd, method);
      clava_dcg_global[ 82 ]++;
      close(ifd);
      
      return;
   }
   /*If compressing to a file, check if ofname is not ambiguous
   * because the operating system truncates names. Otherwise, generate
   * a new ofname and save the original name in the compressed file.
   */
   if(to_stdout) {
      clava_dcg_global[ 84 ]++;
      ofd = fileno(stdout);
      /*keep remove_ofname as zero*/
   }
   else {
      clava_dcg_global[ 85 ]++;
      if(create_outfile() != 0) 
      return;
      if(!decompress && save_orig_name && !verbose && !quiet) {
         clava_dcg_global[ 75 ]++;
         fprintf(stderr, "%s: %s compressed to %s\n", progname, ifname, ofname);
      }
   }
   /*Keep the name even if not truncated except with --no-name:*/
   if(!save_orig_name) save_orig_name = !no_name;
   if(verbose) {
      clava_dcg_global[ 75 ]++;
      fprintf(stderr, "%s:\t", ifname);
   }
   /*Actually do the compression/decompression. Loop over zipped members.
   */
   for(;;) {
      clava_dcg_global[ 86 ]++;
      if((*work)(ifd, ofd) != 0) {
         method = -1;
         /*force cleanup*/
         break;
      }
      clava_dcg_global[ 87 ]++;
      if(input_eof()) break;
      clava_dcg_global[ 81 ]++;
      method = get_method(ifd);
      if(method < 0) break;
      /*error message already emitted*/
      bytes_out = 0;
      /*required for length check*/
   }
   clava_dcg_global[ 82 ]++;
   close(ifd);
   if(!to_stdout) {
      /*Copy modes, times, ownership, and remove the input file*/
      clava_dcg_global[ 88 ]++;
      copy_stat(&istat);
      clava_dcg_global[ 82 ]++;
      if(close(ofd)) {
         clava_dcg_global[ 89 ]++;
         write_error();
      }
   }
   if(method == -1) {
      if(!to_stdout) {
         clava_dcg_global[ 90 ]++;
         xunlink(ofname);
      }
      
      return;
   }
   /*Display statistics*/
   if(verbose) {
      if(test) {
         clava_dcg_global[ 75 ]++;
         fprintf(stderr, " OK");
      }
      else if(decompress) {
         clava_dcg_global[ 91 ]++;
         display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stderr);
      }
      else {
         clava_dcg_global[ 91 ]++;
         display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
      }
      if(!test && !to_stdout) {
         clava_dcg_global[ 75 ]++;
         fprintf(stderr, " -- replaced with %s", ofname);
      }
      clava_dcg_global[ 75 ]++;
      fprintf(stderr, "\n");
   }
}

/*========================================================================
* Create the output file. Return OK or ERROR.
* Try several times if necessary to avoid truncating the z_suffix. For
* example, do not create a compressed file of name "1234567890123."
* Sets save_orig_name to true if the file name has been truncated.
* IN assertions: the input file has already been open (ifd is set) and
*   ofname has already been updated if there was an original name.
* OUT assertions: ifd and ofd are closed in case of error.
*/
static int create_outfile() {
   struct stat ostat;
   /*stat for ofname*/
   int flags = 01 | 0100 | 0200 | 0;
   if(ascii && decompress) {
      flags &= ~0;
      /*force ascii text mode*/
   }
   for(;;) {
      /*Make sure that ofname is not an existing file*/
      clava_dcg_global[ 92 ]++;
      if(check_ofname() != 0) {
         clava_dcg_global[ 93 ]++;
         close(ifd);
         
         return 1;
      }
      /*Create the output file*/
      remove_ofname = 1;
      clava_dcg_global[ 94 ]++;
      ofd = open(ofname, flags, (0400 | 0200));
      if(ofd == -1) {
         clava_dcg_global[ 95 ]++;
         progerror(ofname);
         clava_dcg_global[ 93 ]++;
         close(ifd);
         
         return 1;
      }
      /*Check for name truncation on new file (1234567890123.gz)*/
      clava_dcg_global[ 96 ]++;
      if(fstat(ofd, &ostat) != 0) {
         clava_dcg_global[ 95 ]++;
         progerror(ofname);
         clava_dcg_global[ 93 ]++;
         close(ifd);
         clava_dcg_global[ 93 ]++;
         close(ofd);
         clava_dcg_global[ 97 ]++;
         xunlink(ofname);
         
         return 1;
      }
      clava_dcg_global[ 98 ]++;
      if(!name_too_long(ofname, &ostat)) 
      return 0;
      if(decompress) {
         /*name might be too long if an original name was saved*/
         {
            if(!quiet) {
               clava_dcg_global[ 99 ]++;
               fprintf(stderr, "%s: %s: warning, name truncated\n", progname, ofname);
            }
            if(exit_code == 0) exit_code = 2;
         }
         ;
         
         return 0;
      }
      clava_dcg_global[ 93 ]++;
      close(ofd);
      clava_dcg_global[ 97 ]++;
      xunlink(ofname);
      /*Should never happen, see check_ofname()*/
      clava_dcg_global[ 100 ]++;
      shorten_name(ofname);
   }
}

/*========================================================================
* Use lstat if available, except for -c or -f. Use stat otherwise.
* This allows links when not removing the original file.
*/
static int do_stat(char *name, struct stat *sbuf) {
   clava_dcg_global[ 101 ]++;
   (*__errno_location()) = 0;
   if(!to_stdout && !force) {
      clava_dcg_global[ 102 ]++;
      
      return lstat(name, sbuf);
   }
   clava_dcg_global[ 103 ]++;
   
   return stat(name, sbuf);
}

/*========================================================================
* Return a pointer to the 'z' suffix of a file name, or NULL. For all
* systems, ".gz", ".z", ".Z", ".taz", ".tgz", "-gz", "-z" and "_z" are
* accepted suffixes, in addition to the value of the --suffix option.
* ".tgz" is a useful convention for tar.z files on systems limited
* to 3 characters extensions. On such systems, ".?z" and ".??z" are
* also accepted suffixes. For Unix, we do not want to accept any
* .??z suffix as indicating a compressed file; some people use .xyz
* to denote volume data.
*   On systems allowing multiple versions of the same file (such as VMS),
* this function removes any version suffix in the given name.
*/
static char * get_suffix(char *name) {
   int nlen, slen;
   char suffix[33];
   /*last chars of name, forced to lower case*/
   static char *known_suffixes[9] = {((void *) 0), ".gz", ".z", ".taz", ".tgz", "-gz", "-z", "_z", ((void *) 0)};
   char **suf = known_suffixes;
   *suf = z_suffix;
   clava_dcg_global[ 104 ]++;
   if((strcmp((z_suffix), ("z")) == 0)) suf++;
   /*strip a version number from the file name*/
   clava_dcg_global[ 105 ]++;
   nlen = strlen(name);
   if(nlen <= 30 + 2) {
      clava_dcg_global[ 106 ]++;
      strcpy(suffix, name);
   }
   else {
      clava_dcg_global[ 106 ]++;
      strcpy(suffix, name + nlen - 30 - 2);
   }
   clava_dcg_global[ 107 ]++;
   strlwr(suffix);
   clava_dcg_global[ 105 ]++;
   slen = strlen(suffix);
   do  {
      clava_dcg_global[ 105 ]++;
      int s = strlen(*suf);
      clava_dcg_global[ 104 ]++;
      if(slen > s && suffix[slen - s - 1] != '/' && (strcmp((suffix + slen - s), (*suf)) == 0)) {
         
         return name + nlen - s;
      }
   }
   while (*++suf != ((void *) 0));
   
   return ((void *) 0);
}

/*========================================================================
* Set ifname to the input file name (with a suffix appended if necessary)
* and istat to its stats. For decompression, if no file exists with the
* original name, try adding successively z_suffix, .gz, .z, -z and .Z.
* For MSDOS, we try only z_suffix and z.
* Return OK or ERROR.
*/
static int get_istat(char *iname, struct stat *sbuf) {
   int ilen;
   /*strlen(ifname)*/
   int z_suffix_errno = 0;
   static char *suffixes[6] = {((void *) 0), ".gz", ".z", "-z", ".Z", ((void *) 0)};
   char **suf = suffixes;
   char *s;
   /*pointer to ifname extension, or NULL*/
   *suf = z_suffix;
   clava_dcg_global[ 108 ]++;
   if(sizeof(ifname) - 1 <= strlen(iname)) goto name_too_long;
   clava_dcg_global[ 109 ]++;
   strcpy(ifname, iname);
   /*If input file exists, return OK.*/
   clava_dcg_global[ 110 ]++;
   if(do_stat(ifname, sbuf) == 0) 
   return 0;
   clava_dcg_global[ 111 ]++;
   if(!decompress || (*__errno_location()) != 2) {
      clava_dcg_global[ 112 ]++;
      progerror(ifname);
      
      return 1;
   }
   /*file.ext doesn't exist, try adding a suffix (after removing any
   * version number for VMS).
   */
   clava_dcg_global[ 113 ]++;
   s = get_suffix(ifname);
   if(s != ((void *) 0)) {
      clava_dcg_global[ 112 ]++;
      progerror(ifname);
      /*ifname already has z suffix and does not exist*/
      
      return 1;
   }
   clava_dcg_global[ 108 ]++;
   ilen = strlen(ifname);
   clava_dcg_global[ 114 ]++;
   if((strcmp((z_suffix), (".gz")) == 0)) suf++;
   /*Search for all suffixes*/
   do  {
      char *s0 = s = *suf;
      clava_dcg_global[ 109 ]++;
      strcpy(ifname, iname);
      clava_dcg_global[ 108 ]++;
      if(sizeof(ifname) <= ilen + strlen(s)) goto name_too_long;
      clava_dcg_global[ 115 ]++;
      strcat(ifname, s);
      clava_dcg_global[ 110 ]++;
      if(do_stat(ifname, sbuf) == 0) 
      return 0;
      clava_dcg_global[ 114 ]++;
      if((strcmp((s0), (z_suffix)) == 0)) {
         clava_dcg_global[ 111 ]++;
         z_suffix_errno = (*__errno_location());
      }
   }
   while (*++suf != ((void *) 0));
   /*No suffix found, complain using z_suffix:*/
   clava_dcg_global[ 109 ]++;
   strcpy(ifname, iname);
   clava_dcg_global[ 115 ]++;
   strcat(ifname, z_suffix);
   clava_dcg_global[ 111 ]++;
   (*__errno_location()) = z_suffix_errno;
   clava_dcg_global[ 112 ]++;
   progerror(ifname);
   
   return 1;
   name_too_long:
   clava_dcg_global[ 116 ]++;
   fprintf(stderr, "%s: %s: file name too long\n", progname, iname);
   exit_code = 1;
   
   return 1;
}

/*========================================================================
* Generate ofname given ifname. Return OK, or WARNING if file must be skipped.
* Sets save_orig_name to true if the file name has been truncated.
*/
static int make_ofname() {
   char *suff;
   /*ofname z suffix*/
   clava_dcg_global[ 117 ]++;
   strcpy(ofname, ifname);
   /*strip a version number if any and get the gzip suffix if present:*/
   clava_dcg_global[ 118 ]++;
   suff = get_suffix(ofname);
   if(decompress) {
      if(suff == ((void *) 0)) {
         /*With -t or -l, try all files (even without .gz suffix)
         * except with -r (behave as with just -dr).
         */
         if(!recursive && (list || test)) 
         return 0;
         /*Avoid annoying messages with -r*/
         if(verbose || (!recursive && !quiet)) {
            {
               if(!quiet) {
                  clava_dcg_global[ 119 ]++;
                  fprintf(stderr, "%s: %s: unknown suffix -- ignored\n", progname, ifname);
               }
               if(exit_code == 0) exit_code = 2;
            }
            ;
         }
         
         return 2;
      }
      /*Make a special case for .tgz and .taz:*/
      clava_dcg_global[ 120 ]++;
      strlwr(suff);
      clava_dcg_global[ 121 ]++;
      clava_dcg_global[ 121 ]++;
      if((strcmp((suff), (".tgz")) == 0) || (strcmp((suff), (".taz")) == 0)) {
         clava_dcg_global[ 117 ]++;
         strcpy(suff, ".tar");
      }
      else {
         *suff = '\0';
         /*strip the z suffix*/
      }
      /*ofname might be changed later if infile contains an original name*/
   }
   else if(suff != ((void *) 0)) {
      /*Avoid annoying messages with -r (see treat_dir())*/
      if(verbose || (!recursive && !quiet)) {
         /*don't use WARN -- it will cause an exit_code of 2*/
         clava_dcg_global[ 119 ]++;
         fprintf(stderr, "%s: %s already has %s suffix -- unchanged\n", progname, ifname, suff);
      }
      
      return 2;
   }
   else {
      save_orig_name = 0;
      /*On the Atari and some versions of MSDOS, name_too_long()
      * does not work correctly because of a bug in stat(). So we
      * must truncate here.
      */
      /*NO_MULTIPLE_DOTS*/
      clava_dcg_global[ 122 ]++;
      if(sizeof(ofname) <= strlen(ofname) + z_len) goto name_too_long;
      clava_dcg_global[ 123 ]++;
      strcat(ofname, z_suffix);
   }
   /*decompress ?*/
   
   return 0;
   name_too_long:
   {
      if(!quiet) {
         clava_dcg_global[ 119 ]++;
         fprintf(stderr, "%s: %s: file name too long\n", progname, ifname);
      }
      if(exit_code == 0) exit_code = 2;
   }
   ;
   
   return 2;
}

/*========================================================================
* Check the magic number of the input file and update ofname if an
* original name was given and to_stdout is not set.
* Return the compression method, -1 for error, -2 for warning.
* Set inptr to the offset of the next byte to be processed.
* Updates time_stamp if there is one and --no-time is not used.
* This function may be called repeatedly for an input file consisting
* of several contiguous gzip'ed members.
* IN assertions: there is at least one remaining compressed member.
*   If the member is a zip file, it must be the only one.
*/
static int get_method(int in) {
   /*input file descriptor*/
   uch flags;
   /*compression flags*/
   char magic[2];
   /*magic header*/
   int imagic1;
   /*like magic[1], but can represent EOF*/
   ulg stamp;
   /*time stamp*/
   /*If --force and --stdout, zcat == cat, so do not complain about
   * premature end of file: use try_byte instead of get_byte.
   */
   if(force && to_stdout) {
      clava_dcg_global[ 124 ]++;
      magic[0] = (char) (inptr < insize ? inbuf[inptr++] : fill_inbuf(1));
      clava_dcg_global[ 124 ]++;
      imagic1 = (inptr < insize ? inbuf[inptr++] : fill_inbuf(1));
      magic[1] = (char) imagic1;
      /*If try_byte returned EOF, magic[1] == (char) EOF.*/
   }
   else {
      clava_dcg_global[ 124 ]++;
      magic[0] = (char) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      clava_dcg_global[ 124 ]++;
      magic[1] = (char) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      imagic1 = 0;
      /*avoid lint warning*/
   }
   method = -1;
   /*unknown yet*/
   part_nb++;
   /*number of parts in gzip file*/
   header_bytes = 0;
   last_member = 0;
   /*assume multiple members in gzip file except for record oriented I/O*/
   clava_dcg_global[ 125 ]++;
   clava_dcg_global[ 125 ]++;
   if(memcmp(magic, "", 2) == 0 || memcmp(magic, "", 2) == 0) {
      clava_dcg_global[ 124 ]++;
      method = (int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      if(method != 8) {
         clava_dcg_global[ 126 ]++;
         fprintf(stderr, "%s: %s: unknown method %d -- not supported\n", progname, ifname, method);
         exit_code = 1;
         
         return -1;
      }
      work = unzip;
      clava_dcg_global[ 124 ]++;
      flags = (uch) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      if((flags & 0x20) != 0) {
         clava_dcg_global[ 126 ]++;
         fprintf(stderr, "%s: %s is encrypted -- not supported\n", progname, ifname);
         exit_code = 1;
         
         return -1;
      }
      if((flags & 0x02) != 0) {
         clava_dcg_global[ 126 ]++;
         fprintf(stderr, "%s: %s is a a multi-part gzip file -- not supported\n", progname, ifname);
         exit_code = 1;
         if(force <= 1) 
         return -1;
      }
      if((flags & 0xC0) != 0) {
         clava_dcg_global[ 126 ]++;
         fprintf(stderr, "%s: %s has flags 0x%x -- not supported\n", progname, ifname, flags);
         exit_code = 1;
         if(force <= 1) 
         return -1;
      }
      clava_dcg_global[ 124 ]++;
      stamp = (ulg) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      clava_dcg_global[ 124 ]++;
      stamp |= ((ulg) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0))) << 8;
      clava_dcg_global[ 124 ]++;
      stamp |= ((ulg) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0))) << 16;
      clava_dcg_global[ 124 ]++;
      stamp |= ((ulg) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0))) << 24;
      if(stamp != 0 && !no_time) time_stamp = stamp;
      clava_dcg_global[ 124 ]++;
      (void) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      /*Ignore extra flags for the moment*/
      clava_dcg_global[ 124 ]++;
      (void) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      /*Ignore OS type for the moment*/
      if((flags & 0x02) != 0) {
         clava_dcg_global[ 124 ]++;
         unsigned int part = (unsigned int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
         clava_dcg_global[ 124 ]++;
         part |= ((unsigned int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0))) << 8;
         if(verbose) {
            clava_dcg_global[ 126 ]++;
            fprintf(stderr, "%s: %s: part number %u\n", progname, ifname, part);
         }
      }
      if((flags & 0x04) != 0) {
         clava_dcg_global[ 124 ]++;
         unsigned int len = (unsigned int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
         clava_dcg_global[ 124 ]++;
         len |= ((unsigned int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0))) << 8;
         if(verbose) {
            clava_dcg_global[ 126 ]++;
            fprintf(stderr, "%s: %s: extra field of %u bytes ignored\n", progname, ifname, len);
         }
         while(len--) {
            clava_dcg_global[ 124 ]++;
            (void) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
         }
      }
      /*Get original file name if it was truncated*/
      if((flags & 0x08) != 0) {
         if(no_name || (to_stdout && !list) || part_nb > 1) {
            /*Discard the old name*/
            char c;
            /*dummy used for NeXTstep 3.0 cc optimizer bug*/
            do  {
               clava_dcg_global[ 124 ]++;
               c = (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
            }
            while (c != 0);
         }
         else {
            /*Copy the base name. Keep a directory prefix intact.*/
            clava_dcg_global[ 127 ]++;
            char *p = base_name(ofname);
            char *base = p;
            char *base2;
            for(;;) {
               clava_dcg_global[ 124 ]++;
               *p = (char) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
               if(*p++ == '\0') break;
               if(p >= ofname + sizeof((ofname))) {
                  clava_dcg_global[ 128 ]++;
                  error("corrupted input -- file name too large");
               }
            }
            clava_dcg_global[ 127 ]++;
            base2 = base_name(base);
            clava_dcg_global[ 129 ]++;
            strcpy(base, base2);
            /*If necessary, adapt the name to local OS conventions:*/
            if(!list) {
               ;
               if(base) list = 0;
               /*avoid warning about unused variable*/
            }
         }
         /*no_name || to_stdout*/
      }
      /*ORIG_NAME*/
      /*Discard file comment if any*/
      if((flags & 0x10) != 0) {
         while((inptr < insize ? inbuf[inptr++] : fill_inbuf(0)) != 0) clava_dcg_global[ 124 ]++;
         /*null*/
      }
      if(part_nb == 1) {
         header_bytes = inptr + 2 * sizeof(long);
         /*include crc and size*/
      }
   }
   else {
      clava_dcg_global[ 125 ]++;
      clava_dcg_global[ 125 ]++;
      if(memcmp(magic, "PK", 2) == 0 && inptr == 2 && memcmp((char *) inbuf, "PK", 4) == 0) {
         /*To simplify the code, we support a zip file when alone only.
         * We are thus guaranteed that the entire local header fits in inbuf.
         */
         inptr = 0;
         work = unzip;
         clava_dcg_global[ 130 ]++;
         if(check_zipfile(in) != 0) 
         return -1;
         /*check_zipfile may get ofname from the local header*/
         last_member = 1;
      }
      else {
         clava_dcg_global[ 125 ]++;
         if(memcmp(magic, "", 2) == 0) {
            work = unpack;
            method = 2;
         }
         else {
            clava_dcg_global[ 125 ]++;
            if(memcmp(magic, "", 2) == 0) {
               work = unlzw;
               method = 1;
               last_member = 1;
            }
            else {
               clava_dcg_global[ 125 ]++;
               if(memcmp(magic, " ", 2) == 0) {
                  work = unlzh;
                  method = 3;
                  last_member = 1;
               }
               else if(force && to_stdout && !list) {
                  /*pass input unchanged*/
                  method = 0;
                  work = copy;
                  inptr = 0;
                  last_member = 1;
               }
            }
         }
      }
   }
   if(method >= 0) 
   return method;
   if(part_nb == 1) {
      clava_dcg_global[ 126 ]++;
      fprintf(stderr, "\n%s: %s: not in gzip format\n", progname, ifname);
      exit_code = 1;
      
      return -1;
   }
   else {
      if(magic[0] == 0) {
         int inbyte;
         for(inbyte = imagic1; inbyte == 0; inbyte = (inptr < insize ? inbuf[inptr++] : fill_inbuf(1))) {
            clava_dcg_global[ 124 ]++;
            continue;
         }
         if(inbyte == (-1)) {
            if(verbose) {
               if(!quiet) {
                  clava_dcg_global[ 126 ]++;
                  fprintf(stderr, "\n%s: %s: decompression OK, trailing zero bytes ignored\n", progname, ifname);
               }
               if(exit_code == 0) exit_code = 2;
            }
            ;
            
            return -3;
         }
      }
      {
         if(!quiet) {
            clava_dcg_global[ 126 ]++;
            fprintf(stderr, "\n%s: %s: decompression OK, trailing garbage ignored\n", progname, ifname);
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
      
      return -2;
   }
}

/*========================================================================
* Display the characteristics of the compressed file.
* If the given method is < 0, display the accumulated totals.
* IN assertions: time_stamp, header_bytes and ifile_size are initialized.
*/
static void do_list(int ifd, int method) {
   /*input file descriptor*/
   /*compression method*/
   ulg crc;
   /*original crc*/
   static int first_time = 1;
   static char *methods[9] = {"store", "compr", "pack ", "lzh  ", "", "", "", "", "defla"};
   char *date;
   int positive_off_t_width = 1;
   off_t o;
   for(o = (~(off_t) 0 - (~(off_t) 0 << (sizeof(off_t) * 8 - 1))); 9 < o; o /= 10) {
      positive_off_t_width++;
   }
   if(first_time && method >= 0) {
      first_time = 0;
      if(verbose) {
         clava_dcg_global[ 131 ]++;
         printf("method  crc     date  time  ");
      }
      if(!quiet) {
         clava_dcg_global[ 131 ]++;
         printf("%*.*s %*.*s  ratio uncompressed_name\n", positive_off_t_width, positive_off_t_width, "compressed", positive_off_t_width, positive_off_t_width, "uncompressed");
      }
   }
   else if(method < 0) {
      if(total_in <= 0 || total_out <= 0) 
      return;
      if(verbose) {
         clava_dcg_global[ 131 ]++;
         printf("                            ");
      }
      if(verbose || !quiet) {
         clava_dcg_global[ 132 ]++;
         fprint_off(stdout, total_in, positive_off_t_width);
         clava_dcg_global[ 131 ]++;
         printf(" ");
         clava_dcg_global[ 132 ]++;
         fprint_off(stdout, total_out, positive_off_t_width);
         clava_dcg_global[ 131 ]++;
         printf(" ");
      }
      clava_dcg_global[ 133 ]++;
      display_ratio(total_out - (total_in - header_bytes), total_out, stdout);
      /*header_bytes is not meaningful but used to ensure the same
      * ratio if there is a single file.
      */
      clava_dcg_global[ 131 ]++;
      printf(" (totals)\n");
      
      return;
   }
   crc = (ulg) ~0;
   /*unknown*/
   bytes_out = -1L;
   bytes_in = ifile_size;
   if(method == 8 && !last_member) {
      /*Get the crc and uncompressed size for gzip'ed (not zip'ed) files.
      * If the lseek fails, we could use read() to get to the end, but
      * --list is used to get quick results.
      * Use "gunzip < foo.gz | wc -c" to get the uncompressed size if
      * you are not concerned about speed.
      */
      clava_dcg_global[ 134 ]++;
      bytes_in = lseek(ifd, (off_t) (-8), 2);
      if(bytes_in != -1L) {
         uch buf[8];
         bytes_in += 8L;
         clava_dcg_global[ 135 ]++;
         if(read(ifd, (char *) buf, sizeof((buf))) != sizeof((buf))) {
            clava_dcg_global[ 136 ]++;
            read_error();
         }
         crc = ((ulg) (((ush) (uch) ((buf)[0]) | ((ush) (uch) ((buf)[1]) << 8))) | ((ulg) (((ush) (uch) (((buf) + 2)[0]) | ((ush) (uch) (((buf) + 2)[1]) << 8))) << 16));
         bytes_out = ((ulg) (((ush) (uch) ((buf + 4)[0]) | ((ush) (uch) ((buf + 4)[1]) << 8))) | ((ulg) (((ush) (uch) (((buf + 4) + 2)[0]) | ((ush) (uch) (((buf + 4) + 2)[1]) << 8))) << 16));
      }
   }
   /*RECORD_IO*/
   clava_dcg_global[ 137 ]++;
   date = ctime((time_t *) &time_stamp) + 4;
   /*skip the day of the week*/
   date[12] = '\0';
   /*suppress the 1/100sec and the year*/
   if(verbose) {
      clava_dcg_global[ 131 ]++;
      printf("%5s %08lx %11s ", methods[method], crc, date);
   }
   clava_dcg_global[ 132 ]++;
   fprint_off(stdout, bytes_in, positive_off_t_width);
   clava_dcg_global[ 131 ]++;
   printf(" ");
   clava_dcg_global[ 132 ]++;
   fprint_off(stdout, bytes_out, positive_off_t_width);
   clava_dcg_global[ 131 ]++;
   printf(" ");
   if(bytes_in == -1L) {
      total_in = -1L;
      bytes_in = bytes_out = header_bytes = 0;
   }
   else if(total_in >= 0) {
      total_in += bytes_in;
   }
   if(bytes_out == -1L) {
      total_out = -1L;
      bytes_in = bytes_out = header_bytes = 0;
   }
   else if(total_out >= 0) {
      total_out += bytes_out;
   }
   clava_dcg_global[ 133 ]++;
   display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stdout);
   clava_dcg_global[ 131 ]++;
   printf(" %s\n", ofname);
}

/*========================================================================
* Return true if the two stat structures correspond to the same file.
*/
static int same_file(struct stat *stat1, struct stat *stat2) {
   
   return stat1->st_ino == stat2->st_ino && stat1->st_dev == stat2->st_dev;
   /*Can't rely on st_ino and st_dev, use other fields:*/
}

/*========================================================================
* Return true if a file name is ambiguous because the operating system
* truncates file names.
*/
static int name_too_long(char *name, struct stat *statb) {
   /*file name to check*/
   /*stat buf for this file name*/
   clava_dcg_global[ 138 ]++;
   int s = strlen(name);
   char c = name[s - 1];
   struct stat tstat;
   /*stat for truncated name*/
   int res;
   tstat = *statb;
   /*Just in case OS does not fill all fields*/
   name[s - 1] = '\0';
   clava_dcg_global[ 139 ]++;
   clava_dcg_global[ 140 ]++;
   res = lstat(name, &tstat) == 0 && same_file(statb, &tstat);
   name[s - 1] = c;
   ;
   
   return res;
}

/*========================================================================
* Shorten the given name by one character, or replace a .tar extension
* with .tgz. Truncate the last part of the name which is longer than
* MIN_PART characters: 1234.678.012.gz -> 123.678.012.gz. If the name
* has only parts shorter than MIN_PART truncate the longest part.
* For decompression, just remove the last character of the name.
*
* IN assertion: for compression, the suffix of the given name is z_suffix.
*/
static void shorten_name(char *name) {
   int len;
   /*length of name without z_suffix*/
   char *trunc = ((void *) 0);
   /*character to be truncated*/
   int plen;
   /*current part length*/
   int min_part = 3;
   /*current minimum part length*/
   char *p;
   clava_dcg_global[ 141 ]++;
   len = strlen(name);
   if(decompress) {
      if(len <= 1) {
         clava_dcg_global[ 142 ]++;
         error("name too short");
      }
      name[len - 1] = '\0';
      
      return;
   }
   clava_dcg_global[ 143 ]++;
   p = get_suffix(name);
   if(p == ((void *) 0)) {
      clava_dcg_global[ 142 ]++;
      error("can't recover suffix\n");
   }
   *p = '\0';
   save_orig_name = 1;
   /*compress 1234567890.tar to 1234567890.tgz*/
   clava_dcg_global[ 144 ]++;
   if(len > 4 && (strcmp((p - 4), (".tar")) == 0)) {
      clava_dcg_global[ 145 ]++;
      strcpy(p - 4, ".tgz");
      
      return;
   }
   /*Try keeping short extensions intact:
   * 1234.678.012.gz -> 123.678.012.gz
   */
   do  {
      clava_dcg_global[ 146 ]++;
      p = strrchr(name, '/');
      p = p ? p + 1 : name;
      while(*p) {
         clava_dcg_global[ 147 ]++;
         plen = strcspn(p, ".");
         p += plen;
         if(plen > min_part) trunc = p - 1;
         if(*p) p++;
      }
   }
   while (trunc == ((void *) 0) && --min_part != 0);
   if(trunc != ((void *) 0)) {
      do  {
         trunc[0] = trunc[1];
      }
      while (*trunc++);
      trunc--;
   }
   else {
      clava_dcg_global[ 146 ]++;
      trunc = strrchr(name, "."[0]);
      if(trunc == ((void *) 0)) {
         clava_dcg_global[ 142 ]++;
         error("internal error in shorten_name");
      }
      if(trunc[1] == '\0') trunc--;
      /*force truncation*/
   }
   clava_dcg_global[ 145 ]++;
   strcpy(trunc, z_suffix);
}

/*========================================================================
* If compressing to a file, check if ofname is not ambiguous
* because the operating system truncates names. Otherwise, generate
* a new ofname and save the original name in the compressed file.
* If the compressed file already exists, ask for confirmation.
*    The check for name truncation is made dynamically, because different
* file systems on the same OS might use different truncation rules (on SVR4
* s5 truncates to 14 chars and ufs does not truncate).
*    This function returns -1 if the file must be skipped, and
* updates save_orig_name if necessary.
* IN assertions: save_orig_name is already set if ofname has been
* already truncated because of NO_MULTIPLE_DOTS. The input file has
* already been open and istat is set.
*/
static int check_ofname() {
   struct stat ostat;
   /*stat for ofname*/
   /*Check for strictly conforming Posix systems (which return ENAMETOOLONG
   * instead of silently truncating filenames).
   */
   clava_dcg_global[ 148 ]++;
   (*__errno_location()) = 0;
   while(lstat(ofname, &ostat) != 0) {
      clava_dcg_global[ 149 ]++;
      clava_dcg_global[ 148 ]++;
      if((*__errno_location()) != 36) 
      return 0;
      /*ofname does not exist*/
      clava_dcg_global[ 150 ]++;
      shorten_name(ofname);
   }
   /*Check for name truncation on existing file. Do this even on systems
   * defining ENAMETOOLONG, because on most systems the strict Posix
   * behavior is disabled by default (silent name truncation allowed).
   */
   clava_dcg_global[ 151 ]++;
   if(!decompress && name_too_long(ofname, &ostat)) {
      clava_dcg_global[ 150 ]++;
      shorten_name(ofname);
      clava_dcg_global[ 149 ]++;
      if(lstat(ofname, &ostat) != 0) 
      return 0;
   }
   /*Check that the input and output files are different (could be
   * the same by name truncation or links).
   */
   clava_dcg_global[ 152 ]++;
   if(same_file(&istat, &ostat)) {
      clava_dcg_global[ 153 ]++;
      if((strcmp((ifname), (ofname)) == 0)) {
         clava_dcg_global[ 154 ]++;
         fprintf(stderr, "%s: %s: cannot %scompress onto itself\n", progname, ifname, decompress ? "de" : "");
      }
      else {
         clava_dcg_global[ 154 ]++;
         fprintf(stderr, "%s: %s and %s are the same file\n", progname, ifname, ofname);
      }
      exit_code = 1;
      
      return 1;
   }
   /*Ask permission to overwrite the existing file*/
   if(!force) {
      int ok = 0;
      clava_dcg_global[ 154 ]++;
      fprintf(stderr, "%s: %s already exists;", progname, ofname);
      clava_dcg_global[ 155 ]++;
      clava_dcg_global[ 156 ]++;
      if(foreground && isatty(fileno(stdin))) {
         clava_dcg_global[ 154 ]++;
         fprintf(stderr, " do you wish to overwrite (y or n)? ");
         clava_dcg_global[ 157 ]++;
         fflush(stderr);
         clava_dcg_global[ 158 ]++;
         ok = yesno();
      }
      if(!ok) {
         clava_dcg_global[ 154 ]++;
         fprintf(stderr, "\tnot overwritten\n");
         if(exit_code == 0) exit_code = 2;
         
         return 1;
      }
   }
   clava_dcg_global[ 159 ]++;
   if(xunlink(ofname)) {
      clava_dcg_global[ 160 ]++;
      progerror(ofname);
      
      return 1;
   }
   
   return 0;
}

/*========================================================================
* Set the access and modification times from the given stat buffer.
*/
static void reset_times(char *name, struct stat *statb) {
   struct utimbuf timep;
   /*Copy the time stamp*/
   timep.actime = statb->st_atim.tv_sec;
   timep.modtime = statb->st_mtim.tv_sec;
   /*Some systems (at least OS/2) do not support utime on directories*/
   clava_dcg_global[ 161 ]++;
   if(utime(name, &timep) && !((((statb->st_mode)) & 0170000) == (0040000))) {
      clava_dcg_global[ 162 ]++;
      int e = (*__errno_location());
      {
         if(!quiet) {
            clava_dcg_global[ 163 ]++;
            fprintf(stderr, "%s: ", progname);
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
      if(!quiet) {
         clava_dcg_global[ 162 ]++;
         (*__errno_location()) = e;
         clava_dcg_global[ 164 ]++;
         perror(ofname);
      }
   }
}

/*========================================================================
* Copy modes, times, ownership from input file to output file.
* IN assertion: to_stdout is false.
*/
static void copy_stat(struct stat *ifstat) {
   if(decompress && time_stamp != 0 && ifstat->st_mtim.tv_sec != time_stamp) {
      ifstat->st_mtim.tv_sec = time_stamp;
      if(verbose > 1) {
         clava_dcg_global[ 165 ]++;
         fprintf(stderr, "%s: time stamp restored\n", ofname);
      }
   }
   clava_dcg_global[ 166 ]++;
   reset_times(ofname, ifstat);
   /*Copy the protection modes*/
   clava_dcg_global[ 167 ]++;
   if(fchmod(ofd, ifstat->st_mode & 07777)) {
      clava_dcg_global[ 168 ]++;
      int e = (*__errno_location());
      {
         if(!quiet) {
            clava_dcg_global[ 165 ]++;
            fprintf(stderr, "%s: ", progname);
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
      if(!quiet) {
         clava_dcg_global[ 168 ]++;
         (*__errno_location()) = e;
         clava_dcg_global[ 169 ]++;
         perror(ofname);
      }
   }
   clava_dcg_global[ 170 ]++;
   fchown(ofd, ifstat->st_uid, ifstat->st_gid);
   /*Copy ownership*/
   remove_ofname = 0;
   /*It's now safe to remove the input file:*/
   clava_dcg_global[ 171 ]++;
   if(xunlink(ifname)) {
      clava_dcg_global[ 168 ]++;
      int e = (*__errno_location());
      {
         if(!quiet) {
            clava_dcg_global[ 165 ]++;
            fprintf(stderr, "%s: ", progname);
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
      if(!quiet) {
         clava_dcg_global[ 168 ]++;
         (*__errno_location()) = e;
         clava_dcg_global[ 169 ]++;
         perror(ifname);
      }
   }
}

/*========================================================================
* Recurse through the given directory. This code is taken from ncompress.
*/
static void treat_dir(char *dir) {
   struct dirent *dp;
   DIR *dirp;
   char nbuf[1024];
   int len;
   clava_dcg_global[ 172 ]++;
   dirp = opendir(dir);
   if(dirp == ((void *) 0)) {
      clava_dcg_global[ 173 ]++;
      progerror(dir);
      
      return;
   }
   /*
   ** WARNING: the following algorithm could occasionally cause
   ** compress to produce error warnings of the form "<filename>.gz
   ** already has .gz suffix - ignored". This occurs when the
   ** .gz output file is inserted into the directory below
   ** readdir's current pointer.
   ** These warnings are harmless but annoying, so they are suppressed
   ** with option -r (except when -v is on). An alternative
   ** to allowing this would be to store the entire directory
   ** list in memory, then compress the entries in the stored
   ** list. Given the depth-first recursive algorithm used here,
   ** this could use up a tremendous amount of memory. I don't
   ** think it's worth it. -- Dave Mack
   ** (An other alternative might be two passes to avoid depth-first.)
   */
   while(((*__errno_location()) = 0 , dp = readdir(dirp)) != ((void *) 0)) {
      clava_dcg_global[ 175 ]++;
      clava_dcg_global[ 174 ]++;
      clava_dcg_global[ 176 ]++;
      clava_dcg_global[ 176 ]++;
      if((strcmp((dp->d_name), (".")) == 0) || (strcmp((dp->d_name), ("..")) == 0)) {
         continue;
      }
      clava_dcg_global[ 177 ]++;
      len = strlen(dir);
      clava_dcg_global[ 177 ]++;
      if(len + strlen((dp)->d_name) + 1 < 1024 - 1) {
         clava_dcg_global[ 178 ]++;
         strcpy(nbuf, dir);
         if(len != 0) {
            /*dir = "" means current dir on Amiga*/
            nbuf[len++] = '/';
         }
         clava_dcg_global[ 178 ]++;
         strcpy(nbuf + len, dp->d_name);
         clava_dcg_global[ 179 ]++;
         treat_file(nbuf);
      }
      else {
         clava_dcg_global[ 180 ]++;
         fprintf(stderr, "%s: %s/%s: pathname too long\n", progname, dir, dp->d_name);
         exit_code = 1;
      }
   }
   clava_dcg_global[ 174 ]++;
   if((*__errno_location()) != 0) {
      clava_dcg_global[ 173 ]++;
      progerror(dir);
   }
   clava_dcg_global[ 181 ]++;
   if(closedir(dirp) != 0) {
      clava_dcg_global[ 173 ]++;
      progerror(dir);
   }
}

/*! NO_DIR*/
/*========================================================================
* Free all dynamically allocated variables and exit with the given code.
*/
static void do_exit(int exitcode) {
   static int in_exit = 0;
   if(in_exit) {
      clava_dcg_global[ 182 ]++;
      exit(exitcode);
   }
   in_exit = 1;
   if(env != ((void *) 0)) {
      clava_dcg_global[ 183 ]++;
      free(env) , env = ((void *) 0);
   }
   if(args != ((void *) 0)) {
      clava_dcg_global[ 183 ]++;
      free((char *) args) , args = ((void *) 0);
   }
   ;
   ;
   ;
   ;
   ;
   clava_dcg_global[ 182 ]++;
   exit(exitcode);
}

/*========================================================================
* Close and unlink the output file if appropriate.  This routine must be
* async-signal-safe.
*/
static void do_remove() {
   if(remove_ofname) {
      clava_dcg_global[ 184 ]++;
      close(ofd);
      clava_dcg_global[ 185 ]++;
      xunlink(ofname);
   }
}

/*========================================================================
* Error handler.
*/
void abort_gzip() {
   clava_dcg_global[ 186 ]++;
   do_remove();
   clava_dcg_global[ 187 ]++;
   do_exit(1);
}

/*========================================================================
* Signal handler.
*/
void abort_gzip_signal() {
   clava_dcg_global[ 188 ]++;
   do_remove();
   clava_dcg_global[ 189 ]++;
   _exit(1);
}

/*Inflate deflated data

Copyright (C) 1997, 1998, 1999, 2002 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.
If not, write to the Free Software Foundation,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/
/*Not copyrighted 1992 by Mark Adler
version c10p1, 10 January 1993*/
/*You can do whatever you like with this source file, though I would
prefer that if you modify it and redistribute it that you include
comments to that effect with your name and the date.  Thank you.
[The history has been moved to the file ChangeLog.]
*/
/*
Inflate deflated (PKZIP's method 8 compressed) data.  The compression
method searches for as much of the current string of bytes (up to a
length of 258) in the previous 32K bytes.  If it doesn't find any
matches (of at least length 3), it codes the next byte.  Otherwise, it
codes the length of the matched string and its distance backwards from
the current position.  There is a single Huffman code that codes both
single bytes (called "literals") and match lengths.  A second Huffman
code codes the distance information, which follows a length code.  Each
length or distance code actually represents a base value and a number
of "extra" (sometimes zero) bits to get to add to the base value.  At
the end of each deflated block is a special end-of-block (EOB) literal/
length code.  The decoding process is basically: get a literal/length
code; if EOB then done; if a literal, emit the decoded byte; if a
length then get the distance and emit the referred-to bytes from the
sliding window of previously emitted data.

There are (currently) three kinds of inflate blocks: stored, fixed, and
dynamic.  The compressor deals with some chunk of data at a time, and
decides which method to use on a chunk-by-chunk basis.  A chunk might
typically be 32K or 64K.  If the chunk is uncompressible, then the
"stored" method is used.  In this case, the bytes are simply stored as
is, eight bits per byte, with none of the above coding.  The bytes are
preceded by a count, since there is no longer an EOB code.

If the data is compressible, then either the fixed or dynamic methods
are used.  In the dynamic method, the compressed data is preceded by
an encoding of the literal/length and distance Huffman codes that are
to be used to decode this block.  The representation is itself Huffman
coded, and so is preceded by a description of that code.  These code
descriptions take up a little space, and so for small blocks, there is
a predefined set of codes, called the fixed codes.  The fixed method is
used if the block codes up smaller that way (usually for quite small
chunks), otherwise the dynamic method is used.  In the latter case, the
codes are customized to the probabilities in the current block, and so
can code it much better than the pre-determined fixed codes.

The Huffman codes themselves are decoded using a multi-level table
lookup, in order to maximize the speed of decoding plus the speed of
building the decoding tables.  See the comments below that precede the
lbits and dbits tuning parameters.
*/
/*
Notes beyond the 1.93a appnote.txt:

1. Distance pointers never point before the beginning of the output
stream.
2. Distance pointers can point back across blocks, up to 32k away.
3. There is an implied maximum of 7 bits for the bit length table and
15 bits for the actual data.
4. If only one code exists, then it is encoded using one bit.  (Zero
would be more efficient, but perhaps a little confusing.)  If two
codes exist, they are coded using one bit each (0 and 1).
5. There is no way of sending zero distance codes--a dummy must be
sent if there are none.  (History: a pre 2.0 version of PKZIP would
store blocks with no distance codes, but this was discovered to be
too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
zero distance codes, which is sent as one code of zero bits in
length.
6. There are up to 286 literal/length codes.  Code 256 represents the
end-of-block.  Note however that the static length tree defines
288 codes just to fill out the Huffman codes.  Codes 286 and 287
cannot be used though, since there is no length base or extra bits
defined for them.  Similarly, there are up to 30 distance codes.
However, static trees define 32 codes (all 5 bits) to fill out the
Huffman codes, but the last two had better not show up in the data.
7. Unzip can check dynamic Huffman blocks for complete code sets.
The exception is that a single code would not be complete (see #4).
8. The five bits following the block type is really the number of
literal codes sent minus 257.
9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
(1+6+6).  Therefore, to output three times the length, you output
three codes (1+1+1), whereas to output four times the same length,
you only need two codes (1+3).  Hmm.
10. In the tree reconstruction algorithm, Code = Code + Increment
only if BitLength(i) is not zero.  (Pretty obvious.)
11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
12. Note: length code 284 can represent 227-258, but length code 285
really is 258.  The last length deserves its own, short code
since it gets used a lot in very redundant files.  The length
258 is special since 258 - 3 (the min match length) is 255.
13. The literal/length and distance code bit lengths are read as a
single stream of lengths.  It is possible (and advantageous) for
a repeat code (16, 17, or 18) to go across the boundary between
the two sets of lengths.
*/
/*Huffman code lookup table entry--this entry is four bytes for machines
that have 16-bit pointers (e.g. PC's in the small or medium model).
Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
means that v is a literal, 16 < e < 32 means that v is a pointer to
the next table, which codes e - 16 bits, and lastly e == 99 indicates
an unused code.  If a code with e == 99 is looked up, this implies an
error in the data.*/

struct huft {
   uch e;
   /*number of extra bits or operation*/
   uch b;
   /*number of bits in this code or subcode*/
   
   union anon_gzip_c_4783 {
      ush n;
      /*literal, length base, or distance base*/
      struct huft *t;
   };
   
   union anon_gzip_c_4783 v;
};

/*pointer to next level of table*/
/*Function prototypes*/
int huft_build(unsigned int *, unsigned int, unsigned int, ush *, ush *, struct huft **, int *);
int huft_free(struct huft *);
int inflate_codes(struct huft *, struct huft *, int, int);
int inflate_stored();
int inflate_fixed();
int inflate_dynamic();
int inflate_block(int *);
int inflate();
/*The inflate algorithm uses a sliding 32K byte window on the uncompressed
stream to find repeated byte strings.  This is implemented here as a
circular buffer.  The index is updated simply by incrementing and then
and'ing with 0x7fff (32K-1).*/

/*It is left to other modules to supply the 32K area.  It is assumed
to be usable as if it were declared "uch slide[32768];" or as just
"uch *slide;" and then malloc'ed in the latter case.  The definition
must be in unzip.h, included above.*/

/*unsigned wp;             current position in slide*/

/*Tables for deflate from PKZIP's appnote.txt.*/

static unsigned int border[19] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
/*Order of the bit length code lengths*/

static ush cplens[31] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
/*Copy lengths for literal codes 257..285*/

/*note: see note #13 above about the 258 in this list.*/

static ush cplext[31] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99};
/*Extra bits for literal codes 257..285*/

/*99==invalid*/

static ush cpdist[30] = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};
/*Copy offsets for distance codes 0..29*/

static ush cpdext[30] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
/*Extra bits for distance codes*/

/*Macros for inflate() bit peeking and grabbing.
The usage is:

NEEDBITS(j)
x = b & mask_bits[j];
DUMPBITS(j)

where NEEDBITS makes sure that b has at least j bits in it, and
DUMPBITS removes the bits from b.  The macros use the variable k
for the number of bits in b.  Normally, b and k are register
variables for speed, and are initialized at the beginning of a
routine that uses these macros from a global bit buffer and count.
The macros also use the variable w, which is a cached copy of wp.

If we assume that EOB will be the longest code, then we will never
ask for bits with NEEDBITS that are beyond the end of the stream.
So, NEEDBITS should not read any more bytes than are needed to
meet the request.  Then no bytes need to be "returned" to the buffer
at the end of the last block.

However, this assumption is not true for fixed blocks--the EOB code
is 7 bits, but the other literal/length codes can be 8 or 9 bits.
(The EOB code is shorter than other codes because fixed blocks are
generally short.  So, while a block always has an EOB, many other
literal/length codes have a significantly lower probability of
showing up at all.)  However, by making the first table have a
lookup of seven bits, the EOB code will be found in that first
lookup, and so will not require that too many bits be pulled from
the stream.
*/

ulg bb;
/*bit buffer*/

unsigned int bk;
/*bits in bit buffer*/

ush mask_bits[17] = {0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff};
/*
Huffman code decoding is performed using a multi-level table lookup.
The fastest way to decode is to simply build a lookup table whose
size is determined by the longest code.  However, the time it takes
to build this table can also be a factor if the data being decoded
is not very long.  The most common codes are necessarily the
shortest codes, so those codes dominate the decoding time, and hence
the speed.  The idea is you can have a shorter table that decodes the
shorter, more probable codes, and then point to subsidiary tables for
the longer codes.  The time it costs to decode the longer codes is
then traded against the time it takes to make longer tables.

This results of this trade are in the variables lbits and dbits
below.  lbits is the number of bits the first level table for literal/
length codes can decode in one step, and dbits is the same thing for
the distance codes.  Subsequent tables are also less than or equal to
those sizes.  These values may be adjusted either when all of the
codes are shorter than that, in which case the longest code length in
bits is used, or when the shortest code is *longer* than the requested
table size, in which case the length of the shortest code in bits is
used.

There are two different values for the two tables, since they code a
different number of possibilities each.  The literal/length table
codes 286 possible values, or in a flat code, a little over eight
bits.  The distance table codes 30 possible values, or a little less
than five bits, flat.  The optimum values for speed end up being
about one bit more than those, so lbits is 8+1 and dbits is 5+1.
The optimum values may differ though from machine to machine, and
possibly even between compilers.  Your mileage may vary.
*/

int lbits = 9;
/*bits in base literal/length lookup table*/

int dbits = 6;
/*bits in base distance lookup table*/

/*If BMAX needs to be larger than 16, then h and x[] should be ulg.*/

/*maximum bit length of any code (16 for explode)*/

/*maximum number of codes in any set*/

unsigned int hufts;
/*track memory usage*/
int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d, ush *e, struct huft **t, int *m) {
   /*code lengths in bits (all assumed <= BMAX)*/
   /*number of codes (assumed <= N_MAX)*/
   /*number of simple-valued codes (0..s-1)*/
   /*list of base values for non-simple codes*/
   /*list of extra bits for non-simple codes*/
   /*result: starting table*/
   /*maximum lookup bits, returns actual*/
   /*Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return zero on success, one if
   the given code set is incomplete (the tables are still built in this
   case), two if the input is invalid (all zero length codes or an
   oversubscribed set of lengths), and three if not enough memory.*/
   unsigned int a;
   /*counter for codes of length k*/
   unsigned int c[17];
   /*bit length count table*/
   unsigned int f;
   /*i repeats in table every f entries*/
   int g;
   /*maximum code length*/
   int h;
   /*table level*/
   register unsigned int i;
   /*counter, current code*/
   register unsigned int j;
   /*counter*/
   register int k;
   /*number of bits in current code*/
   int l;
   /*bits per table (returned in m)*/
   register unsigned int *p;
   /*pointer into c[], b[], or v[]*/
   register struct huft *q;
   /*points to current table*/
   struct huft r;
   /*table entry for structure assignment*/
   struct huft *u[16];
   /*table stack*/
   unsigned int v[288];
   /*values in order of bit length*/
   register int w;
   /*bits before this table == (l * h)*/
   unsigned int x[17];
   /*bit offsets, then code stack*/
   unsigned int *xp;
   /*pointer into x*/
   int y;
   /*number of dummy codes added*/
   unsigned int z;
   /*number of entries in current table*/
   /*Generate counts for each bit length*/
   clava_dcg_global[ 190 ]++;
   memset((voidp) (c), 0, (sizeof((c))));
   p = b;
   i = n;
   do  {
      ;
      c[*p]++;
      /*assume all entries <= BMAX*/
      p++;
      /*Can't combine with above line (Solaris bug)*/
   }
   while (--i);
   if(c[0] == n) {
      /*null input--all zero length codes*/
      *t = (struct huft *) ((void *) 0);
      *m = 0;
      
      return 0;
   }
   /*Find minimum and maximum length, bound *m by those*/
   l = *m;
   for(j = 1; j <= 16; j++) if(c[j]) break;
   k = j;
   /*minimum code length*/
   if((unsigned int) l < j) l = j;
   for(i = 16; i; i--) if(c[i]) break;
   g = i;
   /*maximum code length*/
   if((unsigned int) l > i) l = i;
   *m = l;
   /*Adjust last length count to fill out codes, if needed*/
   for(y = 1 << j; j < i; j++ , y <<= 1) if((y -= c[j]) < 0) 
   return 2;
   /*bad input: more codes than bits*/
   if((y -= c[i]) < 0) 
   return 2;
   c[i] += y;
   /*Generate starting offsets into the value table for each length*/
   x[1] = j = 0;
   p = c + 1;
   xp = x + 2;
   while(--i) {
      /*note that i == g from above*/
      *xp++ = (j += *p++);
   }
   /*Make a table of values in order of bit lengths*/
   p = b;
   i = 0;
   do  {
      if((j = *p++) != 0) v[x[j]++] = i;
   }
   while (++i < n);
   n = x[g];
   /*set n to length of v*/
   /*Generate the Huffman codes and for each, make the table entries*/
   x[0] = i = 0;
   /*first Huffman code is zero*/
   p = v;
   /*grab values in bit order*/
   h = -1;
   /*no tables yet--level -1*/
   w = -l;
   /*bits decoded == (l * h)*/
   u[0] = (struct huft *) ((void *) 0);
   /*just to keep compilers happy*/
   q = (struct huft *) ((void *) 0);
   /*ditto*/
   z = 0;
   /*ditto*/
   /*go through the bit lengths (k already is bits in shortest code)*/
   for(; k <= g; k++) {
      a = c[k];
      while(a--) {
         /*here i is the Huffman code of length k bits for value *p*/
         /*make tables up to required level*/
         while(k > w + l) {
            h++;
            w += l;
            /*previous table always l bits*/
            /*compute minimum size table less than or equal to l bits*/
            z = (z = g - w) > (unsigned int) l ? l : z;
            /*upper limit on table size*/
            if((f = 1 << (j = k - w)) > a + 1) {
               /*try a k-w bit table*/
               /*too few codes for k-w bit table*/
               f -= a + 1;
               /*deduct codes from patterns left*/
               xp = c + k;
               if(j < z) while(++j < z) {
                  /*try smaller tables up to z bits*/
                  if((f <<= 1) <= *++xp) break;
                  /*enough codes to use up j bits*/
                  f -= *xp;
                  /*else deduct codes from patterns*/
               }
            }
            z = 1 << j;
            /*table entries for j-bit table*/
            /*allocate and link in new table*/
            clava_dcg_global[ 191 ]++;
            if((q = (struct huft *) malloc((z + 1) * sizeof(struct huft))) == (struct huft *) ((void *) 0)) {
               if(h) {
                  clava_dcg_global[ 192 ]++;
                  huft_free(u[0]);
               }
               
               return 3;
               /*not enough memory*/
            }
            hufts += z + 1;
            /*track memory usage*/
            *t = q + 1;
            /*link to list for huft_free()*/
            *(t = &(q->v.t)) = (struct huft *) ((void *) 0);
            u[h] = ++q;
            /*table starts after link*/
            /*connect to last table, if there is one*/
            if(h) {
               x[h] = i;
               /*save pattern for backing up*/
               r.b = (uch) l;
               /*bits to dump before this table*/
               r.e = (uch) (16 + j);
               /*bits in this table*/
               r.v.t = q;
               /*pointer to this table*/
               j = i >> (w - l);
               /*(get around Turbo C bug)*/
               u[h - 1][j] = r;
               /*connect to last table*/
            }
         }
         /*set up table entry in r*/
         r.b = (uch) (k - w);
         if(p >= v + n) r.e = 99;
         else {
            /*out of values--invalid code*/
            if(*p < s) {
               r.e = (uch) (*p < 256 ? 16 : 15);
               /*256 is end-of-block code*/
               r.v.n = (ush) (*p);
               /*simple code is just the value*/
               p++;
               /*one compiler does not like *p++*/
            }
            else {
               r.e = (uch) e[*p - s];
               /*non-simple--look up in lists*/
               r.v.n = d[*p++ - s];
            }
         }
         /*fill code-like entries with r*/
         f = 1 << (k - w);
         for(j = i >> w; j < z; j += f) q[j] = r;
         /*backwards increment the k-bit code i*/
         for(j = 1 << (k - 1); i & j; j >>= 1) i ^= j;
         i ^= j;
         /*backup over finished tables*/
         while((i & ((1 << w) - 1)) != x[h]) {
            h--;
            /*don't need to update q*/
            w -= l;
         }
      }
   }
   /*Return true (1) if we were given an incomplete table*/
   
   return y != 0 && g != 1;
}

int huft_free(struct huft *t) {
   /*table to free*/
   /*Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table.*/
   register struct huft *p, *q;
   /*Go through linked list, freeing from the malloced (t[-1]) address.*/
   p = t;
   while(p != (struct huft *) ((void *) 0)) {
      q = (--p)->v.t;
      clava_dcg_global[ 193 ]++;
      free((char *) p);
      p = q;
   }
   
   return 0;
}

int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) {
   /*literal/length and distance decoder tables*/
   /*number of bits decoded by tl[] and td[]*/
   /*inflate (decompress) the codes in a deflated (compressed) block.
   Return an error code or zero if it all goes ok.*/
   register unsigned int e;
   /*table entry flag/number of extra bits*/
   unsigned int n, d;
   /*length and index for copy*/
   unsigned int w;
   /*current window position*/
   struct huft *t;
   /*pointer to table entry*/
   unsigned int ml, md;
   /*masks for bl and bd bits*/
   register ulg b;
   /*bit buffer*/
   register unsigned int k;
   /*number of bits in bit buffer*/
   /*make local copies of globals*/
   b = bb;
   /*initialize bit buffer*/
   k = bk;
   w = outcnt;
   /*initialize window position*/
   /*inflate the coded data*/
   ml = mask_bits[bl];
   /*precompute masks for speed*/
   md = mask_bits[bd];
   for(;;) {
      /*do until end of block*/
      {
         while(k < ((unsigned int) bl)) {
            clava_dcg_global[ 194 ]++;
            b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
            k += 8;
         }
      }
      if((e = (t = tl + ((unsigned int) b & ml))->e) > 16) do  {
         if(e == 99) 
         return 1;
         {
            b >>= (t->b);
            k -= (t->b);
         }
         e -= 16;
         {
            while(k < (e)) {
               clava_dcg_global[ 194 ]++;
               b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
               k += 8;
            }
         }
      }
      while ((e = (t = t->v.t + ((unsigned int) b & mask_bits[e]))->e) > 16);
      {
         b >>= (t->b);
         k -= (t->b);
      }
      if(e == 16) {
         /*then it's a literal*/
         window[w++] = (uch) t->v.n;
         ;
         if(w == 0x8000) {
            clava_dcg_global[ 195 ]++;
            (outcnt = (w) , flush_window());
            w = 0;
         }
      }
      else {
         /*it's an EOB or a length*/
         /*exit if end of block*/
         if(e == 15) break;
         /*get length of block to copy*/
         {
            while(k < (e)) {
               clava_dcg_global[ 194 ]++;
               b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
               k += 8;
            }
         }
         n = t->v.n + ((unsigned int) b & mask_bits[e]);
         {
            b >>= (e);
            k -= (e);
         }
         ;
         /*decode distance of block to copy*/
         {
            while(k < ((unsigned int) bd)) {
               clava_dcg_global[ 194 ]++;
               b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
               k += 8;
            }
         }
         if((e = (t = td + ((unsigned int) b & md))->e) > 16) do  {
            if(e == 99) 
            return 1;
            {
               b >>= (t->b);
               k -= (t->b);
            }
            e -= 16;
            {
               while(k < (e)) {
                  clava_dcg_global[ 194 ]++;
                  b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
                  k += 8;
               }
            }
         }
         while ((e = (t = t->v.t + ((unsigned int) b & mask_bits[e]))->e) > 16);
         {
            b >>= (t->b);
            k -= (t->b);
         }
         {
            while(k < (e)) {
               clava_dcg_global[ 194 ]++;
               b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
               k += 8;
            }
         }
         d = w - t->v.n - ((unsigned int) b & mask_bits[e]);
         {
            b >>= (e);
            k -= (e);
         }
         ;
         /*do the copy*/
         do  {
            n -= (e = (e = 0x8000 - ((d &= 0x8000 - 1) > w ? d : w)) > n ? n : e);
            if(w - d >= e) {
               /*(this test assumes unsigned comparison)*/
               clava_dcg_global[ 196 ]++;
               memcpy(window + w, window + d, e);
               w += e;
               d += e;
            }
            else {
               /*do it slow to avoid memcpy() overlap*/
               /*!NOMEMCPY*/
               do  {
                  window[w++] = window[d++];
                  ;
               }
               while (--e);
            }
            if(w == 0x8000) {
               clava_dcg_global[ 195 ]++;
               (outcnt = (w) , flush_window());
               w = 0;
            }
         }
         while (n);
      }
   }
   /*restore the globals from the locals*/
   outcnt = w;
   /*restore global window pointer*/
   bb = b;
   /*restore global bit buffer*/
   bk = k;
   /*done*/
   
   return 0;
}

int inflate_stored() {
   /*"decompress" an inflated type 0 (stored) block.*/
   unsigned int n;
   /*number of bytes in block*/
   unsigned int w;
   /*current window position*/
   register ulg b;
   /*bit buffer*/
   register unsigned int k;
   /*number of bits in bit buffer*/
   /*make local copies of globals*/
   b = bb;
   /*initialize bit buffer*/
   k = bk;
   w = outcnt;
   /*initialize window position*/
   /*go to byte boundary*/
   n = k & 7;
   {
      b >>= (n);
      k -= (n);
   }
   ;
   /*get the length and its complement*/
   {
      while(k < (16)) {
         clava_dcg_global[ 197 ]++;
         b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
         k += 8;
      }
   }
   n = ((unsigned int) b & 0xffff);
   {
      b >>= (16);
      k -= (16);
   }
   {
      while(k < (16)) {
         clava_dcg_global[ 197 ]++;
         b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
         k += 8;
      }
   }
   if(n != (unsigned int) ((~b) & 0xffff)) 
   return 1;
   /*error in compressed data*/
   {
      b >>= (16);
      k -= (16);
   }
   /*read and output the compressed data*/
   while(n--) {
      {
         while(k < (8)) {
            clava_dcg_global[ 197 ]++;
            b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
            k += 8;
         }
      }
      window[w++] = (uch) b;
      if(w == 0x8000) {
         clava_dcg_global[ 198 ]++;
         (outcnt = (w) , flush_window());
         w = 0;
      }
      {
         b >>= (8);
         k -= (8);
      }
   }
   /*restore the globals from the locals*/
   outcnt = w;
   /*restore global window pointer*/
   bb = b;
   /*restore global bit buffer*/
   bk = k;
   
   return 0;
}

int inflate_fixed() {
   /*decompress an inflated type 1 (fixed Huffman codes) block.  We should
   either replace this with a custom decoder, or at least precompute the
   Huffman tables.*/
   int i;
   /*temporary variable*/
   struct huft *tl;
   /*literal/length code table*/
   struct huft *td;
   /*distance code table*/
   int bl;
   /*lookup bits for tl*/
   int bd;
   /*lookup bits for td*/
   unsigned int l[288];
   /*length list for huft_build*/
   /*set up literal table*/
   for(i = 0; i < 144; i++) l[i] = 8;
   for(; i < 256; i++) l[i] = 9;
   for(; i < 280; i++) l[i] = 7;
   for(; i < 288; i++) {
      /*make a complete, but wrong code set*/
      l[i] = 8;
   }
   bl = 7;
   clava_dcg_global[ 199 ]++;
   if((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0) 
   return i;
   /*set up distance table*/
   for(i = 0; i < 30; i++) {
      /*make an incomplete code set*/
      l[i] = 5;
   }
   bd = 5;
   clava_dcg_global[ 199 ]++;
   if((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1) {
      clava_dcg_global[ 200 ]++;
      huft_free(tl);
      
      return i;
   }
   /*decompress until an end-of-block code*/
   clava_dcg_global[ 201 ]++;
   if(inflate_codes(tl, td, bl, bd)) 
   return 1;
   /*free the decoding tables, return*/
   clava_dcg_global[ 200 ]++;
   huft_free(tl);
   clava_dcg_global[ 200 ]++;
   huft_free(td);
   
   return 0;
}

int inflate_dynamic() {
   /*decompress an inflated type 2 (dynamic Huffman codes) block.*/
   int i;
   /*temporary variables*/
   unsigned int j;
   unsigned int l;
   /*last length*/
   unsigned int m;
   /*mask for bit lengths table*/
   unsigned int n;
   /*number of lengths to get*/
   unsigned int w;
   /*current window position*/
   struct huft *tl;
   /*literal/length code table*/
   struct huft *td;
   /*distance code table*/
   int bl;
   /*lookup bits for tl*/
   int bd;
   /*lookup bits for td*/
   unsigned int nb;
   /*number of bit length codes*/
   unsigned int nl;
   /*number of literal/length codes*/
   unsigned int nd;
   /*number of distance codes*/
   /*literal/length and distance code lengths*/
   unsigned int ll[316];
   /*literal/length and distance code lengths*/
   register ulg b;
   /*bit buffer*/
   register unsigned int k;
   /*number of bits in bit buffer*/
   /*make local bit buffer*/
   b = bb;
   k = bk;
   w = outcnt;
   /*read in table lengths*/
   {
      while(k < (5)) {
         clava_dcg_global[ 202 ]++;
         b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
         k += 8;
      }
   }
   nl = 257 + ((unsigned int) b & 0x1f);
   /*number of literal/length codes*/
   {
      b >>= (5);
      k -= (5);
   }
   {
      while(k < (5)) {
         clava_dcg_global[ 202 ]++;
         b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
         k += 8;
      }
   }
   nd = 1 + ((unsigned int) b & 0x1f);
   /*number of distance codes*/
   {
      b >>= (5);
      k -= (5);
   }
   {
      while(k < (4)) {
         clava_dcg_global[ 202 ]++;
         b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
         k += 8;
      }
   }
   nb = 4 + ((unsigned int) b & 0xf);
   /*number of bit length codes*/
   {
      b >>= (4);
      k -= (4);
   }
   if(nl > 286 || nd > 30) 
   return 1;
   /*bad lengths*/
   /*read in bit-length-code lengths*/
   for(j = 0; j < nb; j++) {
      {
         while(k < (3)) {
            clava_dcg_global[ 202 ]++;
            b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
            k += 8;
         }
      }
      ll[border[j]] = (unsigned int) b & 7;
      {
         b >>= (3);
         k -= (3);
      }
   }
   for(; j < 19; j++) ll[border[j]] = 0;
   /*build decoding table for trees--single level, 7 bit lookup*/
   bl = 7;
   clava_dcg_global[ 203 ]++;
   if((i = huft_build(ll, 19, 19, ((void *) 0), ((void *) 0), &tl, &bl)) != 0) {
      if(i == 1) {
         clava_dcg_global[ 204 ]++;
         huft_free(tl);
      }
      
      return i;
      /*incomplete code set*/
   }
   if(tl == ((void *) 0)) {
      /*Grrrhhh*/
      
      return 2;
   }
   /*read in literal and distance code lengths*/
   n = nl + nd;
   m = mask_bits[bl];
   i = l = 0;
   while((unsigned int) i < n) {
      {
         while(k < ((unsigned int) bl)) {
            clava_dcg_global[ 202 ]++;
            b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
            k += 8;
         }
      }
      j = (td = tl + ((unsigned int) b & m))->b;
      {
         b >>= (j);
         k -= (j);
      }
      j = td->v.n;
      if(j < 16) {
         /*length of code in bits (0..15)*/
         ll[i++] = l = j;
      }
      else {
         /*save last length in l*/
         if(j == 16) {
            /*repeat last length 3 to 6 times*/
            {
               while(k < (2)) {
                  clava_dcg_global[ 202 ]++;
                  b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
                  k += 8;
               }
            }
            j = 3 + ((unsigned int) b & 3);
            {
               b >>= (2);
               k -= (2);
            }
            if((unsigned int) i + j > n) 
            return 1;
            while(j--) ll[i++] = l;
         }
         else if(j == 17) {
            /*3 to 10 zero length codes*/
            {
               while(k < (3)) {
                  clava_dcg_global[ 202 ]++;
                  b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
                  k += 8;
               }
            }
            j = 3 + ((unsigned int) b & 7);
            {
               b >>= (3);
               k -= (3);
            }
            if((unsigned int) i + j > n) 
            return 1;
            while(j--) ll[i++] = 0;
            l = 0;
         }
         else {
            /*j == 18: 11 to 138 zero length codes*/
            {
               while(k < (7)) {
                  clava_dcg_global[ 202 ]++;
                  b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
                  k += 8;
               }
            }
            j = 11 + ((unsigned int) b & 0x7f);
            {
               b >>= (7);
               k -= (7);
            }
            if((unsigned int) i + j > n) 
            return 1;
            while(j--) ll[i++] = 0;
            l = 0;
         }
      }
   }
   /*free decoding table for trees*/
   clava_dcg_global[ 204 ]++;
   huft_free(tl);
   /*restore the global bit buffer*/
   bb = b;
   bk = k;
   /*build the decoding tables for literal/length and distance codes*/
   bl = lbits;
   clava_dcg_global[ 203 ]++;
   if((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0) {
      if(i == 1) {
         clava_dcg_global[ 205 ]++;
         fprintf(stderr, " incomplete literal tree\n");
         clava_dcg_global[ 204 ]++;
         huft_free(tl);
      }
      
      return i;
      /*incomplete code set*/
   }
   bd = dbits;
   clava_dcg_global[ 203 ]++;
   if((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0) {
      if(i == 1) {
         clava_dcg_global[ 205 ]++;
         fprintf(stderr, " incomplete distance tree\n");
         clava_dcg_global[ 204 ]++;
         huft_free(td);
      }
      clava_dcg_global[ 204 ]++;
      huft_free(tl);
      
      return i;
      /*incomplete code set*/
   }
   /*decompress until an end-of-block code*/
   clava_dcg_global[ 206 ]++;
   if(inflate_codes(tl, td, bl, bd)) 
   return 1;
   /*free the decoding tables, return*/
   clava_dcg_global[ 204 ]++;
   huft_free(tl);
   clava_dcg_global[ 204 ]++;
   huft_free(td);
   
   return 0;
}

int inflate_block(int *e) {
   /*last block flag*/
   /*decompress an inflated block*/
   unsigned int t;
   /*block type*/
   unsigned int w;
   /*current window position*/
   register ulg b;
   /*bit buffer*/
   register unsigned int k;
   /*number of bits in bit buffer*/
   /*make local bit buffer*/
   b = bb;
   k = bk;
   w = outcnt;
   /*read in last block bit*/
   {
      while(k < (1)) {
         clava_dcg_global[ 207 ]++;
         b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
         k += 8;
      }
   }
   *e = (int) b & 1;
   {
      b >>= (1);
      k -= (1);
   }
   /*read in block type*/
   {
      while(k < (2)) {
         clava_dcg_global[ 207 ]++;
         b |= ((ulg) (uch) (inptr < insize ? inbuf[inptr++] : (outcnt = w , fill_inbuf(0)))) << k;
         k += 8;
      }
   }
   t = (unsigned int) b & 3;
   {
      b >>= (2);
      k -= (2);
   }
   /*restore the global bit buffer*/
   bb = b;
   bk = k;
   /*inflate that block type*/
   if(t == 2) {
      clava_dcg_global[ 208 ]++;
      
      return inflate_dynamic();
   }
   if(t == 0) {
      clava_dcg_global[ 209 ]++;
      
      return inflate_stored();
   }
   if(t == 1) {
      clava_dcg_global[ 210 ]++;
      
      return inflate_fixed();
   }
   /*bad block type*/
   
   return 2;
}

int inflate() {
   /*decompress an inflated entry*/
   int e;
   /*last block flag*/
   int r;
   /*result code*/
   unsigned int h;
   /*maximum struct huft's malloc'ed*/
   /*initialize window, bit buffer*/
   outcnt = 0;
   bk = 0;
   bb = 0;
   /*decompress until the last block*/
   h = 0;
   do  {
      hufts = 0;
      clava_dcg_global[ 211 ]++;
      if((r = inflate_block(&e)) != 0) 
      return r;
      if(hufts > h) h = hufts;
   }
   while (!e);
   /*Undo too much lookahead. The next read will be byte aligned so we
   * can discard unused bits in the last meaningful byte.
   */
   while(bk >= 8) {
      bk -= 8;
      inptr--;
   }
   /*flush out slide*/
   clava_dcg_global[ 212 ]++;
   (outcnt = (outcnt) , flush_window());
   /*return success*/
   /*DEBUG*/
   
   return 0;
}

/*lzw.c -- compress files in LZW format.
* This is a dummy version avoiding patent problems.
*/

static int msg_done = 0;
/*Compress in to out with lzw method.*/
int lzw(int in, int out) {
   if(msg_done) 
   return 1;
   msg_done = 1;
   clava_dcg_global[ 213 ]++;
   fprintf(stderr, "output in compress .Z format not supported\n");
   if(in != out) {
      /*avoid warnings on unused variables*/
      exit_code = 1;
   }
   
   return 1;
}

/*trees.c -- output deflated data using Huffman coding
* Copyright (C) 1992-1993 Jean-loup Gailly
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

/*
*  PURPOSE
*
*      Encode various sets of source values using variable-length
*      binary code trees.
*
*  DISCUSSION
*
*      The PKZIP "deflation" process uses several Huffman trees. The more
*      common source values are represented by shorter bit sequences.
*
*      Each code tree is stored in the ZIP file in a compressed form
*      which is itself a Huffman encoding of the lengths of
*      all the code strings (in ascending order by source values).
*      The actual code strings are reconstructed from the lengths in
*      the UNZIP process, as described in the "application note"
*      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.
*
*  REFERENCES
*
*      Lynch, Thomas J.
*          Data Compression:  Techniques and Applications, pp. 53-55.
*          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.
*
*      Storer, James A.
*          Data Compression:  Methods and Theory, pp. 49-50.
*          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
*
*      Sedgewick, R.
*          Algorithms, p290.
*          Addison-Wesley, 1983. ISBN 0-201-06672-6.
*
*  INTERFACE
*
*      void ct_init (ush *attr, int *methodp)
*          Allocate the match buffer, initialize the various tables and save
*          the location of the internal file attribute (ascii/binary) and
*          method (DEFLATE/STORE)
*
*      void ct_tally (int dist, int lc);
*          Save the match info and tally the frequency counts.
*
*      off_t flush_block (char *buf, ulg stored_len, int pad, int eof)
*          Determine the best encoding for the current block: dynamic trees,
*          static trees or store, and output the encoded block to the zip
*          file. If pad is set, pads the block to the next
*          byte. Returns the total compressed length for the file so
*          far.
**/

/*===========================================================================
* Constants
*/

/*All codes must not exceed MAX_BITS bits*/

/*Bit length codes must not exceed MAX_BL_BITS bits*/

/*number of length codes, not counting the special END_BLOCK code*/

/*number of literal bytes 0..255*/

/*end of block literal code*/

/*number of Literal or Length codes, including the END_BLOCK code*/

/*number of distance codes*/

/*number of codes used to transfer the bit lengths*/

static int extra_lbits[29] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
/*extra bits for each length code*/

static int extra_dbits[30] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
/*extra bits for each distance code*/

static int extra_blbits[19] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7};
/*extra bits for each bit length code*/
/*The three kinds of block type*/
/*Sizes of match buffers for literals/lengths and distances.  There are
* 4 reasons for limiting LIT_BUFSIZE to 64K:
*   - frequencies can be kept in 16 bit counters
*   - if compression is not successful for the first block, all input data is
*     still in the window so we can still emit a stored block even when input
*     comes from standard input.  (This can also be done for all blocks if
*     LIT_BUFSIZE is not greater than 32K.)
*   - if compression is not successful for a file smaller than 64K, we can
*     even emit a stored file instead of a stored block (saving 5 bytes).
*   - creating new Huffman trees less frequently may not provide fast
*     adaptation to changes in the input data statistics. (Take for
*     example a binary file with poorly compressible code followed by
*     a highly compressible string table.) Smaller buffer sizes give
*     fast adaptation but have of course the overhead of transmitting trees
*     more frequently.
*   - I can't count above 4
* The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save
* memory at the expense of compression). Some optimizations would be possible
* if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
*/
/*repeat previous bit length 3-6 times (2 bits of repeat count)*/
/*repeat a zero length 3-10 times  (3 bits of repeat count)*/
/*repeat a zero length 11-138 times  (7 bits of repeat count)*/
/*===========================================================================
* Local data
*/
/*Data structure describing a single value and its code string.*/

struct ct_data {
   
   union anon_gzip_c_5803 {
      ush freq;
      /*frequency count*/
      ush code;
   };
   
   union anon_gzip_c_5803 fc;
   /*bit string*/
   
   union anon_gzip_c_5807 {
      ush dad;
      /*father node in Huffman tree*/
      ush len;
   };
   
   union anon_gzip_c_5807 dl;
};

typedef struct ct_data ct_data;
/*length of bit string*/

/*maximum heap size*/

static ct_data dyn_ltree[573];
/*literal and length tree*/

static ct_data dyn_dtree[61];
/*distance tree*/

static ct_data static_ltree[288];
/*The static literal tree. Since the bit lengths are imposed, there is no
* need for the L_CODES extra codes used during heap construction. However
* The codes 286 and 287 are needed to build a canonical tree (see ct_init
* below).
*/

static ct_data static_dtree[30];
/*The static distance tree. (Actually a trivial tree since all codes use
* 5 bits.)
*/

static ct_data bl_tree[39];
/*Huffman tree for the bit lengths*/

struct tree_desc {
   ct_data *dyn_tree;
   /*the dynamic tree*/
   ct_data *static_tree;
   /*corresponding static tree or NULL*/
   int *extra_bits;
   /*extra bits for each code or NULL*/
   int extra_base;
   /*base index for extra_bits*/
   int elems;
   /*max number of elements in the tree*/
   int max_length;
   /*max bit length for the codes*/
   int max_code;
};

typedef struct tree_desc tree_desc;
/*largest code with non zero frequency*/

static tree_desc l_desc = {dyn_ltree, static_ltree, extra_lbits, 256 + 1, (256 + 1 + 29), 15, 0};
static tree_desc d_desc = {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
static tree_desc bl_desc = {bl_tree, (ct_data *) 0, extra_blbits, 0, 19, 7, 0};
static ush bl_count[16];
/*number of codes at each bit length for an optimal tree*/

static uch bl_order[19] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
/*The lengths of the bit length codes are sent in order of decreasing
* probability, to avoid transmitting the lengths for unused bit length codes.
*/

static int heap[573];
/*heap used to build the Huffman trees*/

static int heap_len;
/*number of elements in the heap*/

static int heap_max;
/*element of largest frequency*/

/*The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
* The same heap array is used to build all trees.
*/

static uch depth[573];
/*Depth of each subtree used as tie breaker for trees of equal frequency*/

static uch length_code[256];
/*length code for each normalized match length (0 == MIN_MATCH)*/

static uch dist_code[512];
/*distance codes. The first 256 values correspond to the distances
* 3 .. 258, the last 256 values correspond to the top 8 bits of
* the 15 bit distances.
*/

static int base_length[29];
/*First normalized length for each code (0 = MIN_MATCH)*/

static int base_dist[30];
/*First normalized distance for each code (0 = distance of 1)*/

/*DECLARE(uch, l_buf, LIT_BUFSIZE);  buffer for literals or lengths*/

/*DECLARE(ush, d_buf, DIST_BUFSIZE); buffer for distances*/

static uch flag_buf[4096];
/*flag_buf is a bit array distinguishing literals from lengths in
* l_buf, thus indicating the presence or absence of a distance.
*/

static unsigned int last_lit;
/*running index in l_buf*/

static unsigned int last_dist;
/*running index in d_buf*/

static unsigned int last_flags;
/*running index in flag_buf*/

static uch flags;
/*current flags not yet saved in flag_buf*/

static uch flag_bit;
/*current bit used in flags*/

/*bits are filled in flags starting at bit 0 (least significant).
* Note: these flags are overkill in the current code since we don't
* take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
*/

static ulg opt_len;
/*bit length of current block with optimal trees*/

static ulg static_len;
/*bit length of current block with static trees*/

static off_t compressed_len;
/*total bit length of compressed file*/

static off_t input_len;
/*total byte length of input file*/

/*input_len is for debugging only since we can get it by other means.*/

ush *file_type;
/*pointer to UNKNOWN, BINARY or ASCII*/

int *file_method;
/*pointer to DEFLATE or STORE*/

/*bit length of the compressed data*/

extern long block_start;
/*window offset of current block*/

extern unsigned int strstart;
/*window offset of current string*/
/*===========================================================================
* Local (static) routines in this file.
*/
static void init_block();
static void pqdownheap(ct_data *tree, int k);
static void gen_bitlen(tree_desc *desc);
static void gen_codes(ct_data *tree, int max_code);
static void build_tree_1(tree_desc *desc);
static void scan_tree(ct_data *tree, int max_code);
static void send_tree(ct_data *tree, int max_code);
static int build_bl_tree();
static void send_all_trees(int lcodes, int dcodes, int blcodes);
static void compress_block(ct_data *ltree, ct_data *dtree);
static void set_file_type();
/*Send a code of the given tree. c and tree must not have side effects*/
/*DEBUG*/
/*Mapping from a distance to a distance code. dist is the distance - 1 and
* must not have side effects. dist_code[256] and dist_code[257] are never
* used.
*/
/*the arguments must not have side effects*/
/*===========================================================================
* Allocate the match buffer, initialize the various tables and save the
* location of the internal file attribute (ascii/binary) and method
* (DEFLATE/STORE).
*/
void ct_init(ush *attr, int *methodp) {
   /*pointer to internal file attribute*/
   /*pointer to compression method*/
   int n;
   /*iterates over tree elements*/
   int bits;
   /*bit counter*/
   int length;
   /*length value*/
   int code;
   /*code value*/
   int dist;
   /*distance index*/
   file_type = attr;
   file_method = methodp;
   compressed_len = input_len = 0L;
   if(static_dtree[0].dl.len != 0) 
   return;
   /*ct_init already called*/
   /*Initialize the mapping length (0..255) -> length code (0..28)*/
   length = 0;
   for(code = 0; code < 29 - 1; code++) {
      base_length[code] = length;
      for(n = 0; n < (1 << extra_lbits[code]); n++) {
         length_code[length++] = (uch) code;
      }
   }
   ;
   /*Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
   length_code[length - 1] = (uch) code;
   /*Initialize the mapping dist (0..32K) -> dist code (0..29)*/
   dist = 0;
   for(code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for(n = 0; n < (1 << extra_dbits[code]); n++) {
         dist_code[dist++] = (uch) code;
      }
   }
   ;
   dist >>= 7;
   /*from now on, all distances are divided by 128*/
   for(; code < 30; code++) {
      base_dist[code] = dist << 7;
      for(n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
         dist_code[256 + dist++] = (uch) code;
      }
   }
   ;
   /*Construct the codes of the static literal tree*/
   for(bits = 0; bits <= 15; bits++) bl_count[bits] = 0;
   n = 0;
   while(n <= 143) static_ltree[n++].dl.len = 8 , bl_count[8]++;
   while(n <= 255) static_ltree[n++].dl.len = 9 , bl_count[9]++;
   while(n <= 279) static_ltree[n++].dl.len = 7 , bl_count[7]++;
   while(n <= 287) static_ltree[n++].dl.len = 8 , bl_count[8]++;
   /*Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
   clava_dcg_global[ 214 ]++;
   gen_codes((ct_data *) static_ltree, (256 + 1 + 29) + 1);
   /*The static distance tree is trivial:*/
   for(n = 0; n < 30; n++) {
      static_dtree[n].dl.len = 5;
      clava_dcg_global[ 215 ]++;
      static_dtree[n].fc.code = bi_reverse(n, 5);
   }
   /*Initialize the first block of the first file:*/
   clava_dcg_global[ 216 ]++;
   init_block();
}

/*===========================================================================
* Initialize a new block.
*/
static void init_block() {
   int n;
   /*iterates over tree elements*/
   /*Initialize the trees.*/
   for(n = 0; n < (256 + 1 + 29); n++) dyn_ltree[n].fc.freq = 0;
   for(n = 0; n < 30; n++) dyn_dtree[n].fc.freq = 0;
   for(n = 0; n < 19; n++) bl_tree[n].fc.freq = 0;
   dyn_ltree[256].fc.freq = 1;
   opt_len = static_len = 0L;
   last_lit = last_dist = last_flags = 0;
   flags = 0;
   flag_bit = 1;
}

/*Index within the heap array of least frequent node in the Huffman tree*/
/*===========================================================================
* Remove the smallest element from the heap and recreate the heap with
* one less element. Updates heap and heap_len.
*/
/*===========================================================================
* Compares to subtrees, using the tree depth as tie breaker when
* the subtrees have equal frequency. This minimizes the worst case length.
*/
/*===========================================================================
* Restore the heap property by moving down the tree starting at node k,
* exchanging a node with the smallest of its two sons if necessary, stopping
* when the heap property is re-established (each father smaller than its
* two sons).
*/
static void pqdownheap(ct_data *tree, int k) {
   /*the tree to restore*/
   /*node to move down*/
   int v = heap[k];
   int j = k << 1;
   /*left son of k*/
   while(j <= heap_len) {
      /*Set j to the smallest of the two sons:*/
      if(j < heap_len && (tree[heap[j + 1]].fc.freq < tree[heap[j]].fc.freq || (tree[heap[j + 1]].fc.freq == tree[heap[j]].fc.freq && depth[heap[j + 1]] <= depth[heap[j]]))) j++;
      /*Exit if v is smaller than both sons*/
      if((tree[v].fc.freq < tree[heap[j]].fc.freq || (tree[v].fc.freq == tree[heap[j]].fc.freq && depth[v] <= depth[heap[j]]))) break;
      /*Exchange v with the smallest son*/
      heap[k] = heap[j];
      k = j;
      /*And continue down the tree, setting j to the left son of k*/
      j <<= 1;
   }
   heap[k] = v;
}

/*===========================================================================
* Compute the optimal bit lengths for a tree and update the total bit length
* for the current block.
* IN assertion: the fields freq and dad are set, heap[heap_max] and
*    above are the tree nodes sorted by increasing frequency.
* OUT assertions: the field len is set to the optimal bit length, the
*     array bl_count contains the frequencies for each bit length.
*     The length opt_len is updated; static_len is also updated if stree is
*     not null.
*/
static void gen_bitlen(tree_desc *desc) {
   /*the tree descriptor*/
   ct_data *tree = desc->dyn_tree;
   int *extra = desc->extra_bits;
   int base = desc->extra_base;
   int max_code = desc->max_code;
   int max_length = desc->max_length;
   ct_data *stree = desc->static_tree;
   int h;
   /*heap index*/
   int n, m;
   /*iterate over the tree elements*/
   int bits;
   /*bit length*/
   int xbits;
   /*extra bits*/
   ush f;
   /*frequency*/
   int overflow = 0;
   /*number of elements with bit length too large*/
   for(bits = 0; bits <= 15; bits++) bl_count[bits] = 0;
   /*In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
   tree[heap[heap_max]].dl.len = 0;
   /*root of the heap*/
   for(h = heap_max + 1; h < (2 * (256 + 1 + 29) + 1); h++) {
      n = heap[h];
      bits = tree[tree[n].dl.dad].dl.len + 1;
      if(bits > max_length) bits = max_length , overflow++;
      tree[n].dl.len = (ush) bits;
      /*We overwrite tree[n].Dad which is no longer needed*/
      if(n > max_code) continue;
      /*not a leaf node*/
      bl_count[bits]++;
      xbits = 0;
      if(n >= base) xbits = extra[n - base];
      f = tree[n].fc.freq;
      opt_len += (ulg) f * (bits + xbits);
      if(stree) static_len += (ulg) f * (stree[n].dl.len + xbits);
   }
   if(overflow == 0) 
   return;
   ;
   /*This happens for example on obj2 and pic of the Calgary corpus*/
   /*Find the first bit length which could increase:*/
   do  {
      bits = max_length - 1;
      while(bl_count[bits] == 0) bits--;
      bl_count[bits]--;
      /*move one leaf down the tree*/
      bl_count[bits + 1] += 2;
      /*move one overflow item as its brother*/
      bl_count[max_length]--;
      /*The brother of the overflow item also moves one step up,
      * but this does not affect bl_count[max_length]
      */
      overflow -= 2;
   }
   while (overflow > 0);
   /*Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
   for(bits = max_length; bits != 0; bits--) {
      n = bl_count[bits];
      while(n != 0) {
         m = heap[--h];
         if(m > max_code) continue;
         if(tree[m].dl.len != (unsigned int) bits) {
            ;
            opt_len += ((long) bits - (long) tree[m].dl.len) * (long) tree[m].fc.freq;
            tree[m].dl.len = (ush) bits;
         }
         n--;
      }
   }
}

/*===========================================================================
* Generate the codes for a given tree and bit counts (which need not be
* optimal).
* IN assertion: the array bl_count contains the bit length statistics for
* the given tree and the field len is set for all tree elements.
* OUT assertion: the field code is set for all tree elements of non
*     zero code length.
*/
static void gen_codes(ct_data *tree, int max_code) {
   /*the tree to decorate*/
   /*largest code with non zero frequency*/
   ush next_code[16];
   /*next code value for each bit length*/
   ush code = 0;
   /*running code value*/
   int bits;
   /*bit index*/
   int n;
   /*code index*/
   /*The distribution counts are first used to generate the code values
   * without bit reversal.
   */
   for(bits = 1; bits <= 15; bits++) {
      next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
   }
   /*Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
   ;
   ;
   for(n = 0; n <= max_code; n++) {
      int len = tree[n].dl.len;
      if(len == 0) continue;
      /*Now reverse the bits*/
      clava_dcg_global[ 217 ]++;
      tree[n].fc.code = bi_reverse(next_code[len]++, len);
      ;
   }
}

/*===========================================================================
* Construct one Huffman tree and assigns the code bit strings and lengths.
* Update the total bit length for the current block.
* IN assertion: the field freq is set for all tree elements.
* OUT assertions: the fields len and code are set to the optimal bit length
*     and corresponding code. The length opt_len is updated; static_len is
*     also updated if stree is not null. The field max_code is set.
*/
static void build_tree_1(tree_desc *desc) {
   /*the tree descriptor*/
   ct_data *tree = desc->dyn_tree;
   ct_data *stree = desc->static_tree;
   int elems = desc->elems;
   int n, m;
   /*iterate over heap elements*/
   int max_code = -1;
   /*largest code with non zero frequency*/
   int node = elems;
   /*next internal node of the tree*/
   /*Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
   heap_len = 0 , heap_max = (2 * (256 + 1 + 29) + 1);
   for(n = 0; n < elems; n++) {
      if(tree[n].fc.freq != 0) {
         heap[++heap_len] = max_code = n;
         depth[n] = 0;
      }
      else {
         tree[n].dl.len = 0;
      }
   }
   /*The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
   while(heap_len < 2) {
      int new = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
      tree[new].fc.freq = 1;
      depth[new] = 0;
      opt_len--;
      if(stree) static_len -= stree[new].dl.len;
      /*new is 0 or 1 so it does not have extra bits*/
   }
   desc->max_code = max_code;
   /*The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
   for(n = heap_len / 2; n >= 1; n--) {
      clava_dcg_global[ 218 ]++;
      pqdownheap(tree, n);
   }
   /*Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
   do  {
      {
         n = heap[1];
         heap[1] = heap[heap_len--];
         clava_dcg_global[ 218 ]++;
         pqdownheap(tree, 1);
      }
      ;
      /*n = node of least frequency*/
      m = heap[1];
      /*m = node of next least frequency*/
      heap[--heap_max] = n;
      /*keep the nodes sorted by frequency*/
      heap[--heap_max] = m;
      /*Create a new node father of n and m*/
      tree[node].fc.freq = tree[n].fc.freq + tree[m].fc.freq;
      depth[node] = (uch) ((depth[n] >= depth[m] ? depth[n] : depth[m]) + 1);
      tree[n].dl.dad = tree[m].dl.dad = (ush) node;
      /*and insert the new node in the heap*/
      heap[1] = node++;
      clava_dcg_global[ 218 ]++;
      pqdownheap(tree, 1);
   }
   while (heap_len >= 2);
   heap[--heap_max] = heap[1];
   /*At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
   clava_dcg_global[ 219 ]++;
   gen_bitlen((tree_desc *) desc);
   /*The field len is now set, we can generate the bit codes*/
   clava_dcg_global[ 220 ]++;
   gen_codes((ct_data *) tree, max_code);
}

/*===========================================================================
* Scan a literal or distance tree to determine the frequencies of the codes
* in the bit length tree. Updates opt_len to take into account the repeat
* counts. (The contribution of the bit length codes will be added later
* during the construction of bl_tree.)
*/
static void scan_tree(ct_data *tree, int max_code) {
   /*the tree to be scanned*/
   /*and its largest code of non zero frequency*/
   int n;
   /*iterates over all tree elements*/
   int prevlen = -1;
   /*last emitted length*/
   int curlen;
   /*length of current code*/
   int nextlen = tree[0].dl.len;
   /*length of next code*/
   int count = 0;
   /*repeat count of the current code*/
   int max_count = 7;
   /*max repeat count*/
   int min_count = 4;
   /*min repeat count*/
   if(nextlen == 0) max_count = 138 , min_count = 3;
   tree[max_code + 1].dl.len = (ush) 0xffff;
   /*guard*/
   for(n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[n + 1].dl.len;
      if(++count < max_count && curlen == nextlen) {
         continue;
      }
      else if(count < min_count) {
         bl_tree[curlen].fc.freq += count;
      }
      else if(curlen != 0) {
         if(curlen != prevlen) bl_tree[curlen].fc.freq++;
         bl_tree[16].fc.freq++;
      }
      else if(count <= 10) {
         bl_tree[17].fc.freq++;
      }
      else {
         bl_tree[18].fc.freq++;
      }
      count = 0;
      prevlen = curlen;
      if(nextlen == 0) {
         max_count = 138 , min_count = 3;
      }
      else if(curlen == nextlen) {
         max_count = 6 , min_count = 3;
      }
      else {
         max_count = 7 , min_count = 4;
      }
   }
}

/*===========================================================================
* Send a literal or distance tree in compressed form, using the codes in
* bl_tree.
*/
static void send_tree(ct_data *tree, int max_code) {
   /*the tree to be scanned*/
   /*and its largest code of non zero frequency*/
   int n;
   /*iterates over all tree elements*/
   int prevlen = -1;
   /*last emitted length*/
   int curlen;
   /*length of current code*/
   int nextlen = tree[0].dl.len;
   /*length of next code*/
   int count = 0;
   /*repeat count of the current code*/
   int max_count = 7;
   /*max repeat count*/
   int min_count = 4;
   /*min repeat count*/
   /*tree[max_code+1].Len = -1;*/
   if(nextlen == 0) max_count = 138 , min_count = 3;
   for(n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[n + 1].dl.len;
      if(++count < max_count && curlen == nextlen) {
         continue;
      }
      else if(count < min_count) {
         do  {
            clava_dcg_global[ 221 ]++;
            send_bits(bl_tree[curlen].fc.code, bl_tree[curlen].dl.len);
         }
         while (--count != 0);
      }
      else if(curlen != 0) {
         if(curlen != prevlen) {
            clava_dcg_global[ 221 ]++;
            send_bits(bl_tree[curlen].fc.code, bl_tree[curlen].dl.len);
            count--;
         }
         ;
         clava_dcg_global[ 221 ]++;
         send_bits(bl_tree[16].fc.code, bl_tree[16].dl.len);
         clava_dcg_global[ 221 ]++;
         send_bits(count - 3, 2);
      }
      else if(count <= 10) {
         clava_dcg_global[ 221 ]++;
         send_bits(bl_tree[17].fc.code, bl_tree[17].dl.len);
         clava_dcg_global[ 221 ]++;
         send_bits(count - 3, 3);
      }
      else {
         clava_dcg_global[ 221 ]++;
         send_bits(bl_tree[18].fc.code, bl_tree[18].dl.len);
         clava_dcg_global[ 221 ]++;
         send_bits(count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if(nextlen == 0) {
         max_count = 138 , min_count = 3;
      }
      else if(curlen == nextlen) {
         max_count = 6 , min_count = 3;
      }
      else {
         max_count = 7 , min_count = 4;
      }
   }
}

/*===========================================================================
* Construct the Huffman tree for the bit lengths and return the index in
* bl_order of the last bit length code to send.
*/
static int build_bl_tree() {
   int max_blindex;
   /*index of last bit length code of non zero freq*/
   /*Determine the bit length frequencies for literal and distance trees*/
   clava_dcg_global[ 222 ]++;
   scan_tree((ct_data *) dyn_ltree, l_desc.max_code);
   clava_dcg_global[ 222 ]++;
   scan_tree((ct_data *) dyn_dtree, d_desc.max_code);
   /*Build the bit length tree:*/
   clava_dcg_global[ 223 ]++;
   build_tree_1((tree_desc *) (&bl_desc));
   /*opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */
   /*Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
   for(max_blindex = 19 - 1; max_blindex >= 3; max_blindex--) {
      if(bl_tree[bl_order[max_blindex]].dl.len != 0) break;
   }
   /*Update opt_len to include the bit length tree and counts*/
   opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
   ;
   
   return max_blindex;
}

/*===========================================================================
* Send the header for a block using dynamic Huffman trees: the counts, the
* lengths of the bit length codes, the literal tree and the distance tree.
* IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
*/
static void send_all_trees(int lcodes, int dcodes, int blcodes) {
   /*number of codes for each tree*/
   int rank;
   /*index in bl_order*/
   ;
   ;
   ;
   clava_dcg_global[ 224 ]++;
   send_bits(lcodes - 257, 5);
   /*not +255 as stated in appnote.txt*/
   clava_dcg_global[ 224 ]++;
   send_bits(dcodes - 1, 5);
   clava_dcg_global[ 224 ]++;
   send_bits(blcodes - 4, 4);
   /*not -3 as stated in appnote.txt*/
   for(rank = 0; rank < blcodes; rank++) {
      ;
      clava_dcg_global[ 224 ]++;
      send_bits(bl_tree[bl_order[rank]].dl.len, 3);
   }
   clava_dcg_global[ 225 ]++;
   send_tree((ct_data *) dyn_ltree, lcodes - 1);
   /*send the literal tree*/
   clava_dcg_global[ 225 ]++;
   send_tree((ct_data *) dyn_dtree, dcodes - 1);
   /*send the distance tree*/
}

/*===========================================================================
* Determine the best encoding for the current block: dynamic trees, static
* trees or store, and output the encoded block to the zip file. This function
* returns the total compressed length for the file so far.
*/
off_t flush_block(char *buf, ulg stored_len, int pad, int eof) {
   /*input block, or NULL if too old*/
   /*length of input block*/
   /*pad output to byte boundary*/
   /*true if this is the last block for a file*/
   ulg opt_lenb, static_lenb;
   /*opt_len and static_len in bytes*/
   int max_blindex;
   /*index of last bit length code of non zero freq*/
   flag_buf[last_flags] = flags;
   /*Save the flags for the last 8 items*/
   /*Check if the file is ascii or binary*/
   if(*file_type == (ush) 0xffff) {
      clava_dcg_global[ 226 ]++;
      set_file_type();
   }
   /*Construct the literal and distance trees*/
   clava_dcg_global[ 227 ]++;
   build_tree_1((tree_desc *) (&l_desc));
   ;
   clava_dcg_global[ 227 ]++;
   build_tree_1((tree_desc *) (&d_desc));
   ;
   /*At this point, opt_len and static_len are the total bit lengths of
   * the compressed block data, excluding the tree representations.
   */
   /*Build the bit length tree for the above two trees, and get the index
   * in bl_order of the last bit length code to send.
   */
   clava_dcg_global[ 228 ]++;
   max_blindex = build_bl_tree();
   /*Determine the best encoding. Compute first the block length in bytes*/
   opt_lenb = (opt_len + 3 + 7) >> 3;
   static_lenb = (static_len + 3 + 7) >> 3;
   input_len += stored_len;
   /*for debugging only*/
   ;
   if(static_lenb <= opt_lenb) opt_lenb = static_lenb;
   /*If compression failed and this is the first and last block,
   * and if the zip file can be seeked (to rewrite the local header),
   * the whole file is transformed into a stored file:
   */
   /*force stored file*/
   if(stored_len <= opt_lenb && eof && compressed_len == 0L && 0) {
      /*Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there:*/
      if(buf == (char *) 0) {
         clava_dcg_global[ 229 ]++;
         error("block vanished");
      }
      clava_dcg_global[ 230 ]++;
      copy_block(buf, (unsigned int) stored_len, 0);
      /*without header*/
      compressed_len = stored_len << 3;
      *file_method = 0;
      /*force stored block*/
   }
   else if(stored_len + 4 <= opt_lenb && buf != (char *) 0) {
      /*4: two words for the lengths*/
      /*The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
      * Otherwise we can't have processed more than WSIZE input bytes since
      * the last block flush, because compression would have been
      * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
      * transform a block into a stored block.
      */
      clava_dcg_global[ 231 ]++;
      send_bits((0 << 1) + eof, 3);
      /*send block type*/
      compressed_len = (compressed_len + 3 + 7) & ~7L;
      compressed_len += (stored_len + 4) << 3;
      clava_dcg_global[ 230 ]++;
      copy_block(buf, (unsigned int) stored_len, 1);
      /*with header*/
      /*force static trees*/
   }
   else if(static_lenb == opt_lenb) {
      clava_dcg_global[ 231 ]++;
      send_bits((1 << 1) + eof, 3);
      clava_dcg_global[ 232 ]++;
      compress_block((ct_data *) static_ltree, (ct_data *) static_dtree);
      compressed_len += 3 + static_len;
   }
   else {
      clava_dcg_global[ 231 ]++;
      send_bits((2 << 1) + eof, 3);
      clava_dcg_global[ 233 ]++;
      send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
      clava_dcg_global[ 232 ]++;
      compress_block((ct_data *) dyn_ltree, (ct_data *) dyn_dtree);
      compressed_len += 3 + opt_len;
   }
   ;
   clava_dcg_global[ 234 ]++;
   init_block();
   if(eof) {
      ;
      clava_dcg_global[ 235 ]++;
      bi_windup();
      compressed_len += 7;
      /*align on byte boundary*/
   }
   else if(pad && (compressed_len % 8) != 0) {
      clava_dcg_global[ 231 ]++;
      send_bits((0 << 1) + eof, 3);
      /*send block type*/
      compressed_len = (compressed_len + 3 + 7) & ~7L;
      clava_dcg_global[ 230 ]++;
      copy_block(buf, 0, 1);
      /*with header*/
   }
   
   return compressed_len >> 3;
}

/*===========================================================================
* Save the match info and tally the frequency counts. Return true if
* the current block must be flushed.
*/
int ct_tally(int dist, int lc) {
   /*distance of matched string*/
   /*match length-MIN_MATCH or unmatched char (if dist==0)*/
   inbuf[last_lit++] = (uch) lc;
   if(dist == 0) {
      /*lc is the unmatched char*/
      dyn_ltree[lc].fc.freq++;
   }
   else {
      /*Here, lc is the match length - MIN_MATCH*/
      dist--;
      /*dist = match distance - 1*/
      ;
      dyn_ltree[length_code[lc] + 256 + 1].fc.freq++;
      dyn_dtree[((dist) < 256 ? dist_code[dist] : dist_code[256 + ((dist) >> 7)])].fc.freq++;
      d_buf[last_dist++] = (ush) dist;
      flags |= flag_bit;
   }
   flag_bit <<= 1;
   /*Output the flags if they fill a byte:*/
   if((last_lit & 7) == 0) {
      flag_buf[last_flags++] = flags;
      flags = 0 , flag_bit = 1;
   }
   /*Try to guess if it is profitable to stop the current block here*/
   if(level > 2 && (last_lit & 0xfff) == 0) {
      /*Compute an upper bound for the compressed length*/
      ulg out_length = (ulg) last_lit * 8L;
      ulg in_length = (ulg) strstart - block_start;
      int dcode;
      for(dcode = 0; dcode < 30; dcode++) {
         out_length += (ulg) dyn_dtree[dcode].fc.freq * (5L + extra_dbits[dcode]);
      }
      out_length >>= 3;
      ;
      if(last_dist < last_lit / 2 && out_length < in_length / 2) 
      return 1;
   }
   
   return (last_lit == 0x8000 - 1 || last_dist == 0x8000);
   /*We avoid equality with LIT_BUFSIZE because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

/*===========================================================================
* Send the block data compressed using the given Huffman trees
*/
static void compress_block(ct_data *ltree, ct_data *dtree) {
   /*literal tree*/
   /*distance tree*/
   unsigned int dist;
   /*distance of matched string*/
   int lc;
   /*match length or unmatched char (if dist == 0)*/
   unsigned int lx = 0;
   /*running index in l_buf*/
   unsigned int dx = 0;
   /*running index in d_buf*/
   unsigned int fx = 0;
   /*running index in flag_buf*/
   uch flag = 0;
   /*current flags*/
   unsigned int code;
   /*the code to send*/
   int extra;
   /*number of extra bits to send*/
   if(last_lit != 0) do  {
      if((lx & 7) == 0) flag = flag_buf[fx++];
      lc = inbuf[lx++];
      if((flag & 1) == 0) {
         clava_dcg_global[ 236 ]++;
         send_bits(ltree[lc].fc.code, ltree[lc].dl.len);
         /*send a literal byte*/
         ;
      }
      else {
         /*Here, lc is the match length - MIN_MATCH*/
         code = length_code[lc];
         clava_dcg_global[ 236 ]++;
         send_bits(ltree[code + 256 + 1].fc.code, ltree[code + 256 + 1].dl.len);
         /*send the length code*/
         extra = extra_lbits[code];
         if(extra != 0) {
            lc -= base_length[code];
            clava_dcg_global[ 236 ]++;
            send_bits(lc, extra);
            /*send the extra length bits*/
         }
         dist = d_buf[dx++];
         /*Here, dist is the match distance - 1*/
         code = ((dist) < 256 ? dist_code[dist] : dist_code[256 + ((dist) >> 7)]);
         ;
         clava_dcg_global[ 236 ]++;
         send_bits(dtree[code].fc.code, dtree[code].dl.len);
         /*send the distance code*/
         extra = extra_dbits[code];
         if(extra != 0) {
            dist -= base_dist[code];
            clava_dcg_global[ 236 ]++;
            send_bits(dist, extra);
            /*send the extra distance bits*/
         }
      }
      /*literal or match pair ?*/
      flag >>= 1;
   }
   while (lx < last_lit);
   clava_dcg_global[ 236 ]++;
   send_bits(ltree[256].fc.code, ltree[256].dl.len);
}

/*===========================================================================
* Set the file type to ASCII or BINARY, using a crude approximation:
* binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
* IN assertion: the fields freq of dyn_ltree are set and the total of all
* frequencies does not exceed 64K (to fit in an int on 16 bit machines).
*/
static void set_file_type() {
   int n = 0;
   unsigned int ascii_freq = 0;
   unsigned int bin_freq = 0;
   while(n < 7) bin_freq += dyn_ltree[n++].fc.freq;
   while(n < 128) ascii_freq += dyn_ltree[n++].fc.freq;
   while(n < 256) bin_freq += dyn_ltree[n++].fc.freq;
   *file_type = bin_freq > (ascii_freq >> 2) ? 0 : 1;
   if(*file_type == 0 && 0) {
      clava_dcg_global[ 237 ]++;
      warning("-l used on binary file");
   }
}

/*unlzh.c -- decompress files in SCO compress -H (LZH) format.
* The code in this file is directly derived from the public domain 'ar002'
* written by Haruhiko Okumura.
*/
/*decode.c*/
static unsigned int decode(unsigned int count, uch buffer[]);
static void decode_start();
/*huf.c*/
static void huf_decode_start();
static unsigned int decode_c();
static unsigned int decode_p();
static void read_pt_len(int nn, int nbit, int i_special);
static void read_c_len();
/*io.c*/
static void fillbuf(int n);
static unsigned int getbits(int n);
static void init_getbits();
/*maketbl.c*/
static void make_table(int nchar, uch bitlen[], int tablebits, ush table[]);
/*12(-lh4-) or 13(-lh5-)*/

/*Do not use CHAR_BIT * sizeof(bitbuf), does not work on machines
* for which short is not on 16 bits (Cray).
*/

/*encode.c and decode.c*/

/*formerly F (not more than UCHAR_MAX + 1)*/

/*choose optimal value*/

/*huf.c*/

/*alphabet = {0, 1, 2, ..., NC - 1}*/

/*$\lfloor \log_2 NC \rfloor + 1$*/

/*codeword length*/

/*smallest integer such that (1U << PBIT) > NP*/

/*smallest integer such that (1U << TBIT) > NT*/

/*local ush left[2 * NC - 1];*/

/*local ush right[2 * NC - 1];*/

/*local uch c_len[NC];*/

static uch pt_len[19];
static unsigned int blocksize;
static ush pt_table[256];
/*local ush c_table[4096];*/

/***********************************************************
io.c -- input/output
***********************************************************/

static ush io_bitbuf;
static unsigned int subbitbuf;
static int bitcount;
static void fillbuf(int n) {
   /*Shift io_bitbuf n bits left, read n bits*/
   io_bitbuf <<= n;
   while(n > bitcount) {
      io_bitbuf |= subbitbuf << (n -= bitcount);
      clava_dcg_global[ 238 ]++;
      subbitbuf = (unsigned int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(1));
      if((int) subbitbuf == (-1)) subbitbuf = 0;
      bitcount = 8;
   }
   io_bitbuf |= subbitbuf >> (bitcount -= n);
}

static unsigned int getbits(int n) {
   unsigned int x;
   x = io_bitbuf >> ((8 * 2 * sizeof(char)) - n);
   clava_dcg_global[ 239 ]++;
   fillbuf(n);
   
   return x;
}

static void init_getbits() {
   io_bitbuf = 0;
   subbitbuf = 0;
   bitcount = 0;
   clava_dcg_global[ 240 ]++;
   fillbuf((8 * 2 * sizeof(char)));
}

/***********************************************************
maketbl.c -- make table for decoding
***********************************************************/
static void make_table(int nchar, uch bitlen[], int tablebits, ush table[]) {
   ush count[17];
   ush weight[17];
   ush start[18];
   ush *p;
   unsigned int i, k, len, ch, jutbits, avail, nextcode, mask;
   for(i = 1; i <= 16; i++) count[i] = 0;
   for(i = 0; i < (unsigned int) nchar; i++) count[bitlen[i]]++;
   start[1] = 0;
   for(i = 1; i <= 16; i++) start[i + 1] = start[i] + (count[i] << (16 - i));
   if((start[17] & 0xffff) != 0) {
      clava_dcg_global[ 241 ]++;
      error("Bad table\n");
   }
   jutbits = 16 - tablebits;
   for(i = 1; i <= (unsigned int) tablebits; i++) {
      start[i] >>= jutbits;
      weight[i] = (unsigned int) 1 << (tablebits - i);
   }
   while(i <= 16) {
      weight[i] = (unsigned int) 1 << (16 - i);
      i++;
   }
   i = start[tablebits + 1] >> jutbits;
   if(i != 0) {
      k = 1 << tablebits;
      while(i != k) table[i++] = 0;
   }
   avail = nchar;
   mask = (unsigned int) 1 << (15 - tablebits);
   for(ch = 0; ch < (unsigned int) nchar; ch++) {
      if((len = bitlen[ch]) == 0) continue;
      nextcode = start[len] + weight[len];
      if(len <= (unsigned int) tablebits) {
         for(i = start[len]; i < nextcode; i++) table[i] = ch;
      }
      else {
         k = start[len];
         p = &table[k >> jutbits];
         i = len - tablebits;
         while(i != 0) {
            if(*p == 0) {
               (prev + 0x8000)[avail] = prev[avail] = 0;
               *p = avail++;
            }
            if(k & mask) p = &(prev + 0x8000)[*p];
            else p = &prev[*p];
            k <<= 1;
            i--;
         }
         *p = ch;
      }
      start[len] = nextcode;
   }
}

/***********************************************************
huf.c -- static Huffman
***********************************************************/
static void read_pt_len(int nn, int nbit, int i_special) {
   int i, c, n;
   unsigned int mask;
   clava_dcg_global[ 242 ]++;
   n = getbits(nbit);
   if(n == 0) {
      clava_dcg_global[ 242 ]++;
      c = getbits(nbit);
      for(i = 0; i < nn; i++) pt_len[i] = 0;
      for(i = 0; i < 256; i++) pt_table[i] = c;
   }
   else {
      i = 0;
      while(i < n) {
         c = io_bitbuf >> ((8 * 2 * sizeof(char)) - 3);
         if(c == 7) {
            mask = (unsigned int) 1 << ((8 * 2 * sizeof(char)) - 1 - 3);
            while(mask & io_bitbuf) {
               mask >>= 1;
               c++;
            }
         }
         clava_dcg_global[ 243 ]++;
         fillbuf((c < 7) ? 3 : c - 3);
         pt_len[i++] = c;
         if(i == i_special) {
            clava_dcg_global[ 242 ]++;
            c = getbits(2);
            while(--c >= 0) pt_len[i++] = 0;
         }
      }
      while(i < nn) pt_len[i++] = 0;
      clava_dcg_global[ 244 ]++;
      make_table(nn, pt_len, 8, pt_table);
   }
}

static void read_c_len() {
   int i, c, n;
   unsigned int mask;
   clava_dcg_global[ 245 ]++;
   n = getbits(9);
   if(n == 0) {
      clava_dcg_global[ 245 ]++;
      c = getbits(9);
      for(i = 0; i < ((127 * 2 + 1) + 256 + 2 - 3); i++) outbuf[i] = 0;
      for(i = 0; i < 4096; i++) d_buf[i] = c;
   }
   else {
      i = 0;
      while(i < n) {
         c = pt_table[io_bitbuf >> ((8 * 2 * sizeof(char)) - 8)];
         if(c >= (16 + 3)) {
            mask = (unsigned int) 1 << ((8 * 2 * sizeof(char)) - 1 - 8);
            do  {
               if(io_bitbuf & mask) c = (prev + 0x8000)[c];
               else c = prev[c];
               mask >>= 1;
            }
            while (c >= (16 + 3));
         }
         clava_dcg_global[ 246 ]++;
         fillbuf((int) pt_len[c]);
         if(c <= 2) {
            if(c == 0) c = 1;
            else if(c == 1) {
               clava_dcg_global[ 245 ]++;
               c = getbits(4) + 3;
            }
            else {
               clava_dcg_global[ 245 ]++;
               c = getbits(9) + 20;
            }
            while(--c >= 0) outbuf[i++] = 0;
         }
         else outbuf[i++] = c - 2;
      }
      while(i < ((127 * 2 + 1) + 256 + 2 - 3)) outbuf[i++] = 0;
      clava_dcg_global[ 247 ]++;
      make_table(((127 * 2 + 1) + 256 + 2 - 3), outbuf, 12, d_buf);
   }
}

static unsigned int decode_c() {
   unsigned int j, mask;
   if(blocksize == 0) {
      clava_dcg_global[ 248 ]++;
      blocksize = getbits(16);
      if(blocksize == 0) {
         
         return ((127 * 2 + 1) + 256 + 2 - 3);
         /*end of file*/
      }
      clava_dcg_global[ 249 ]++;
      read_pt_len((16 + 3), 5, 3);
      clava_dcg_global[ 250 ]++;
      read_c_len();
      clava_dcg_global[ 249 ]++;
      read_pt_len((13 + 1), 4, -1);
   }
   blocksize--;
   j = d_buf[io_bitbuf >> ((8 * 2 * sizeof(char)) - 12)];
   if(j >= ((127 * 2 + 1) + 256 + 2 - 3)) {
      mask = (unsigned int) 1 << ((8 * 2 * sizeof(char)) - 1 - 12);
      do  {
         if(io_bitbuf & mask) j = (prev + 0x8000)[j];
         else j = prev[j];
         mask >>= 1;
      }
      while (j >= ((127 * 2 + 1) + 256 + 2 - 3));
   }
   clava_dcg_global[ 251 ]++;
   fillbuf((int) outbuf[j]);
   
   return j;
}

static unsigned int decode_p() {
   unsigned int j, mask;
   j = pt_table[io_bitbuf >> ((8 * 2 * sizeof(char)) - 8)];
   if(j >= (13 + 1)) {
      mask = (unsigned int) 1 << ((8 * 2 * sizeof(char)) - 1 - 8);
      do  {
         if(io_bitbuf & mask) j = (prev + 0x8000)[j];
         else j = prev[j];
         mask >>= 1;
      }
      while (j >= (13 + 1));
   }
   clava_dcg_global[ 252 ]++;
   fillbuf((int) pt_len[j]);
   if(j != 0) {
      clava_dcg_global[ 253 ]++;
      j = ((unsigned int) 1 << (j - 1)) + getbits((int) (j - 1));
   }
   
   return j;
}

static void huf_decode_start() {
   clava_dcg_global[ 254 ]++;
   init_getbits();
   blocksize = 0;
}

/***********************************************************
decode.c
***********************************************************/

static int j;
/*remaining bytes to copy*/

static int done;
/*set at end of input*/
static void decode_start() {
   clava_dcg_global[ 255 ]++;
   huf_decode_start();
   j = 0;
   done = 0;
}

/*Decode the input and return the number of decoded bytes put in buffer
*/
static unsigned int decode(unsigned int count, uch buffer[]) {
   /*The calling function must keep the number of
   bytes to be processed.  This function decodes
   either 'count' bytes or 'DICSIZ' bytes, whichever
   is smaller, into the array 'buffer[]' of size
   'DICSIZ' or more.
   Call decode_start() once for each new file
   before calling this function.
   */
   static unsigned int i;
   unsigned int r, c;
   r = 0;
   while(--j >= 0) {
      buffer[r] = buffer[i];
      i = (i + 1) & (((unsigned int) 1 << 13) - 1);
      if(++r == count) 
      return r;
   }
   for(;;) {
      clava_dcg_global[ 256 ]++;
      c = decode_c();
      if(c == ((127 * 2 + 1) + 256 + 2 - 3)) {
         done = 1;
         
         return r;
      }
      if(c <= (127 * 2 + 1)) {
         buffer[r] = c;
         if(++r == count) 
         return r;
      }
      else {
         j = c - ((127 * 2 + 1) + 1 - 3);
         clava_dcg_global[ 257 ]++;
         i = (r - decode_p() - 1) & (((unsigned int) 1 << 13) - 1);
         while(--j >= 0) {
            buffer[r] = buffer[i];
            i = (i + 1) & (((unsigned int) 1 << 13) - 1);
            if(++r == count) 
            return r;
         }
      }
   }
}

/*===========================================================================
* Unlzh in to out. Return OK or ERROR.
*/
int unlzh(int in, int out) {
   unsigned int n;
   ifd = in;
   ofd = out;
   clava_dcg_global[ 258 ]++;
   decode_start();
   while(!done) {
      clava_dcg_global[ 259 ]++;
      n = decode((unsigned int) ((unsigned int) 1 << 13), window);
      if(!test && n > 0) {
         clava_dcg_global[ 260 ]++;
         write_buf(out, (char *) window, n);
      }
   }
   
   return 0;
}

/*unlzw.c -- decompress files in LZW format.
* The code in this file is directly derived from the public domain 'compress'
* written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,
* Ken Turkowski, Dave Mack and Peter Jannesen.
*
* This is a temporary version which will be rewritten in some future version
* to accommodate in-memory decompression.
*/

typedef unsigned char char_type;
typedef long code_int;
typedef unsigned long count_int;
typedef unsigned short count_short;
typedef unsigned long cmp_code_int;

union bytes {
   long word;
   
   struct anon_gzip_c_7228 {
      int dummy;
   };
   
   struct anon_gzip_c_7228 bytes;
};

/*DECLARE(ush, tab_prefix, (1<<BITS)); -- prefix code*/

/*DECLARE(ush, tab_prefix0, (1<<(BITS-1)); -- prefix for even codes*/

/*DECLARE(ush, tab_prefix1, (1<<(BITS-1)); -- prefix for odd  codes*/

int block_mode = 0x80;
/*block compress mode -C compatible with 2.0*/
/*============================================================================
* Decompress in to out.  This routine adapts to the codes in the
* file building the "string" table on-the-fly; requiring no table to
* be stored in the compressed file.
* IN assertions: the buffer inbuf contains already the beginning of
*   the compressed data, from offsets iptr to insize-1 included.
*   The magic header has already been checked and skipped.
*   bytes_in and bytes_out have been initialized.
*/
int unlzw(int in, int out) {
   /*input and output file descriptors*/
   register char_type *stackp;
   code_int code;
   int finchar;
   code_int oldcode;
   code_int incode;
   long inbits;
   long posbits;
   int outpos;
   /*REG10  int        insize; (global)*/
   unsigned int bitmask;
   code_int free_ent;
   code_int maxcode;
   code_int maxmaxcode;
   int n_bits;
   int rsize;
   clava_dcg_global[ 261 ]++;
   maxbits = (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
   block_mode = maxbits & 0x80;
   if((maxbits & 0x60) != 0) {
      {
         if(!quiet) {
            clava_dcg_global[ 262 ]++;
            fprintf(stderr, "\n%s: %s: warning, unknown flags 0x%x\n", progname, ifname, maxbits & 0x60);
         }
         if(exit_code == 0) exit_code = 2;
      }
      ;
   }
   maxbits &= 0x1f;
   maxmaxcode = (1L << (maxbits));
   if(maxbits > 16) {
      clava_dcg_global[ 262 ]++;
      fprintf(stderr, "\n%s: %s: compressed with %d bits, can only handle %d bits\n", progname, ifname, maxbits, 16);
      exit_code = 1;
      
      return 1;
   }
   rsize = insize;
   maxcode = (1L << (n_bits = 9)) - 1;
   bitmask = (1 << n_bits) - 1;
   oldcode = -1;
   finchar = 0;
   outpos = 0;
   posbits = inptr << 3;
   free_ent = ((block_mode) ? (256 + 1) : 256);
   clava_dcg_global[ 263 ]++;
   memset((voidp) (prev), 0, (256));
   ;
   /*Initialize the first 256 entries in the table.*/
   for(code = 255; code >= 0; --code) {
      window[code] = (char_type) code;
   }
   do  {
      register int i;
      int e;
      int o;
      resetbuf:
      e = insize - (o = (posbits >> 3));
      for(i = 0; i < e; ++i) {
         inbuf[i] = inbuf[i + o];
      }
      insize = e;
      posbits = 0;
      if(insize < 64) {
         clava_dcg_global[ 264 ]++;
         if((rsize = read(in, (char *) inbuf + insize, 0x8000)) == -1) {
            clava_dcg_global[ 265 ]++;
            read_error();
         }
         insize += rsize;
         bytes_in += (off_t) rsize;
      }
      inbits = ((rsize != 0) ? ((long) insize - insize % n_bits) << 3 : ((long) insize << 3) - (n_bits - 1));
      while(inbits > posbits) {
         if(free_ent > maxcode) {
            posbits = ((posbits - 1) + ((n_bits << 3) - (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));
            ++n_bits;
            if(n_bits == maxbits) {
               maxcode = maxmaxcode;
            }
            else {
               maxcode = (1L << (n_bits)) - 1;
            }
            bitmask = (1 << n_bits) - 1;
            goto resetbuf;
         }
         {
            register char_type *p = &(inbuf)[(posbits) >> 3];
            (code) = ((((long) (p[0])) | ((long) (p[1]) << 8) | ((long) (p[2]) << 16)) >> ((posbits) & 0x7)) & (bitmask);
            (posbits) += (n_bits);
         }
         ;
         ;
         if(oldcode == -1) {
            if(code >= 256) {
               clava_dcg_global[ 266 ]++;
               error("corrupt input.");
            }
            outbuf[outpos++] = (char_type) (finchar = (int) (oldcode = code));
            continue;
         }
         if(code == 256 && block_mode) {
            clava_dcg_global[ 263 ]++;
            memset((voidp) (prev), 0, (256));
            ;
            free_ent = (256 + 1) - 1;
            posbits = ((posbits - 1) + ((n_bits << 3) - (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));
            maxcode = (1L << (n_bits = 9)) - 1;
            bitmask = (1 << n_bits) - 1;
            goto resetbuf;
         }
         incode = code;
         stackp = ((char_type *) (&d_buf[0x8000 - 1]));
         if(code >= free_ent) {
            /*Special case for KwKwK string.*/
            if(code > free_ent) {
               if(!test && outpos > 0) {
                  clava_dcg_global[ 267 ]++;
                  write_buf(out, (char *) outbuf, outpos);
                  bytes_out += (off_t) outpos;
               }
               clava_dcg_global[ 266 ]++;
               error(to_stdout ? "corrupt input." : "corrupt input. Use zcat to recover some data.");
            }
            *--stackp = (char_type) finchar;
            code = oldcode;
         }
         while((cmp_code_int) code >= (cmp_code_int) 256) {
            /*Generate output characters in reverse order*/
            *--stackp = window[code];
            code = prev[code];
         }
         *--stackp = (char_type) (finchar = window[code]);
         /*And put them out in forward order*/
         {
            register int i;
            if(outpos + (i = (((char_type *) (&d_buf[0x8000 - 1])) - stackp)) >= 16384) {
               do  {
                  if(i > 16384 - outpos) i = 16384 - outpos;
                  if(i > 0) {
                     clava_dcg_global[ 268 ]++;
                     memcpy(outbuf + outpos, stackp, i);
                     outpos += i;
                  }
                  if(outpos >= 16384) {
                     if(!test) {
                        clava_dcg_global[ 267 ]++;
                        write_buf(out, (char *) outbuf, outpos);
                        bytes_out += (off_t) outpos;
                     }
                     outpos = 0;
                  }
                  stackp += i;
               }
               while ((i = (((char_type *) (&d_buf[0x8000 - 1])) - stackp)) > 0);
            }
            else {
               clava_dcg_global[ 268 ]++;
               memcpy(outbuf + outpos, stackp, i);
               outpos += i;
            }
         }
         if((code = free_ent) < maxmaxcode) {
            /*Generate the new entry.*/
            prev[code] = (unsigned short) oldcode;
            window[code] = (char_type) finchar;
            free_ent = code + 1;
         }
         oldcode = incode;
         /*Remember previous code.*/
      }
   }
   while (rsize != 0);
   if(!test && outpos > 0) {
      clava_dcg_global[ 267 ]++;
      write_buf(out, (char *) outbuf, outpos);
      bytes_out += (off_t) outpos;
   }
   
   return 0;
}

/*unpack.c -- decompress files in pack format.
* Copyright (C) 1992-1993 Jean-loup Gailly
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

/*The arguments must not have side effects.*/

/*Maximum length of Huffman codes. (Minor modifications to the code
* would be needed to support 32 bits codes, but pack never generates
* more than 24 bits anyway.)
*/

/*Number of literals, excluding the End of Block (EOB) code*/

/*Maximum number of 'peek' bits used to optimize traversal of the
* Huffman tree.
*/

static ulg orig_len;
/*original uncompressed length*/

static int max_len;
/*maximum bit length of Huffman codes*/

static uch literal[256];
/*The literal bytes present in the Huffman tree. The EOB code is not
* represented.
*/

static int lit_base[26];
/*All literals of a given bit length are contiguous in literal[] and
* have contiguous codes. literal[code+lit_base[len]] is the literal
* for a code of len bits.
*/

static int leaves[26];
/*Number of leaves for each bit length*/

static int parents[26];
/*Number of parents for each bit length*/

static int peek_bits;
/*Number of peek bits currently used*/

/*local uch prefix_len[1 << MAX_PEEK];*/

/*For each bit pattern b of peek_bits bits, prefix_len[b] is the length
* of the Huffman code starting with a prefix of b (upper bits), or 0
* if all codes of prefix b have more than peek_bits bits. It is not
* necessary to have a huge table (large MAX_PEEK) because most of the
* codes encountered in the input stream are short codes (by construction).
* So for most codes a single lookup will be necessary.
*/

static ulg bitbuf;
/*Bits are added on the low part of bitbuf and read from the high part.*/

static int valid;
/*number of valid bits in bitbuf*/
/*all bits above the last valid bit are always zero*/
/*Set code to the next 'bits' input bits without skipping them. code
* must be the name of a simple variable and bits must not have side effects.
* IN assertions: bits <= 25 (so that we still have room for an extra byte
* when valid is only 24), and mask = (1<<bits)-1.
*/
/*Skip the given number of bits (after having peeked at them):*/
/*Local functions*/
static void read_tree();
static void build_tree();
/*===========================================================================
* Read the Huffman tree.
*/
static void read_tree() {
   int len;
   /*bit length*/
   int base;
   /*base offset for a sequence of leaves*/
   int n;
   /*Read the original input size, MSB first*/
   orig_len = 0;
   for(n = 1; n <= 4; n++) {
      clava_dcg_global[ 269 ]++;
      orig_len = (orig_len << 8) | (ulg) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
   }
   clava_dcg_global[ 269 ]++;
   max_len = (int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
   /*maximum bit length of Huffman codes*/
   if(max_len > 25) {
      clava_dcg_global[ 270 ]++;
      error("invalid compressed data -- Huffman code > 32 bits");
   }
   /*Get the number of leaves at each bit length*/
   n = 0;
   for(len = 1; len <= max_len; len++) {
      clava_dcg_global[ 269 ]++;
      leaves[len] = (int) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      n += leaves[len];
   }
   if(n > 256) {
      clava_dcg_global[ 270 ]++;
      error("too many leaves in Huffman tree");
   }
   ;
   /*There are at least 2 and at most 256 leaves of length max_len.
   * (Pack arbitrarily rejects empty files and files consisting of
   * a single byte even repeated.) To fit the last leaf count in a
   * byte, it is offset by 2. However, the last literal is the EOB
   * code, and is not transmitted explicitly in the tree, so we must
   * adjust here by one only.
   */
   leaves[max_len]++;
   /*Now read the leaves themselves*/
   base = 0;
   for(len = 1; len <= max_len; len++) {
      /*Remember where the literals of this length start in literal[] :*/
      lit_base[len] = base;
      /*And read the literals:*/
      for(n = leaves[len]; n > 0; n--) {
         clava_dcg_global[ 269 ]++;
         literal[base++] = (uch) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
      }
   }
   leaves[max_len]++;
   /*Now include the EOB code in the Huffman tree*/
}

/*===========================================================================
* Build the Huffman tree and the prefix table.
*/
static void build_tree() {
   int nodes = 0;
   /*number of nodes (parents+leaves) at current bit length*/
   int len;
   /*current bit length*/
   uch *prefixp;
   /*pointer in prefix_len*/
   for(len = max_len; len >= 1; len--) {
      /*The number of parent nodes at this level is half the total
      * number of nodes at parent level:
      */
      nodes >>= 1;
      parents[len] = nodes;
      /*Update lit_base by the appropriate bias to skip the parent nodes
      * (which are not represented in the literal array):
      */
      lit_base[len] -= nodes;
      /*Restore nodes to be parents+leaves:*/
      nodes += leaves[len];
   }
   /*Construct the prefix table, from shortest leaves to longest ones.
   * The shortest code is all ones, so we start at the end of the table.
   */
   peek_bits = ((max_len) <= (12) ? (max_len) : (12));
   prefixp = &outbuf[1 << peek_bits];
   for(len = 1; len <= peek_bits; len++) {
      int prefixes = leaves[len] << (peek_bits - len);
      /*may be 0*/
      while(prefixes--) *--prefixp = (uch) len;
   }
   /*The length of all other codes is unknown:*/
   while(prefixp > outbuf) *--prefixp = 0;
}

/*===========================================================================
* Unpack in to out.  This routine does not support the old pack format
* with magic header \037\037.
*
* IN assertions: the buffer inbuf contains already the beginning of
*   the compressed data, from offsets inptr to insize-1 included.
*   The magic header has already been checked. The output buffer is cleared.
*/
int unpack(int in, int out) {
   /*input and output file descriptors*/
   int len;
   /*Bit length of current code*/
   unsigned int eob;
   /*End Of Block code*/
   register unsigned int peek;
   /*lookahead bits*/
   unsigned int peek_mask;
   /*Mask for peek_bits bits*/
   ifd = in;
   ofd = out;
   clava_dcg_global[ 271 ]++;
   read_tree();
   /*Read the Huffman tree*/
   clava_dcg_global[ 272 ]++;
   build_tree();
   /*Build the prefix table*/
   (valid = 0 , bitbuf = 0);
   /*Initialize bit input*/
   peek_mask = (1 << peek_bits) - 1;
   /*The eob code is the largest code among all leaves of maximal length:*/
   eob = leaves[max_len] - 1;
   ;
   /*Decode the input data:*/
   for(;;) {
      /*Since eob is the longest code and not shorter than max_len,
      * we can peek at max_len bits without having the risk of reading
      * beyond the end of file.
      */
      {
         while(valid < (peek_bits)) {
            clava_dcg_global[ 273 ]++;
            bitbuf = (bitbuf << 8) | (ulg) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0)) , valid += 8;
         }
         peek = (bitbuf >> (valid - (peek_bits))) & (peek_mask);
      }
      ;
      len = outbuf[peek];
      if(len > 0) {
         peek >>= peek_bits - len;
         /*discard the extra bits*/
      }
      else {
         /*Code of more than peek_bits bits, we must traverse the tree*/
         ulg mask = peek_mask;
         len = peek_bits;
         do  {
            len++ , mask = (mask << 1) + 1;
            {
               while(valid < (len)) {
                  clava_dcg_global[ 273 ]++;
                  bitbuf = (bitbuf << 8) | (ulg) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0)) , valid += 8;
               }
               peek = (bitbuf >> (valid - (len))) & (mask);
            }
            ;
         }
         while (peek < (unsigned int) parents[len]);
         /*loop as long as peek is a parent node*/
      }
      /*At this point, peek is the next complete code, of len bits*/
      if(peek == eob && len == max_len) break;
      /*end of file?*/
      {
         window[outcnt++] = (uch) (literal[peek + lit_base[len]]);
         if(outcnt == 0x8000) {
            clava_dcg_global[ 274 ]++;
            flush_window();
         }
      }
      ;
      ;
      (valid -= (len));
   }
   /*for (;;)*/
   clava_dcg_global[ 274 ]++;
   flush_window();
   if(orig_len != (ulg) (bytes_out & 0xffffffff)) {
      clava_dcg_global[ 275 ]++;
      error("invalid compressed data--length error");
   }
   
   return 0;
}

/*unzip.c -- decompress files in gzip or pkzip format.
* Copyright (C) 1992-1993 Jean-loup Gailly
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*
* The code in this file is derived from the file funzip.c written
* and put in the public domain by Mark Adler.
*/

/*
This version can extract files in gzip or pkzip format.
For the latter, only the first entry is extracted, and it has to be
either deflated or stored.
*/

/*PKZIP header definitions*/

/*four-byte lead-in (lsb first)*/

/*offset of bit flag*/

/*bit for encrypted entry*/

/*bit for extended local header*/

/*offset of compression method*/

/*file mod time (for decryption)*/

/*offset of crc*/

/*offset of compressed size*/

/*offset of uncompressed length*/

/*offset of file name field length*/

/*offset of extra field length*/

/*size of local header, including sig*/

/*size of extended local header, inc sig*/

/*length of encryption random header*/

/*Globals*/

int decrypt;
/*flag to turn on decryption*/

char *key;
/*not used--needed to link crypt.c*/

int pkzip = 0;
/*set for a pkzip file*/

int ext_header = 0;
/*set if extended local header*/
/*===========================================================================
* Check zip file and advance inptr to the start of the compressed data.
* Get ofname from the local header if necessary.
*/
int check_zipfile(int in) {
   /*input file descriptors*/
   uch *h = inbuf + inptr;
   /*first local header*/
   ifd = in;
   /*Check validity of local header, and skip name and extra fields*/
   inptr += 30 + ((ush) (uch) ((h + 26)[0]) | ((ush) (uch) ((h + 26)[1]) << 8)) + ((ush) (uch) ((h + 28)[0]) | ((ush) (uch) ((h + 28)[1]) << 8));
   if(inptr > insize || ((ulg) (((ush) (uch) ((h)[0]) | ((ush) (uch) ((h)[1]) << 8))) | ((ulg) (((ush) (uch) (((h) + 2)[0]) | ((ush) (uch) (((h) + 2)[1]) << 8))) << 16)) != 0x04034b50L) {
      clava_dcg_global[ 276 ]++;
      fprintf(stderr, "\n%s: %s: not a valid zip file\n", progname, ifname);
      exit_code = 1;
      
      return 1;
   }
   method = h[8];
   if(method != 0 && method != 8) {
      clava_dcg_global[ 276 ]++;
      fprintf(stderr, "\n%s: %s: first entry not deflated or stored -- use unzip\n", progname, ifname);
      exit_code = 1;
      
      return 1;
   }
   /*If entry encrypted, decrypt and validate encryption header*/
   if((decrypt = h[6] & 1) != 0) {
      clava_dcg_global[ 276 ]++;
      fprintf(stderr, "\n%s: %s: encrypted file -- use unzip\n", progname, ifname);
      exit_code = 1;
      
      return 1;
   }
   /*Save flags for unzip()*/
   ext_header = (h[6] & 8) != 0;
   pkzip = 1;
   /*Get ofname and time stamp from local header (to be done)*/
   
   return 0;
}

/*===========================================================================
* Unzip in to out.  This routine works on both gzip and pkzip files.
*
* IN assertions: the buffer inbuf contains already the beginning of
*   the compressed data, from offsets inptr to insize-1 included.
*   The magic header has already been checked. The output buffer is cleared.
*/
int unzip(int in, int out) {
   /*input and output file descriptors*/
   ulg orig_crc = 0;
   /*original crc*/
   ulg orig_len = 0;
   /*original uncompressed length*/
   int n;
   uch buf[16];
   /*extended local header*/
   int err = 0;
   ifd = in;
   ofd = out;
   clava_dcg_global[ 277 ]++;
   updcrc(((void *) 0), 0);
   /*initialize crc*/
   if(pkzip && !ext_header) {
      /*crc and length at the end otherwise*/
      orig_crc = ((ulg) (((ush) (uch) ((inbuf + 14)[0]) | ((ush) (uch) ((inbuf + 14)[1]) << 8))) | ((ulg) (((ush) (uch) (((inbuf + 14) + 2)[0]) | ((ush) (uch) (((inbuf + 14) + 2)[1]) << 8))) << 16));
      orig_len = ((ulg) (((ush) (uch) ((inbuf + 22)[0]) | ((ush) (uch) ((inbuf + 22)[1]) << 8))) | ((ulg) (((ush) (uch) (((inbuf + 22) + 2)[0]) | ((ush) (uch) (((inbuf + 22) + 2)[1]) << 8))) << 16));
   }
   /*Decompress*/
   if(method == 8) {
      clava_dcg_global[ 278 ]++;
      int res = inflate();
      if(res == 3) {
         clava_dcg_global[ 279 ]++;
         error("out of memory");
      }
      else if(res != 0) {
         clava_dcg_global[ 279 ]++;
         error("invalid compressed data--format violated");
      }
   }
   else if(pkzip && method == 0) {
      register ulg n = ((ulg) (((ush) (uch) ((inbuf + 22)[0]) | ((ush) (uch) ((inbuf + 22)[1]) << 8))) | ((ulg) (((ush) (uch) (((inbuf + 22) + 2)[0]) | ((ush) (uch) (((inbuf + 22) + 2)[1]) << 8))) << 16));
      if(n != ((ulg) (((ush) (uch) ((inbuf + 18)[0]) | ((ush) (uch) ((inbuf + 18)[1]) << 8))) | ((ulg) (((ush) (uch) (((inbuf + 18) + 2)[0]) | ((ush) (uch) (((inbuf + 18) + 2)[1]) << 8))) << 16)) - (decrypt ? 12 : 0)) {
         clava_dcg_global[ 280 ]++;
         fprintf(stderr, "len %ld, siz %ld\n", n, ((ulg) (((ush) (uch) ((inbuf + 18)[0]) | ((ush) (uch) ((inbuf + 18)[1]) << 8))) | ((ulg) (((ush) (uch) (((inbuf + 18) + 2)[0]) | ((ush) (uch) (((inbuf + 18) + 2)[1]) << 8))) << 16)));
         clava_dcg_global[ 279 ]++;
         error("invalid compressed data--length mismatch");
      }
      while(n--) {
         clava_dcg_global[ 281 ]++;
         uch c = (uch) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
         {
            window[outcnt++] = (uch) (c);
            if(outcnt == 0x8000) {
               clava_dcg_global[ 282 ]++;
               flush_window();
            }
         }
         ;
      }
      clava_dcg_global[ 282 ]++;
      flush_window();
   }
   else {
      clava_dcg_global[ 279 ]++;
      error("internal error, invalid method");
   }
   /*Get the crc and original length*/
   if(!pkzip) {
      /*crc32  (see algorithm.doc)
      * uncompressed input size modulo 2^32
      */
      for(n = 0; n < 8; n++) {
         clava_dcg_global[ 281 ]++;
         buf[n] = (uch) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
         /*may cause an error if EOF*/
      }
      orig_crc = ((ulg) (((ush) (uch) ((buf)[0]) | ((ush) (uch) ((buf)[1]) << 8))) | ((ulg) (((ush) (uch) (((buf) + 2)[0]) | ((ush) (uch) (((buf) + 2)[1]) << 8))) << 16));
      orig_len = ((ulg) (((ush) (uch) ((buf + 4)[0]) | ((ush) (uch) ((buf + 4)[1]) << 8))) | ((ulg) (((ush) (uch) (((buf + 4) + 2)[0]) | ((ush) (uch) (((buf + 4) + 2)[1]) << 8))) << 16));
   }
   else if(ext_header) {
      /*If extended header, check it*/
      /*signature - 4bytes: 0x50 0x4b 0x07 0x08
      * CRC-32 value
      * compressed size 4-bytes
      * uncompressed size 4-bytes
      */
      for(n = 0; n < 16; n++) {
         clava_dcg_global[ 281 ]++;
         buf[n] = (uch) (inptr < insize ? inbuf[inptr++] : fill_inbuf(0));
         /*may cause an error if EOF*/
      }
      orig_crc = ((ulg) (((ush) (uch) ((buf + 4)[0]) | ((ush) (uch) ((buf + 4)[1]) << 8))) | ((ulg) (((ush) (uch) (((buf + 4) + 2)[0]) | ((ush) (uch) (((buf + 4) + 2)[1]) << 8))) << 16));
      orig_len = ((ulg) (((ush) (uch) ((buf + 12)[0]) | ((ush) (uch) ((buf + 12)[1]) << 8))) | ((ulg) (((ush) (uch) (((buf + 12) + 2)[0]) | ((ush) (uch) (((buf + 12) + 2)[1]) << 8))) << 16));
   }
   /*Validate decompression*/
   clava_dcg_global[ 277 ]++;
   if(orig_crc != updcrc(outbuf, 0)) {
      clava_dcg_global[ 280 ]++;
      fprintf(stderr, "\n%s: %s: invalid compressed data--crc error\n", progname, ifname);
      err = 1;
   }
   if(orig_len != (ulg) (bytes_out & 0xffffffff)) {
      clava_dcg_global[ 280 ]++;
      fprintf(stderr, "\n%s: %s: invalid compressed data--length error\n", progname, ifname);
      err = 1;
   }
   /*Check if there are more entries in a pkzip file*/
   if(pkzip && inptr + 4 < insize && ((ulg) (((ush) (uch) ((inbuf + inptr)[0]) | ((ush) (uch) ((inbuf + inptr)[1]) << 8))) | ((ulg) (((ush) (uch) (((inbuf + inptr) + 2)[0]) | ((ush) (uch) (((inbuf + inptr) + 2)[1]) << 8))) << 16)) == 0x04034b50L) {
      if(to_stdout) {
         {
            if(!quiet) {
               clava_dcg_global[ 280 ]++;
               fprintf(stderr, "%s: %s has more than one entry--rest ignored\n", progname, ifname);
            }
            if(exit_code == 0) exit_code = 2;
         }
         ;
      }
      else {
         /*Don't destroy the input zip file*/
         clava_dcg_global[ 280 ]++;
         fprintf(stderr, "%s: %s has more than one entry -- unchanged\n", progname, ifname);
         err = 1;
      }
   }
   ext_header = pkzip = 0;
   /*for next file*/
   if(err == 0) 
   return 0;
   exit_code = 1;
   if(!test) {
      clava_dcg_global[ 283 ]++;
      abort_gzip();
   }
   
   return err;
}

/*util.c -- utility functions for gzip support
* Copyright (C) 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
* Copyright (C) 1992-1993 Jean-loup Gailly
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

extern ulg crc_32_tab[];
/*crc table, defined below*/
/*===========================================================================
* Copy input to output unchanged: zcat == cat with --force.
* IN assertion: insize bytes have already been read in inbuf.
*/
int copy(int in, int out) {
   /*input and output file descriptors*/
   clava_dcg_global[ 284 ]++;
   (*__errno_location()) = 0;
   while(insize != 0 && (int) insize != -1) {
      clava_dcg_global[ 285 ]++;
      write_buf(out, (char *) inbuf, insize);
      bytes_out += insize;
      clava_dcg_global[ 286 ]++;
      insize = read(in, (char *) inbuf, 0x8000);
   }
   if((int) insize == -1) {
      clava_dcg_global[ 287 ]++;
      read_error();
   }
   bytes_in = bytes_out;
   
   return 0;
}

/*===========================================================================
* Run a set of bytes through the crc shift register.  If s is a NULL
* pointer, then initialize the crc shift register contents instead.
* Return the current crc in either case.
*/
ulg updcrc(uch *s, unsigned int n) {
   /*pointer to bytes to pump through*/
   /*number of bytes in s[]*/
   register ulg c;
   /*temporary variable*/
   static ulg crc = (ulg) 0xffffffffL;
   /*shift register contents*/
   if(s == ((void *) 0)) {
      c = 0xffffffffL;
   }
   else {
      c = crc;
      if(n) do  {
         c = crc_32_tab[((int) c ^ (*s++)) & 0xff] ^ (c >> 8);
      }
      while (--n);
   }
   crc = c;
   
   return c ^ 0xffffffffL;
   /*(instead of ~c for 64-bit machines)*/
}

/*===========================================================================
* Clear input and output buffers
*/
void clear_bufs() {
   outcnt = 0;
   insize = inptr = 0;
   bytes_in = bytes_out = 0L;
}

/*===========================================================================
* Fill the input buffer. This is called only when the buffer is empty.
*/
int fill_inbuf(int eof_ok) {
   /*set if EOF acceptable as a result*/
   int len;
   /*Read as much as possible*/
   insize = 0;
   do  {
      clava_dcg_global[ 288 ]++;
      len = read(ifd, (char *) inbuf + insize, 0x8000 - insize);
      if(len == 0) break;
      if(len == -1) {
         clava_dcg_global[ 289 ]++;
         read_error();
         break;
      }
      insize += len;
   }
   while (insize < 0x8000);
   if(insize == 0) {
      if(eof_ok) 
      return (-1);
      clava_dcg_global[ 290 ]++;
      flush_window();
      clava_dcg_global[ 291 ]++;
      (*__errno_location()) = 0;
      clava_dcg_global[ 289 ]++;
      read_error();
   }
   bytes_in += (off_t) insize;
   inptr = 1;
   
   return inbuf[0];
}

/*===========================================================================
* Write the output buffer outbuf[0..outcnt-1] and update bytes_out.
* (used for the compressed data only)
*/
void flush_outbuf() {
   if(outcnt == 0) 
   return;
   clava_dcg_global[ 292 ]++;
   write_buf(ofd, (char *) outbuf, outcnt);
   bytes_out += (off_t) outcnt;
   outcnt = 0;
}

/*===========================================================================
* Write the output window window[0..outcnt-1] and update crc and bytes_out.
* (Used for the decompressed data only.)
*/
void flush_window() {
   if(outcnt == 0) 
   return;
   clava_dcg_global[ 293 ]++;
   updcrc(window, outcnt);
   if(!test) {
      clava_dcg_global[ 294 ]++;
      write_buf(ofd, (char *) window, outcnt);
   }
   bytes_out += (off_t) outcnt;
   outcnt = 0;
}

/*===========================================================================
* Does the same as write(), but also handles partial pipe writes and checks
* for error return.
*/
void write_buf(int fd, voidp buf, unsigned int cnt) {
   unsigned int n;
   while((n = write(fd, buf, cnt)) != cnt) {
      clava_dcg_global[ 295 ]++;
      if(n == (unsigned int) (-1)) {
         clava_dcg_global[ 296 ]++;
         write_error();
      }
      cnt -= n;
      buf = (voidp) ((char *) buf + n);
   }
}

/*========================================================================
* Put string s in lower case, return s.
*/
char * strlwr(char *s) {
   char *t;
   for(t = s; *t; t++) {
      clava_dcg_global[ 297 ]++;
      clava_dcg_global[ 298 ]++;
      *t = (((*__ctype_b_loc())[(int) (((unsigned char) *t))] & (unsigned short) _ISupper) ? tolower((unsigned char) *t) : ((unsigned char) *t));
   }
   
   return s;
}

/*========================================================================
* Return the base name of a file (remove any directory prefix and
* any version suffix). For systems with file names that are not
* case sensitive, force the base name to lower case.
*/
char * base_name(char *fname) {
   char *p;
   clava_dcg_global[ 299 ]++;
   if((p = strrchr(fname, '/')) != ((void *) 0)) fname = p + 1;
   if(('A') == 'a') {
      clava_dcg_global[ 300 ]++;
      strlwr(fname);
   }
   
   return fname;
}

/*========================================================================
* Unlink a file, working around the unlink readonly bug (if present).
*/
int xunlink(char *filename) {
   clava_dcg_global[ 301 ]++;
   int r = unlink(filename);
   
   return r;
}

/*========================================================================
* Make a file name legal for file systems not allowing file names with
* multiple dots or starting with a dot (such as MSDOS), by changing
* all dots except the last one into underlines.  A target dependent
* function can be used instead of this simple function by defining the macro
* MAKE_LEGAL_NAME in tailor.h and providing the function in a target
* dependent module.
*/
void make_simple_name(char *name) {
   clava_dcg_global[ 302 ]++;
   char *p = strrchr(name, '.');
   if(p == ((void *) 0)) 
   return;
   if(p == name) p++;
   do  {
      if(*--p == '.') *p = '_';
   }
   while (p != name);
}

/*Provide missing strspn and strcspn functions.*/
/*========================================================================
* Return the length of the maximum initial segment
* of s which contains only characters in accept.
*/
/*========================================================================
* Return the length of the maximum inital segment of s
* which contains no characters from reject.
*/
/*========================================================================
* Add an environment variable (if any) before argv, and update argc.
* Return the expanded environment variable to be freed later, or NULL
* if no options were added to argv.
*/
char * add_envopt(int *argcp, char ***argvp, char *env) {
   /*pointer to argc*/
   /*pointer to argv*/
   /*name of environment variable*/
   char *p;
   /*running pointer through env variable*/
   char **oargv;
   /*runs through old argv array*/
   char **nargv;
   /*runs through new argv array*/
   int oargc = *argcp;
   /*old argc*/
   int nargc = 0;
   /*number of arguments in env variable*/
   clava_dcg_global[ 303 ]++;
   env = (char *) getenv(env);
   if(env == ((void *) 0)) 
   return ((void *) 0);
   clava_dcg_global[ 304 ]++;
   clava_dcg_global[ 305 ]++;
   p = (char *) xmalloc(strlen(env) + 1);
   clava_dcg_global[ 306 ]++;
   env = strcpy(p, env);
   /*keep env variable intact*/
   for(p = env; *p; nargc++) {
      /*move through env*/
      clava_dcg_global[ 307 ]++;
      p += strspn(p, " \t");
      /*skip leading separators*/
      if(*p == '\0') break;
      clava_dcg_global[ 308 ]++;
      p += strcspn(p, " \t");
      /*find end of word*/
      if(*p) *p++ = '\0';
      /*mark it*/
   }
   if(nargc == 0) {
      clava_dcg_global[ 309 ]++;
      free(env);
      
      return ((void *) 0);
   }
   *argcp += nargc;
   /*Allocate the new argv array, with an extra element just in case
   * the original arg list did not end with a NULL.
   */
   clava_dcg_global[ 310 ]++;
   nargv = (char **) calloc(*argcp + 1, sizeof(char *));
   if(nargv == ((void *) 0)) {
      clava_dcg_global[ 311 ]++;
      error("out of memory");
   }
   oargv = *argvp;
   *argvp = nargv;
   /*Copy the program name first*/
   if(oargc-- < 0) {
      clava_dcg_global[ 311 ]++;
      error("argc<=0");
   }
   *(nargv++) = *(oargv++);
   /*Then copy the environment args*/
   for(p = env; nargc > 0; nargc--) {
      clava_dcg_global[ 307 ]++;
      p += strspn(p, " \t");
      /*skip separators*/
      *(nargv++) = p;
      /*store start*/
      while(*p++);
      /*skip over word*/
   }
   /*Finally copy the old args and add a NULL (usual convention)*/
   while(oargc--) *(nargv++) = *(oargv++);
   *nargv = ((void *) 0);
   
   return env;
}

/*========================================================================
* Error handlers.
*/
void error(char *m) {
   clava_dcg_global[ 312 ]++;
   fprintf(stderr, "\n%s: %s: %s\n", progname, ifname, m);
   clava_dcg_global[ 313 ]++;
   abort_gzip();
}

void warning(char *m) {
   {
      if(!quiet) {
         clava_dcg_global[ 314 ]++;
         fprintf(stderr, "%s: %s: warning: %s\n", progname, ifname, m);
      }
      if(exit_code == 0) exit_code = 2;
   }
   ;
}

void read_error() {
   clava_dcg_global[ 315 ]++;
   int e = (*__errno_location());
   clava_dcg_global[ 316 ]++;
   fprintf(stderr, "\n%s: ", progname);
   if(e != 0) {
      clava_dcg_global[ 315 ]++;
      (*__errno_location()) = e;
      clava_dcg_global[ 317 ]++;
      perror(ifname);
   }
   else {
      clava_dcg_global[ 316 ]++;
      fprintf(stderr, "%s: unexpected end of file\n", ifname);
   }
   clava_dcg_global[ 318 ]++;
   abort_gzip();
}

void write_error() {
   clava_dcg_global[ 319 ]++;
   int e = (*__errno_location());
   clava_dcg_global[ 320 ]++;
   fprintf(stderr, "\n%s: ", progname);
   clava_dcg_global[ 319 ]++;
   (*__errno_location()) = e;
   clava_dcg_global[ 321 ]++;
   perror(ofname);
   clava_dcg_global[ 322 ]++;
   abort_gzip();
}

/*========================================================================
* Display compression ratio on the given stream on 6 characters.
*/
void display_ratio(off_t num, off_t den, FILE *file) {
   clava_dcg_global[ 323 ]++;
   fprintf(file, "%5.1f%%", den == 0 ? 0 : 100.0 * num / den);
}

/*========================================================================
* Print an off_t.  There's no completely portable way to use printf,
* so we do it ourselves.
*/
void fprint_off(FILE *file, off_t offset, int width) {
   char buf[64];
   char *p = buf + sizeof(buf);
   /*Don't negate offset here; it might overflow.*/
   if(offset < 0) {
      do  *--p = '0' - offset % 10;while ((offset /= 10) != 0);
      *--p = '-';
   }
   else {
      do  *--p = '0' + offset % 10;while ((offset /= 10) != 0);
   }
   width -= buf + sizeof(buf) - p;
   while(0 < width--) {
      clava_dcg_global[ 324 ]++;
      _IO_putc(' ', file);
   }
   for(; p < buf + sizeof(buf); p++) {
      clava_dcg_global[ 324 ]++;
      _IO_putc(*p, file);
   }
}

/*========================================================================
* Semi-safe malloc -- never returns NULL.
*/
voidp xmalloc(unsigned int size) {
   clava_dcg_global[ 325 ]++;
   voidp cp = (voidp) malloc(size);
   if(cp == ((void *) 0)) {
      clava_dcg_global[ 326 ]++;
      error("out of memory");
   }
   
   return cp;
}

/*========================================================================
* Table of CRC-32's of all single-byte values (made by makecrc.c)
*/

ulg crc_32_tab[256] = {0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL, 0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL, 0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L, 0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L, 0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L, 0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL, 0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L, 0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L, 0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L, 0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L, 0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL, 0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L, 0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL};
/*yesno.c -- read a yes/no response from stdin
Copyright (C) 1990, 1998 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/
/*Read one line from standard input
and return nonzero if that line begins with y or Y,
otherwise return 0.*/
__attribute__((nonnull(1)))
__attribute__((no_throw))
int rpmatch(char const *);
int yesno() {
   /*We make some assumptions here:
   a) leading white space in the response are not vital
   b) the first 128 characters of the answer are enough (the rest can
   be ignored)
   I cannot think for a situation where this is not ok.  --drepper@gnu*/
   char buf[128];
   int len = 0;
   int c;
   while((c = getchar()) != (-1) && c != '\n') {
      clava_dcg_global[ 327 ]++;
      clava_dcg_global[ 328 ]++;
      if((len > 0 && len < 127) || (len == 0 && !((*__ctype_b_loc())[(int) ((c))] & (unsigned short) _ISspace))) buf[len++] = c;
   }
   buf[len] = '\0';
   clava_dcg_global[ 329 ]++;
   
   return rpmatch(buf) == 1;
}

/*zip.c -- compress files to the gzip or pkzip format
* Copyright (C) 1992-1993 Jean-loup Gailly
* This is free software; you can redistribute it and/or modify it under the
* terms of the GNU General Public License, see the file COPYING.
*/

static ulg crc;
/*crc on uncompressed file data*/

off_t header_bytes;
/*number of bytes in gzip header*/
/*===========================================================================
* Deflate in to out.
* IN assertions: the input and output buffers are cleared.
*   The variables time_stamp and save_orig_name are initialized.
*/
int zip(int in, int out) {
   /*input and output file descriptors*/
   uch flags = 0;
   /*general purpose bit flags*/
   ush attr = 0;
   /*ascii/binary flag*/
   ush deflate_flags = 0;
   /*pkzip -es, -en or -ex equivalent*/
   ifd = in;
   ofd = out;
   outcnt = 0;
   /*Write the header to the gzip file. See algorithm.doc for the format*/
   method = 8;
   {
      outbuf[outcnt++] = (uch) (""[0]);
      if(outcnt == 16384) {
         clava_dcg_global[ 330 ]++;
         flush_outbuf();
      }
   }
   ;
   /*magic header*/
   {
      outbuf[outcnt++] = (uch) (""[1]);
      if(outcnt == 16384) {
         clava_dcg_global[ 330 ]++;
         flush_outbuf();
      }
   }
   ;
   {
      outbuf[outcnt++] = (uch) (8);
      if(outcnt == 16384) {
         clava_dcg_global[ 330 ]++;
         flush_outbuf();
      }
   }
   ;
   /*compression method*/
   if(save_orig_name) {
      flags |= 0x08;
   }
   {
      outbuf[outcnt++] = (uch) (flags);
      if(outcnt == 16384) {
         clava_dcg_global[ 330 ]++;
         flush_outbuf();
      }
   }
   ;
   /*general flags*/
   {
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) (((time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0) & 0xffff) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) ((time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0) & 0xffff) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) (((time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0) & 0xffff) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) ((time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0) & 0xffff) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) ((((ulg) (time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0)) >> 16) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) (((ulg) (time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0)) >> 16) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) ((((ulg) (time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0)) >> 16) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) (((ulg) (time_stamp == (time_stamp & 0xffffffff) ? (ulg) time_stamp : (ulg) 0)) >> 16) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
   }
   ;
   /*Write deflated file to zip file*/
   clava_dcg_global[ 331 ]++;
   crc = updcrc(0, 0);
   clava_dcg_global[ 332 ]++;
   bi_init(out);
   clava_dcg_global[ 333 ]++;
   ct_init(&attr, &method);
   clava_dcg_global[ 334 ]++;
   lm_init(level, &deflate_flags);
   {
      outbuf[outcnt++] = (uch) ((uch) deflate_flags);
      if(outcnt == 16384) {
         clava_dcg_global[ 330 ]++;
         flush_outbuf();
      }
   }
   ;
   /*extra flags*/
   {
      outbuf[outcnt++] = (uch) (0x03);
      if(outcnt == 16384) {
         clava_dcg_global[ 330 ]++;
         flush_outbuf();
      }
   }
   ;
   /*OS identifier*/
   if(save_orig_name) {
      clava_dcg_global[ 335 ]++;
      char *p = base_name(ifname);
      /*Don't save the directory part.*/
      do  {
         {
            outbuf[outcnt++] = (uch) (*p);
            if(outcnt == 16384) {
               clava_dcg_global[ 330 ]++;
               flush_outbuf();
            }
         }
         ;
      }
      while (*p++);
   }
   header_bytes = (off_t) outcnt;
   clava_dcg_global[ 336 ]++;
   (void) deflate();
   /*Check input size (but not in VMS -- variable record lengths mess it up)
   * and not on MSDOS -- diet in TSR mode reports an incorrect file size)
   */
   /*Write the crc and uncompressed size*/
   {
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) (((crc) & 0xffff) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) ((crc) & 0xffff) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) (((crc) & 0xffff) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) ((crc) & 0xffff) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) ((((ulg) (crc)) >> 16) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) (((ulg) (crc)) >> 16) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) ((((ulg) (crc)) >> 16) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) (((ulg) (crc)) >> 16) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
   }
   ;
   {
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) ((((ulg) bytes_in) & 0xffff) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) (((ulg) bytes_in) & 0xffff) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) ((((ulg) bytes_in) & 0xffff) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) (((ulg) bytes_in) & 0xffff) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
      {
         if(outcnt < 16384 - 2) {
            outbuf[outcnt++] = (uch) ((((ulg) ((ulg) bytes_in)) >> 16) & 0xff);
            outbuf[outcnt++] = (uch) ((ush) (((ulg) ((ulg) bytes_in)) >> 16) >> 8);
         }
         else {
            {
               outbuf[outcnt++] = (uch) ((uch) ((((ulg) ((ulg) bytes_in)) >> 16) & 0xff));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
            {
               outbuf[outcnt++] = (uch) ((uch) ((ush) (((ulg) ((ulg) bytes_in)) >> 16) >> 8));
               if(outcnt == 16384) {
                  clava_dcg_global[ 330 ]++;
                  flush_outbuf();
               }
            }
            ;
         }
      }
      ;
   }
   ;
   header_bytes += 2 * sizeof(long);
   clava_dcg_global[ 330 ]++;
   flush_outbuf();
   
   return 0;
}

/*===========================================================================
* Read a new buffer from the current input file, perform end-of-line
* translation, and update the crc and input file size.
* IN assertion: size >= 2 (for end-of-line translation)
*/
int file_read(char *buf, unsigned int size) {
   unsigned int len;
   ;
   clava_dcg_global[ 337 ]++;
   len = read(ifd, buf, size);
   if(len == 0) 
   return (int) len;
   if(len == (unsigned int) -1) {
      clava_dcg_global[ 338 ]++;
      read_error();
      
      return (-1);
   }
   clava_dcg_global[ 339 ]++;
   crc = updcrc((uch *) buf, len);
   bytes_in += (off_t) len;
   
   return (int) len;
}

/*Determine whether string value is affirmation or negative response
according to current locale's data.
Copyright (C) 1996, 1998, 2000 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/
__attribute__((nonnull(1)))
__attribute__((no_throw))
int rpmatch(char const *response) {
   /*Test against "^[yY]" and "^[nN]", hardcoded to avoid requiring regex*/
   
   return (*response == 'y' || *response == 'Y' ? 1 : *response == 'n' || *response == 'N' ? 0 : -1);
}

int getopt_long(int argc, char * const *argv, char const *options, struct option const *long_options, int *opt_index) {
   clava_dcg_global[ 340 ]++;
   
   return _getopt_internal(argc, argv, options, long_options, opt_index, 0);
}

/*Like getopt_long, but '-' as well as '--' can indicate a long option.
If an option that starts with '-' (not '--') doesn't match a long option,
but does match a short option, it is parsed as a short option
instead.*/
int getopt_long_only(int argc, char * const *argv, char const *options, struct option const *long_options, int *opt_index) {
   clava_dcg_global[ 341 ]++;
   
   return _getopt_internal(argc, argv, options, long_options, opt_index, 1);
}
